#!/usr/bin/env python3

import pymongo
import sys,os,time,pickle,urllib.request,getopt,subprocess,random,operator,datetime
import re
from math import *
from numpy import *
from numpy.linalg import *
from numpy.fft import *

############## tinymongo ################
import tinydb
import tinymongo as tm
from tinymongo.serializers import DateTimeSerializer
from tinydb_serialization import SerializationMiddleware
class TinyMongoClient(tm.TinyMongoClient):
    @property
    def _storage(self):
        return tinydb.storages.JSONStorage
class CustomClient(TinyMongoClient):
    @property
    def _storage(self):
        serialization = SerializationMiddleware()
        serialization.register_serializer(DateTimeSerializer(), 'TinyDate')
        # register other custom serializers
        return serialization
############## tinymongo ################

############## wrapptermongo ################
class CustomCollection:
    def __init__(self, collection, is_mongo):
        self.collection = collection
        self.is_mongo = is_mongo

    def insert(self, entry):
        if self.is_mongo:
            return self.collection.insert_one(entry).inserted_id
        else:
            return self.collection.insert(entry)

    def remove(self, delentry):
        if self.is_mongo:
            return self.collection.delete_one(delentry)
        else:
            return self.collection.remove(delentry)

    def count(self):
        if self.is_mongo:
            return self.collection.count_documents({})
        else:
            return self.collection.count()  # Use the count method for TinyMongo

    def find_count(self,filter=None,projection=None):
        if self.is_mongo:
            return self.collection.count_documents(filter, projection)
        else:
            return self.collection.find(filter, e=projection).count()

    def find(self, filter=None, projection=None):
        if self.is_mongo:
            return self.collection.find(filter, projection)
        else:
            return self.collection.find(filter, e=projection)

    def find_one(self, check):
        if self.is_mongo:
            return self.collection.find_one(check)
        else:
            return self.collection.find_one(check)

    def update(self, check, new_values, upsert=False, multi=False):
        if self.is_mongo:
            return self.collection.update_many(check, new_values, upsert=upsert)
        else:
            return self.collection.update(check, new_values, upsert=upsert, multi=multi)

    #def update(self, check, new_values, upsert=False):
    #    if self.is_mongo:
    #        return self.collection.update_many(check, new_values, upsert=upsert)
    #    else:
    #        return self.collection.update(check, new_values, upsert=upsert)
    #def update(self, check, new_values):
    #    if self.is_mongo:
    #        return self.collection.update_many(check, new_values)
    #    else:
    #        return self.collection.update(check, new_values)

    def update_one(self, check, new_values):
        if self.is_mongo:
            return self.collection.update_one(check, new_values)
        else:
            return self.collection.update(check, new_values, multi=False)

    #def update_one(self, check, new_values):
    #    if self.is_mongo:
    #        return self.collection.update_one(check, new_values)
    #    else:
    #        return self.collection.update(check, new_values)
############## wrapptermongo ################

################ machine parameters #########################
#ARROWS_HOME     = '/Users/bylaska/Public/TinyArrows'
ARROWS_HOME           = __file__.split("TinyArrows")[0] + "TinyArrows"
MY_ENV                = os.environ.copy()
MY_ENV["ARROWS_HOME"] = ARROWS_HOME

ARROWS_API_HOME = 'http://localhost:5001/api/'

####################### mongoDB #############################
#uri = "mongodb://arrows:password@we17860.emsl.pnl.gov:27017"
with open(ARROWS_HOME + "/bin/.queue_nwchem",'r') as f: uri = f.readline().strip()
if "mongodb:" in uri:
   nosql_client = pymongo.MongoClient(uri)
   ismongo      = True
else:
   nosql_client = CustomClient(uri)
   ismongo      = False

# Define the TinyMongo collections
arrows_db          = nosql_client.Arrows
qnumber_collection = CustomCollection(arrows_db.queue_number,ismongo)
nwchem_collection  = CustomCollection(arrows_db.nwchem_queue,ismongo)
machine_collection = CustomCollection(arrows_db.nwchem_machinedata,ismongo)

#arrows_db          = nosql_client.Arrows
#qnumber_collection = arrows_db.queue_number
#nwchem_collection  = arrows_db.nwchem_queue
#machine_collection = arrows_db.nwchem_machinedata
#################### machine specifics ######################

nwpythonlib    = "/bin/nwpythonlib.py"

obabel         = "/usr/bin/env obabel "
obrotamer       = "/usr/bin/env obrotamer"

chemdb_balance_reaction  = ARROWS_HOME + "/bin/chemdb_balance_reaction9f --arrows_api=" + ARROWS_API_HOME + " "
chemdb_queue             = ARROWS_HOME + "/bin/chemdb_queue --arrows_api=" + ARROWS_API_HOME + " " 

solvatedsolute_esmiles   = ARROWS_HOME + "/bin/solvatedsolute_esmiles "

esmiles2xyz              = ARROWS_HOME + "/bin/esmiles2xyz "
esmilespmf2xyz           = ARROWS_HOME + "/bin/esmilespmf2xyz "
remote_nwchem            = ARROWS_HOME + "/bin/submit_nwchem3"

wrkdir     = ARROWS_HOME + "/Work"
submitdir0 = ARROWS_HOME + "/TNTQ" 
curdir     = os.getcwd()

geom_maxiter   = 50
remote_computer = None
ddrand = random.randint(0,999999)
tmpsmi1  = "tmpsmi1-%d.smi" % ddrand
tmpsmi2  = "tmpsmi2-%d.smi" % ddrand
tmpsdf1  = "tmpsdf1-%d.sdf" % ddrand
tmpsdf2  = "tmpsdf2-%d.sdf" % ddrand
tmpjunk  = "tmpjunk-%d.err" % ddrand
tmpjob   = "tntjob-%d"      % ddrand
################ machine parameters #########################

#global variables
bad_smiles2xyz_geom = False
use_cactus_geom     = False
def reset_bad_smiles2xyz_geom():
   global bad_smiles2xyz_geom
   bad_smiles2xyz_geom = True  
def reset_use_cactus_geom():
   global use_cactus_geom
   use_cactus_geom = True

LJparam = {
 'H':  [0.7,0.044],
 'N':  [3.26,0.069],
 'F': [3.26,0.08],
 'Cl': [3.52,0.16],
 'C':  [3.41, 0.100],
 'O':  [3.16555789,0.15539425],
 'Fe':  [2.15,0.124],
 'U':  [3.16555789,0.15539425],
 'Ca': [3.028,0.238],
 '.':  [3.5,0.1]
}

vdw = {
 'H': 1.20,
 'N': 1.55,
 'NA': 2.27,
 'Na': 2.27,
 'CU': 1.40,
 'Cu': 1.40,
 'CL': 1.75,
 'Cl': 1.75,
 'C': 1.70,
 'O': 1.52,
 'I': 1.98,
 'P': 1.80,
 'B': 1.85,
 'BR': 1.85,
 'Br': 1.85,
 'S': 1.80,
 'SE': 1.90,
 'Se': 1.90,
 'F': 1.47,
 'FE': 1.80,
 'Fe': 1.80,
 'K':  2.75,
 'MN': 1.73,
 'Mn': 1.73,
 'MG': 1.73,
 'Mg': 1.73,
 'ZN': 1.39,
 'Zz': 1.39,
 'HG': 1.8,
 'Hg': 1.8,
 'XE': 1.8,
 'Xe': 1.8,
 'AU': 1.8,
 'Au': 1.8,
 'LI': 1.8,
 'Li': 1.8,
 'Ow': 1.52,
 'U': 1.8,
 'Ca': 1.73,
 '.': 1.8
}

periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}


periodic_table_valence_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 1,
    'Be' : 2,
    'B'  : 3,
    'C'  : 4,
    'N'  : 5,
    'O'  : 6,
    'F'  : 7,
    'Ne' : 8,
    'Na' : 1,
    'Mg' : 2,
    'Al' : 3,
    'Si' : 4,
    'P'  : 5,
    'S'  : 6,
    'Cl' : 7,
    'Ar' : 8,
    'K'  : 1,
    'Ca' : 2,
    'Sc' : 3,
    'Ti' : 4,
    'V'  : 5,
    'Cr' : 6,
    'Mn' : 7,
    'Fe' : 8,
    'Co' : 9,
    'Ni' : 10,
    'Cu' : 11,
    'Zn' : 12,
    'Ga' : 3,
    'Ge' : 4,
    'As' : 5,
    'Se' : 6,
    'Br' : 7,
    'Kr' : 8,
    'Rb' : 1,
    'Sr' : 2,
    'Y'  : 3,
    'Zr' : 4,
    'Nb' : 5,
    'Mo' : 6,
    'Tc' : 7,
    'Ru' : 8,
    'Rh' : 9,
    'Pd' : 10,
    'Ag' : 11,
    'Cd' : 12,
    'In' : 3,
    'Sn' : 4,
    'Sb' : 5,
    'Te' : 6,
    'I'  : 7,
    'Xe' : 8,
    'Cs' : 1,
    'Ba' : 2,
    'La' : 3,
    'Ce' : 4,
    'Pr' : 5,
    'Nd' : 6,
    'Pm' : 7,
    'Sm' : 8,
    'Eu' : 9,
    'Gd' : 10,
    'Tb' : 11,
    'Dy' : 12,
    'Ho' : 13,
    'Er' : 14,
    'Tm' : 15,
    'Yb' : 16,
    'Lu' : 17,
    'Hf' : 4,
    'Ta' : 5,
    'W'  : 6,
    'Re' : 7,
    'Os' : 8,
    'Ir' : 9,
    'Pt' : 10,
    'Au' : 11,
    'Hg' : 12,
    'Tl' : 3,
    'Pb' : 4,
    'Bi' : 5,
    'Po' : 6,
    'At' : 7,
    'Rn' : 8,
    'Fr' : 1,
    'Ra' : 2,
    'Ac' : 3,
    'Th' : 4,
    'Pa' : 5,
    'U'  : 6,
    'Np' : 7,
    'Pu' : 8,
    'Am' : 9,
    'Cm' : 10,
    'Bk' : 11,
    'Cf' : 12,
    'Es' : 13,
    'Fm' : 14,
    'Md' : 15,
    'No' : 16,
    'Lr' : 17,
    'Rf' : 4,
    'Ha' : 5,
    'Sg' : 6,
    'Bh' : 7,
    'Hs' : 8,
    'Mt' : 9
}


def eval_dict(dict0,key):
   if key in dict0:
      aak = dict0[key]
   else:
      aak = dict0['.']
   return aak

def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)

def RepresentsInt(s):
   try: 
      int(s)
      return True
   except ValueError:
      return False




def taskjobtheory(jobtheory,mult):
   if (jobtheory=="ccsd(t)") and (mult==1):
      tt = 'ccsd(t)'
   elif (jobtheory=="ccsd(t)") and (mult>1):
      tt = 'tce'
   elif (jobtheory=="ccsd") and (mult==1):
      tt = 'ccsd'
   elif (jobtheory=="ccsd") and (mult>1):
      tt = 'tce'
   elif (jobtheory=="qsharp_chem"):
      tt = 'tce'
   elif (jobtheory=="mp2") and (mult==1):
      tt = "direct_mp2"
   elif (jobtheory=="hf") or (jobtheory=="uhf"):
      tt = "scf"
   else:
      tt = jobtheory
   return tt


#############################################
#                                           #
#             addspaces_esmiles              #
#                                           #
#############################################
def addspaces_esmiles(esmiles):
   tags = ['^','mult','theory','xc','solvation_type','basis','xyzdata','calculation_type']
   esmiles2 = esmiles[:]
   for tag1 in tags: 
      if tag1 in esmiles2: esmiles2 = esmiles2.replace(tag1," " + tag1)
   return esmiles2


#### geturlresult function ####
def geturlresult(url):
   try:
      the_page = ""
      with urllib.request.urlopen(url) as response:
         the_page = response.read().rstrip()
   except:
      the_page = "" 

   if isinstance(the_page,bytes): the_page = the_page.decode("utf-8")

   return the_page


#######################################
#                                     #
#          smiles2twirl               #
#                                     #
#######################################
def smiles2twirl(smiles):
   link = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/twirl"
   #result = "</pre>"
   #result = "<a href=\"" + link + "\">TwirlMol Link</a>"
   #result += "<pre style=\"font-size:0.6em;color:red\">"
   #result = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/twirl"
   result = "<a href=\"" + link + "\">TwirlMol Link</a>"
   return result

#######################################
#                                     #
#          smiles2image               #
#                                     #
#######################################
def smiles2image(smiles):
   link = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/image"
   #result = "</pre>"
   #result = "<a href=\"" + link + "\">GIF Image Link</a>"
   #result += "<pre style=\"font-size:0.6em;color:red\">"
   #result = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/image"
   result = "<a href=\"" + link + "\">GIF Image Link</a>"
   return result

#######################################
#                                     #
#          smiles2nmrdb               #
#                                     #
#######################################
def smiles2nmrdb(smiles):
   #result = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/image"
   link1   = "http://www.nmrdb.org/service.php?name=nmr-1h-prediction&smiles="+ smiles
   link2   = "http://www.nmrdb.org/service.php?name=nmr-13c-prediction&smiles="+ smiles
   link3   = "http://www.nmrdb.org/service.php?name=cosy-prediction&smiles="+smiles
   link4   = "http://www.nmrdb.org/service.php?name=hmbc-prediction&smiles="+smiles
   result  = "#  - nmrdb webpage    =  <a href=\"" + link1 + "\">1H NMR prediction</a>\n"
   result += "#  - nmrdb webpage    =  <a href=\"" + link2 + "\">13C NMR prediction</a>\n"
   result += "#  - nmrdb webpage    =  <a href=\"" + link3 + "\">COSY prediction</a>\n"
   result += "#  - nmrdb webpage    =  <a href=\"" + link4 + "\">HSQC/HMBC prediction</a>"
   return result


#######################################
#                                     #
#          smiles2ascii               #
#                                     #
#######################################

#  This function converts a smiles string and converts
# it to a chemical drawing in ascii art.

def smiles2ascii(smiles):
   try:
      cmd6 = esmiles2xyz + ' "'+ smiles.strip() + '" ' + wrkdir + "/" + tmpsmi1
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      ascii  = result.split("chemical_structure_asciiart:")[1].split(":chemical_structure_asciiart")[0]
   except:
      ascii = ""

   ascii2 = ""
   for a in ascii.split('\n'):
      if 'WARNING' not in a:
         ascii2 += a + '\n'

   return ascii2


#######################################
#                                     #
#          nametosmiles                #
#                                     #
#######################################

#  This function converts a smiles string and converts
# it to a chemical drawing in ascii art.

def nametosmiles(name):
   try:
      cmd6 = esmiles2xyz + ' "'+ name.strip() + '" ' + wrkdir + "/" + tmpsmi1
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      smiles = result.split("smiles   =")[1].split("\n")[0].strip()

   except:
      smiles = name

   return smiles



###### xyz_badgeom ####
#### geometry is badd if nan's are produced or a bond distance < 0.5 ####
def xyz_badgeom(xyzfile):
   with open(xyzfile,'r') as ff:
      test = ff.read()
   badgeom = False
   if "nan" in test:
      badgeom = True
   else:
      ### check bond distances ###
      geomlst = test.strip().split("\n")
      rxyz = []
      for ln in geomlst[2:]:
         ss = ln.strip().split()
         rxyz.append(evalnum(ss[1]))
         rxyz.append(evalnum(ss[2]))
         rxyz.append(evalnum(ss[3]))
      nion = len(rxyz)//3
      for i in range(nion-1):
         for j in range(i+1,nion):
            x = rxyz[3*i]   - rxyz[3*j]
            y = rxyz[3*i+1] - rxyz[3*j+1]
            z = rxyz[3*i+2] - rxyz[3*j+2]
            r = sqrt(x*x + y*y + z*z)
            if (r<0.7): badgeom = True

   return badgeom


#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    ### cactus cannot handle # and $ symbols ###
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result

#### cml2xyz function ####
def cml2xyz(cmlfile,xyzfile):
   cmd6 = obabel + " --ffuff --gen3d -icml " + cmlfile + " -oxyz -O" + xyzfile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")

#### xyz2cml function ####
def xyz2cml(xyzfile,cmlfile):
   cmd6 = obabel + " -ixyz " + xyzfile + " -ocml -O" + cmlfile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")

#### smiles2cml function ####
def smiles2cml(smiles,cmlfile):
   eoln = "\n"
   smilefile = wrkdir + "/" + tmpsmi1
   ofile = open(smilefile,'w')
   ofile.write(smiles); ofile.write(eoln)
   ofile.close()
   cmd6 = obabel + " --ffuff --gen3d -ismi " + smilefile + " -ocml -O" + cmlfile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")

#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "'+ smiles.strip() + '" ' + xyzfile
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")

   #### if nan's are produced or a bond distance < 0.5 then use cactus smiles2xyz rest interface ####
   badgeom = xyz_badgeom(xyzfile)
   if (badgeom or use_cactus_geom):
      reset_bad_smiles2xyz_geom()
      xyzdata = cactus_smiles2xyz(smiles)
      xyzdata = xyzdata.strip()
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+"\n")



#### smilespmf2xyz function ####
def smilespmf2xyz(esmiles,xyzfile):
   #eoln = "\n"
   cmd = esmilespmf2xyz + ' "'+ esmiles.strip() + '" ' + xyzfile
   result1 = subprocess.check_output(cmd,shell=True).decode("utf-8")
   print(result1)
   solutejob = result1.split("solutejob:")[1].split(":solutejob")[0]

   return eval(solutejob)


#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result  = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

def pubchem_smiles2cid_link(smiles):
    result  = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    if (result.strip()!='0'):
       link    = "https://pubchem.ncbi.nlm.nih.gov/compound/"+result
       result1 = "<a href=\"" + link + "\">" + result + "</a>"
    else:
       result1 = result
    return result1

#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles).replace(';','\n').split('\n')
    return result

#### pubchem_smiles2synonym0 function ####
def pubchem_smiles2synonym0(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles).replace(';','\n').split('\n')
    return result[0]

#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result

#### pubchem_smiles2InChI function ####
def pubchem_smiles2InChI(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/InChI/TXT" % smiles)
    return result

#### pubchem_cid2smiles function ####
def pubchem_cid2smiles(cid):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%s/property/CanonicalSMILES/TXT" % cid)
    return result

#### pubchem_cid2InChI function ####
def pubchem_cid2InChI(cid):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%s/property/InChI/TXT" % cid)
    return result


def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/" + tmpsmi1
      smilefile2 = wrkdir + "/" + tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      cmd6 = obabel + " -ismi " + smilefile + " -ocan -O" + smilefile2 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2



#### cml2smiles function ####
def cml2smiles(cmlfile):
   smiles = "nosmiles"
   smilefile = wrkdir + "/" + tmpsmi1
   cmd6 = obabel + " -icml " + cmlfile + " -ocan -O" + smilefile 
   #os.system(cmd6)
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   sdat = []
   ofile = open(smilefile,'r')
   for line in ofile:
      sdat.append(line)
   ofile.close()
   smiles = sdat[0].split()[0]
   return smiles

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   smiles = "nosmiles"
   smilefile = wrkdir + "/" + tmpsmi1
   cmd6 = obabel + " -ixyz " + xyzfile + " -ocan -O" + smilefile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   sdat = []
   ofile = open(smilefile,'r')
   for line in ofile:
      sdat.append(line)
   ofile.close()
   smiles = sdat[0].split()[0]
   return smiles

#### xyzrotamer function ####
def xyzrotamer(xyzfile):
   with open(xyzfile,'r') as ff: 
      xyzbak = ff.read()
   sdffile  = wrkdir + "/" + tmpsdf1
   sdffile2 = wrkdir + "/" + tmpsdf2
   cmd6 = obabel + " -ixyz " + xyzfile + " -osdf -O" + sdffile 
   cmd7 = "(" + obrotamer + " " + sdffile + " > " + sdffile2 + ") > "+ wrkdir + "/" + tmpjunk
   cmd8 = obabel + " -isdf " + sdffile2 + " -oxyz -O" + xyzfile 
   os.system(cmd6)
   os.system(cmd7)
   os.system(cmd8)
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   result = subprocess.check_output(cmd7,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   result = subprocess.check_output(cmd8,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   sdat = []
   ofile = open(wrkdir + "/"+tmpjunk,'r')
   for line in ofile:
      sdat.append(line)
   ofile.close()
   rots = sdat[0]

   ### check for bad geometry -revert to orginal file if geometry is bas ###
   badgeom = xyz_badgeom(xyzfile)
   if badgeom:
      with open(xyzfile,'w') as ff:
         ff.write(xyzbak)
         rots = 'Using the non-rotated geometry because the rotation caused a bad geometry.'

   return rots



#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ""
   inchifile = wrkdir + "/" + tmpsmi1
   cmd6 = obabel + " -ixyz " + xyzfile + " -oinchi -O" + inchifile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   sdat = []
   ofile = open(inchifile,'r')
   for line in ofile:
      sdat.append(line)
   ofile.close()
   inchi = sdat[0].split()[0]
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ""
   inchifile = wrkdir + "/" + tmpsmi1
   cmd6 = obabel + " -ixyz " + xyzfile + " -oinchikey -O" + inchifile 
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   sdat = []
   ofile = open(inchifile,'r')
   for line in ofile:
      sdat.append(line)
   ofile.close()
   inchi = sdat[0].split()[0]
   return inchi




#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = obabel + " -ismi " + smilefile + " -oinchi -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = obabel + " -ismi " + smilefile + " -oinchikey -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi




def smiles2charge(smiles):
  charge = 0
  ss = smiles.split('[')
  if (len(ss)>1):
     ss = ss[1:]
  else:
     ss = []
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+10")!=-1): charge += 10
     elif (inside.find("-10")!=-1): charge -= 10
     elif (inside.find("+9")!=-1): charge += 9
     elif (inside.find("-9")!=-1): charge -= 9
     elif (inside.find("+8")!=-1): charge += 8
     elif (inside.find("-8")!=-1): charge -= 8
     elif (inside.find("+7")!=-1): charge += 7
     elif (inside.find("-7")!=-1): charge -= 7
     elif (inside.find("+6")!=-1): charge += 6
     elif (inside.find("-6")!=-1): charge -= 6
     elif (inside.find("+5")!=-1): charge += 5
     elif (inside.find("-5")!=-1): charge -= 5
     elif (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge

def esmiles2mult_set(smiles,charge,esmiles):
   mult = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:
      isodd = ((mult%2)==1)
      mult0 = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      isodd0 = ((mult0%2)==1)
      if (isodd==isodd0):
         mult = mult0
      elif (mult0<2) and isodd:
         mult = 1
      elif (mult0<3) and (not isodd):
         mult = 2
      else:
         mult = mult0-1
   return mult

def smiles2mult(smiles,q):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpjunk)
  pcharge = q
  count = 0
  xyzfile = open(wrkdir + "/"+tmpjunk,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult


def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult


def xyz2ncharge(xyzfilename,q):
  ncharge = -q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           ncharge += periodic_table_charge[Symb]
  xyzfile.close()
  return ncharge



def smiles2valencecharge(smiles):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpjunk)
  vcharge = 0
  count = 0
  largeatom = False
  xyzfile = open(wrkdir + "/"+tmpjunk,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_valence_charge:
           vcharge += periodic_table_valence_charge[Symb]
        if Symb in periodic_table_charge:
           if (periodic_table_charge[Symb]>35): largeatom = True
  xyzfile.close()

  #if ((largeatom) and (vcharge<51)): vcharge = 55

  return vcharge


def removespace_basis(basis):
   if ('ry' not in basis.lower()) and ('hartree' not in basis.lower()):
      basis = basis.replace(" ", "")
   return basis


def theorysmiles2machine(theory,smiles):
   machine = 'Shirky'
   vachinetype = "toobig"
   hasmopac    = False
   vcharge = smiles2valencecharge(smiles)
   if ('am1' in theory) or ('pm3' in theory) or ('mndo' in theory) or ('mindo3' in theory):
      hasmopac = True
      if vcharge<2000:
         vachinetype = 'tiny'
   elif ('qsharp_chem' in theory):
      if vcharge<50:
         vachinetype = 'qsharp'
   elif ('ccsd' in theory):
      if vcharge<50:
         vachinetype = 'large'
   elif ('ccsd(t)' in theory):
      if vcharge<50:
         vachinetype = 'large'
   elif ('mp2' in theory):
      if vcharge<80:
         vachinetype = 'large'
   elif ('pspw4' in theory) or ('pspw' in theory) or ('aimd' in theory) or ('aimd4' in theory):
      if vcharge<50:
         vachinetype = 'small'
      elif vcharge<150:
         vachinetype = 'medium'
      elif vcharge<500:
         vachinetype = 'large'
   else:
      if vcharge<30:
         vachinetype = 'tiny'
      elif vcharge<50:
         vachinetype = 'small'
      elif vcharge<150:
         vachinetype = 'medium'
      elif vcharge<500:
         vachinetype = 'large'


   if (vachinetype=='tiny' or vachinetype=='small' or vachinetype=='medium' or vachinetype=='large'):
      machinedata = machine_collection.find()
      machinejobs  = {}
      for mach in machinedata:
         mname = mach['machinename']
         if 'machinetype' in mach:
            mts = mach['machinetype']
         else:
            mts = ''
         if 'mopacbinary' in mach:
            mps = True
         else:
            mps = False
         if hasmopac:
             if mps: machinejobs[mname]  = 0
         else:
            if vachinetype=='tiny'  and (mts=='tiny' or mts=='small' or mts=='medium'):
               machinejobs[mname]  = 0
            if vachinetype=='small'  and (mts=='small' or mts=='medium'):
               machinejobs[mname]  = 0
            elif vachinetype=='medium' and (mts=='medium' or mts=='large'):
               machinejobs[mname]  = 0
            elif vachinetype=='large'  and (mts=='large'):
               machinejobs[mname]  = 0

      spokane_q = nwchem_collection.find()
      for job in spokane_q:
         mname = job['machinename']
         if mname in machinejobs: machinejobs[mname] += 1

      smallest = 999999999
      for key,val in machinejobs.items():
         if val < smallest:
            smallest = val
            machine  = key

   #### compare to shirky queues ####
   if ((vachinetype=='tiny') and (hasmopac)):
      cmd9 = chemdb_queue 
      result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
      shirkycount = len([w for w in result9.split() if w=='mopac'])
      if (shirkycount<=smallest):
         machine = 'Shirky'

   if ((vachinetype=='tiny') and (not hasmopac)):
      cmd9 = chemdb_queue 
      result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
      shirkycount = len([w for w in result9.split() if w=='tiny'])
      if (shirkycount<=smallest):
         machine = 'Shirky'

   if ((vachinetype=='small') and (not hasmopac)):
      cmd9 = chemdb_queue 
      result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
      shirkycount = len([w for w in result9.split() if w=='small'])
      if (shirkycount<=smallest):
         machine = 'Shirky'

   if ((vachinetype=='medium') and (not hasmopac)):
      cmd9 = chemdb_queue
      result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
      shirkycount = len([w for w in result9.split() if w=='medium'])
      if (shirkycount<=smallest):
         machine = 'Shirky'

   if ((vachinetype=='large') and (not hasmopac)):
      cmd9 = chemdb_queue
      result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
      shirkycount = len([w for w in result9.split() if w=='large'])
      if (shirkycount<=smallest):
         machine = 'Shirky'

    
   print("#VALENCE CHARGE=",vcharge, " MACHINE=",machine)

   return machine





def datafile_prune(data):
   aaa = data.split('@')
   count = len(aaa)
   if (count>10):
      start = aaa[5].split('\n')[0]
      end = aaa[count-3].split('\n')[0]
      mid = data.split(start)[1].split(end)[0]
      data = data.replace(mid,'')
   return data



def datafile_xyzfile(datafile,tmpxyzfile):
   try:
      count = -1
      xyzdat = []
      ofound = False
      gfound = False
      done = False
      for line in datafile.split("\n"):
        if (not done):
           if (count>0):
              if (len(line)<=5):
                 done = True
              else:
                 xyzdat.append(line)
           if (not done):
              if (count>=0):
                 count += 1
              if (line.find("Optimization converged") != -1):
                 ofound = True
              if (line.find("Failed to converge in maximum number of steps") != -1):
                 ofound = True
              if (ofound and (line.find("No.") != -1)):
                 gfound = True
                 count = 0

      #print("Generating xyzfile = ",xyzfile)
      n = len(xyzdat)
      xfile = open(tmpxyzfile,'w')
      xfile.write("%d\n\n" % n)
      for i in range(n):
         split = xyzdat[i].split()
         xfile.write("%s   %f %f %f\n" % (split[1],evalnum(split[3]),evalnum(split[4]),evalnum(split[5])))
      xfile.close()

   except:
      print("Cannot generate xyzfile ")




##############################################
#                                            #
#           molecule_unitcell                #
#                                            #
##############################################

def molecule_unitcell(xyzfile):
   with open(xyzfile,'r') as ff:
      xyzdat = ff.read()

   nion = eval(xyzdat.split("\n")[0].strip())

   rion = []
   xcm = 0.0
   ycm = 0.0
   zcm = 0.0
   for ln in xyzdat.strip().split('\n')[2:]:
      ss = ln.split()
      x = eval(ss[1])/0.529177
      y = eval(ss[2])/0.529177
      z = eval(ss[3])/0.529177
      rion.append(x)
      rion.append(y)
      rion.append(z)
      xcm += x
      ycm += y
      zcm += z

   xcm /= nion
   ycm /= nion
   zcm /= nion
   for ii in range(nion):
      rion[3*ii]   -= xcm
      rion[3*ii+1] -= ycm
      rion[3*ii+2] -= zcm

   mtensor = [0.0]*9

   TMass = nion
   ## determine Ixx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i+1]**2 + rion[3*i+2]**2)
   for i in range(nion): ty += (rion[3*i+1])
   for i in range(nion): tz += (rion[3*i+2]);
   Ixx = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Iyy ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i]**2 + rion[3*i+2]**2)
   for i in range(nion): ty += (rion[3*i])
   for i in range(nion): tz += (rion[3*i+2])
   Iyy = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Izz ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i]**2 + rion[3*i+1]**2)
   for i in range(nion): ty += (rion[3*i])
   for i in range(nion): tz += (rion[3*i+1])
   Izz = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Ixy  and Iyx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i]*rion[3*i+1])
   for i in range(nion): ty += (rion[3*i])
   for i in range(nion): tz += (rion[3*i+1])
   Ixy = tx - ty*tz/TMass
   Iyx = Ixy
   ## determine Ixz  and Izx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i]*rion[3*i+2])
   for i in range(nion): ty += (rion[3*i])
   for i in range(nion): tz += (rion[3*i+2])
   Ixz = tx - ty*tz/TMass
   Izx = Ixz
   ## determine Iyz  and Izy ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += (rion[3*i+1]*rion[3*i+2]);
   for i in range(nion): ty += (rion[3*i+1]);
   for i in range(nion): tz += (rion[3*i+2]);
   Iyz = tx - ty*tz/TMass
   Izy = Iyz

   M = [[Ixx, -Iyx, -Izx], [-Ixy, Iyy, -Izy], [-Ixz, -Iyz, Izz]]
   MM = array(M)
   (e,V) = eig(MM)

   delta = 7.0
   L1 = 0.0
   L2 = 0.0
   L3 = 0.0
   for ii in range(nion):
      x = rion[3*ii]
      y = rion[3*ii+1]
      z = rion[3*ii+2]
      f1 = V[0,0]*x + V[1,0]*y + V[2,0]*z
      f2 = V[0,1]*x + V[1,1]*y + V[2,1]*z
      f3 = V[0,2]*x + V[1,2]*y + V[2,2]*z
      if ((f1+delta)>(0.5*L1)): L1 = 2*(f1+delta)
      if ((f2+delta)>(0.5*L2)): L2 = 2*(f2+delta)
      if ((f3+delta)>(0.5*L3)): L3 = 2*(f3+delta)
      if ((f1-delta)<(-0.5*L1)): L1 = 2*(abs(f1)+delta)
      if ((f2-delta)<(-0.5*L2)): L2 = 2*(abs(f2)+delta)
      if ((f3-delta)<(-0.5*L3)): L3 = 2*(abs(f3)+delta)

   Lmax = L1
   if (L2>Lmax): Lmax = L2
   if (L3>Lmax): Lmax = L3

   if (Lmax<26.0):
      cell = "    fcc 38.0"
   else:
      unita = [0.0]*9
      unita[0] = L1*V[0,0]
      unita[1] = L1*V[1,0]
      unita[2] = L1*V[2,0]
      unita[3] = L2*V[0,1]
      unita[4] = L2*V[1,1]
      unita[5] = L2*V[2,1]
      unita[6] = L3*V[0,2]
      unita[7] = L3*V[1,2]
      unita[8] = L3*V[2,2]
      cell  = "    lattice_vectors\n"
      cell += "      %f %f %f\n" % (unita[0],unita[1],unita[2])
      cell += "      %f %f %f\n" % (unita[3],unita[4],unita[5])
      cell += "      %f %f %f" % (unita[6],unita[7],unita[8])

   #cell  =  " a1=< %f %f %f> \n" % (unita[0],unita[1],unita[2])
   #cell  += " a2=< %f %f %f> \n" % (unita[3],unita[4],unita[5])
   #cell  += " a3=< %f %f %f> \n" % (unita[6],unita[7],unita[8])

   return cell







#### functions ####
def makeheader(jobname,jobtheory,jobxc,jobtype,mformula,charge,mult,vtag,machine,permdir,mem):
   #
   eoln = "\n"
   titlestr = "title \"" + "swnc: " + jobtype 
   titlestr += " theory=%s" % jobtheory
   if (jobtheory=='pspw' or jobtheory=='dft'):
      titlestr += " xc=%s" % jobxc
   titlestr += " formula=%s" % mformula
   titlestr += " charge=%d"  % charge
   titlestr += " mult=%d"    % mult
   titlestr += "\""
   #titlestr += " jobname=%s" % jobname
   titlestr += "\n#machinejob:%s  "    % machine
   titlestr += "\n#vtag= %s  "    % vtag

   echostr = "echo"
   startstr = "start " + jobname
   #dirsstr  = "permanent_dir " + permdir + eoln + "scratch_dir  " + permdir 
   #dirsstr  = "permanent_dir " + permdir + eoln
   memstr   = "memory " + mem

   tstr = ''
   tstr += titlestr+eoln+eoln
   tstr += echostr+eoln+eoln
   tstr += startstr+eoln+eoln
   tstr += memstr+eoln+eoln
   #tstr += dirsstr);  tstr += eoln); tstr += eoln); 
   tstr += "charge %d" % charge
   tstr += eoln

   return tstr


def makecosmoradii(xyzfilename):
   symbol = []; x = []; y = []; z = []
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().split()
      symbol.append(line[0]) 
      x.append(evalnum(line[1]))
      y.append(evalnum(line[2]))
      z.append(evalnum(line[3]))
   xyzfile.close()
   radii = []
   for i in range(n): radii.append(0.0)
   for i in range(n): 
      if (symbol[i]=='H'):    radii[i] = 1.172
      elif (symbol[i]=='N'):  radii[i] = 2.126
      elif (symbol[i]=='O'):  radii[i] = 1.576
      elif (symbol[i]=='F'):  radii[i] = 1.28
      elif (symbol[i]=='P'):  radii[i] = 2.279
      elif (symbol[i]=='S'):  radii[i] = 2.023
      elif (symbol[i]=='Cl'): radii[i] = 1.75
      elif (symbol[i]=='Al'): radii[i] = 1.404
      elif (symbol[i]=='Si'): radii[i] = 2.457
      elif (symbol[i]=='Br'): radii[i] = 2.16
      elif (symbol[i]=='I'):  radii[i] = 2.32
      elif (symbol[i]=='C'): 
        dsigma = True
        for j in range(n):
           if ((symbol[j]=='C') and (j!=i)): 
             xx= x[i]-x[j]; yy= y[i]-y[j]; zz= z[i]-z[j]
             r = sqrt(xx*xx + yy*yy + zz*zz)
             if (r <= 1.46):
               dsigma = False
        if (dsigma):
           radii[i] = 2.096
        else:
           radii[i] = 1.635
      else:
        radii[i] = 2.223
   return radii



def makemasses(xyzfilename):
   symbol = []
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().split()
      symbol.append(line[0])
   xyzfile.close()
   masses = []
   for i in range(n): masses.append(0.0)
   for i in range(n): 
      if (symbol[i]=='H'):  masses[i] = 1.007825
      if (symbol[i]=='C'):  masses[i] = 12.01100
      if (symbol[i]=='N'):  masses[i] = 14.00307
      if (symbol[i]=='O'):  masses[i] = 15.9994
      if (symbol[i]=='F'):  masses[i] = 18.9984
      if (symbol[i]=='P'):  masses[i] = 30.97376
      if (symbol[i]=='S'):  masses[i] = 31.97207
      if (symbol[i]=='Cl'): masses[i] = 35.4530
   return masses


def makerion(xyzfilename):
   rion = []
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().split()
      rion.append(evalnum(line[1]))
      rion.append(evalnum(line[2]))
      rion.append(evalnum(line[3]))
   xyzfile.close()
   return rion


def makesymbols(xyzfilename):
   symbol = [];
   xyzfile = open(xyzfilename,'r')     
   n = evalnum(xyzfile.readline())
   xyzfile.readline()  
   for i in range(n):  
      line = xyzfile.readline().split() 
      symbol.append(line[0])
   xyzfile.close()
   return symbol



def makegeom(xyzfilename,diagonal_hessian):
   #
   ### generate geometry input ###
   eoln = "\n"
   tstr = ''
   tstr += eoln+eoln+eoln
   if (diagonal_hessian) or (bad_smiles2xyz_geom) or (job['reaction_hash']!=''):
      tstr += "geometry units angstroms print xyz noautosym noautoz"+eoln
   else:
      tstr += "geometry units angstroms print xyz noautosym"+eoln
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      tstr += xyzfile.readline().strip()+eoln
   xyzfile.close()
   tstr += "end"+eoln

   return tstr

def makegeom_neb(xyzfilename,xyzfilename2):
   #
   ### generate neb_start geometry input ###
   eoln = "\n"
   tstr = ''
   tstr += eoln+eoln+eoln
   tstr += "geometry neb_start units angstroms print xyz noautosym"+eoln
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      tstr += xyzfile.readline().strip()+eoln
   xyzfile.close()
   tstr += "end"+eoln

   ### generate neb_end geometry input ###
   tstr += eoln+eoln+eoln
   tstr += "geometry neb_end units angstroms print xyz noautosym"+eoln
   xyzfile = open(xyzfilename2,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      tstr += xyzfile.readline().strip() + eoln
   xyzfile.close()
   tstr += "end"+eoln

   return tstr


def makegaussianbasis(mformula,basis,basisHZ):
   foundHZ = False
   str = "basis \"ao basis\" cartesian print\n"
   for aa in re.findall('[^\d ]+', mformula):
      if (periodic_table_charge[aa]<21):
         if (basis=='default'):
            str += " " + aa + " library \"6-311++G(2d,2p)\"" + "\n"
         else:
            str += " " + aa + " library " + basis + "\n"
      else:
         if (basisHZ=='default'):
            if (periodic_table_charge[aa]<37):
               str += " " + aa + " library aug-cc-pVTZ" + "\n"
               #str += " " + aa + " library Def2-TZVPD" + "\n"
            elif (periodic_table_charge[aa]<87):
               str += " " + aa + " library Def2-TZVP" + "\n"
               foundHZ = True
            elif (periodic_table_charge[aa]<104):
               str += " " + aa + " library stuttgart_rsc_1997" + "\n"
               foundHZ = True
            else:
               str += " " + aa + " library crenbl_ecp" + "\n"
               foundHZ = True
         else:
            str += " " + aa + " library " + basisHZ + "\n"
            if (periodic_table_charge[aa]>=37):
               foundHZ = True
   str += "end\n"
   if foundHZ: 
      str += "ecp\n"
      for aa in re.findall('[^\d ]+', mformula):
         if (periodic_table_charge[aa]>=37):
            if (basisHZ=='default'):
               if (periodic_table_charge[aa]<87):
                  str += " " + aa + " library Def2-TZVP" + "\n"
               elif (periodic_table_charge[aa]<104):
                  str += " " + aa + " library stuttgart_rsc_1997" + "\n"
               else:
                  str += " " + aa + " library crenbl_ecp" + "\n"
            else:
               str += " " + aa + " library " + basisHZ + "\n"
      str += "end\n"

   return str

def maketheory(jobtheory,xc,mult,pspw4,paw,basis,basisHZ,job):
   #
   eoln = "\n"
   tstr = ''
   tstr += eoln+eoln
   if (jobtheory=='pspw'):
      tstr += "nwpw"; tstr += eoln
      if (paw):
         tstr += "pseudopotentials"; tstr += eoln
         tstr += " *  library paw_default"; tstr += eoln
         tstr += "end"; tstr += eoln
      if (basis=='default'):
         tstr += "  cutoff 50.0";     tstr += eoln
      else:
         tstr += "  cutoff %s" % (basis);     tstr += eoln
      tstr += "  mult %d" % mult;  tstr += eoln
      if (xc=='lda'):   tstr += "  xc vosko"
      if (xc=='pbe'):   tstr += "  xc pbe96"
      if (xc=='blyp'):  tstr += "  xc blyp"
      if (xc=='b3lyp'): tstr += "  xc b3lyp"
      if (xc=='pbe0'):  tstr += "  xc pbe0"
      if (xc=='m06-2x'):tstr += "  xc m06-2x"
      tstr += eoln
      #tstr += "  lcao_skip"); tstr += eoln
      tstr += "  lmbfgs";    tstr += eoln
      if (job['diagonal_hessian']) and (job['reaction_hash']!=''):
         tstr += "  translation on";    tstr += eoln
      tstr += "end";  tstr += eoln

      if 'solutejob' in job:
         solutejob = job['solutejob']
         tstr += "nwpw\n"
         tstr += "   simulation_cell\n"
         tstr += "      SC %.6f\n" % (solutejob['L']/0.529177)
         tstr += "   end\n"
         tstr += "   qmmm\n"
         tstr += "      mm_tags %d:%d\n" % (solutejob['solute_size']+1,solutejob['solute_size']+solutejob['solvent_size'])
         for ka in job['kindatoms']:
            tstr += "      lj_ion_parameters %s %.6f %.6f\n" % (ka,eval_dict(LJparam,ka)[0],eval_dict(LJparam,ka)[1])
         tstr += "      lj_ion_parameters %s %.6f %.6f\n\n" % ('O^',3.16555789,0.15539425)
         tstr += "      fragment spc\n"
         tstr += "         size 3\n"
         tstr += "         index_start %d:%d:3\n\n" % (solutejob['solute_size']+1,solutejob['solute_size']+solutejob['solvent_size']-2)
         tstr += "         #spc/e water\n"
         tstr += "         shake units angstroms 1 2 3 cyclic 1.0 1.632993125 1.0\n\n"
         tstr += "         #Toukan-Rahman Potential\n"
         tstr += "         #bond_morse  1 2    0.1623940 1.3578682  1.889726878\n"
         tstr += "         #bond_morse  1 3    0.1623940 1.3578682  1.889726878\n"
         tstr += "         #bond_spring 2 3    0.0733187 3.0864590\n"
         tstr += "         #cross_bond_spring 1 2 1.889726878 2 3 3.0864590 -0.0943540\n"
         tstr += "         #cross_bond_spring 1 3 1.889726878 2 3 3.0864590 -0.0943540\n"
         tstr += "         #cross_bond_spring 1 2 1.889726878 1 3 1.889726878 0.0498426\n"
         tstr += "      end\n"
         tstr += "   end\n"
         tstr += "end\n\n"

         #### add constraints ####
         if (solutejob['constraint_type']=='bonddiff'):
            tup = (solutejob['constraint_index1'],solutejob['constraint_index3'],solutejob['constraint_index2'],solutejob['constraint_value'])
            tstr += "set nwpw:shake_constraint \"%d %d %d d %f\" " % tup
         elif (solutejob['constraint_type']=='bond'):
            tup = (solutejob['constraint_index1'],solutejob['constraint_index2'],solutejob['constraint_value']/0.529177)
            tstr += "set nwpw:shake_constraint \"%d %d L %f\" " % tup

      else:
         tstr += "nwpw"; tstr += eoln
         tstr += "  simulation_cell"; tstr += eoln
         if (job['pspw4']):
            tstr += "    boundary_conditions aperiodic";      tstr += eoln
         if (job['unitcell']==''):
            #tstr += ""
            try:
               tstr += molecule_unitcell(job['xyzfile']); tstr += eoln
            except:
               tstr += "    fcc 38.0";      tstr += eoln
         else:
            tstr += "   "
            tstr += job['unitcell'];     tstr += eoln
         tstr += "  end";             tstr += eoln
         tstr += "end";             tstr += eoln


   if (jobtheory=='am1' or jobtheory=='pm3' or jobtheory=='mndo' or jobtheory=='mindo3'):
      tstr += "mopacker"; tstr += eoln
      tstr += "  mult %d" % mult;  tstr += eoln
      tstr += "end";  tstr += eoln

   if ((jobtheory=='hf') or (jobtheory=='uhf')):
      tstr += makegaussianbasis(job['mformula'],basis,basisHZ); tstr += eoln
      if (mult==1):
         tstr += "scf"; tstr += eoln
         if (jobtheory=='uhf'): tstr += "uhf"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==2):
         tstr += "scf"; tstr += eoln
         if (jobtheory=='uhf'): tstr += "uhf"; tstr += eoln
         tstr += "doublet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==3):
         tstr += "scf"; tstr += eoln
         if (jobtheory=='uhf'): tstr += "uhf"; tstr += eoln
         tstr += "triplet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==4):
         tstr += "scf"; tstr += eoln
         if (jobtheory=='uhf'): tstr += "uhf"; tstr += eoln
         tstr += "quartet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==5):
         tstr += "scf"; tstr += eoln
         if (jobtheory=='uhf'): tstr += "uhf"; tstr += eoln
         tstr += "quintet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
         tstr += "end"; tstr += eoln


   if (jobtheory=='dft') or (jobtheory=='tddft'):
      tstr += makegaussianbasis(job['mformula'],basis,basisHZ); tstr += eoln

      tstr += "dft"; tstr += eoln
      if job['include_mocoefficients']: tstr += "print \"final vectors\""; tstr += eoln
      tstr += "direct"; tstr += eoln
      tstr += "noio"; tstr += eoln
      tstr += "grid nodisk"; tstr += eoln
      tstr += "  mult %d" % mult;  tstr += eoln

      #if (xc=='lda'):  tstr += "  xc svwn5"
      if ('pbe0'   in xc):
         tstr += "  xc pbe0"
      elif ('pbe'    in xc):
         tstr += "  xc xpbe96 cpbe96"

      if ('blyp'  in xc):  tstr += "  xc becke88 lyp"
      if ('b3lyp'  in xc): tstr += "  xc b3lyp"
      if ('m06-2x' in xc): tstr += "  xc m06-2x"
      tstr += eoln
      if ('coarse' in xc): tstr += "  grid coarse"
      if ('fine'   in xc): tstr += "  grid fine"
      if ('xfine'  in xc): tstr += "  grid xfine"
      tstr += eoln
  
      if (job['smear']>1.0e-6): 
          tstr += "  smear %f" % job['smear'];  tstr += eoln

      elif ('cgmin' in job['optimizer']): 
        tstr += "  cgmin";  tstr += eoln

      tstr += "  iterations 5001";  tstr += eoln
      tstr += "end"; tstr += eoln

   if (jobtheory=='tddft'):
      tstr += eoln
      tstr += "tddft" + eoln
      if (job['enroots']=='' or (not RepresentsInt(job['enroots']))):
         tstr += "   nroots 5"
      else:
         tstr += "   nroots %s" % job['enroots'] 
      tstr += eoln
      if job['esurface']!='':
         if ('triplet' in job['esurface']):
            tstr += "   nosinglet" + eoln
         else:
            tstr += "   notriplet" + eoln
         #tstr += "   algorithm 1" + eoln
         myroot = job['esurface'].lower().strip('triplet').strip('singlet').strip()
         if (not RepresentsInt(myroot)): myroot = '1'
         tstr += "   target %s" % myroot
         tstr += eoln
         tstr += "   civecs" + eoln
         tstr += "   grad" + eoln
         tstr += "      root %s" % myroot
         tstr += eoln
         tstr += "   end" + eoln
      tstr += "end" + eoln

   if (jobtheory=='mp2'):
      tstr += makegaussianbasis(job['mformula'],basis,basisHZ); tstr += eoln
      if (mult==1):
         tstr += "scf"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==2):
         tstr += "scf"; tstr += eoln
         tstr += "uhf"; tstr += eoln
         tstr += "doublet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==3):
         tstr += "scf"; tstr += eoln
         tstr += "uhf"; tstr += eoln
         tstr += "triplet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==4):
         tstr += "scf"; tstr += eoln
         tstr += "uhf"; tstr += eoln
         tstr += "quartet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==5):
         tstr += "scf"; tstr += eoln
         tstr += "uhf"; tstr += eoln
         tstr += "quintet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         tstr += "end"; tstr += eoln
      tstr += "mp2"; tstr += eoln
      tstr += "freeze atomic"; tstr += eoln
      tstr += "end"; tstr += eoln
      tstr += "set cphf:maxiter 1500"; tstr += eoln
   if (jobtheory=='ccsd(t)') or  (jobtheory=='qsharp_chem') or (jobtheory=='ccsd'):
      tstr += makegaussianbasis(job['mformula'],basis,basisHZ); tstr += eoln
      if (mult==1):
         tstr += "scf"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if (jobtheory=="qsharp_chem"):
            tstr += "thresh 1.0e-10"; tstr += eoln
            tstr += "tol2e 1.0e-10";  tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==2):
         tstr += "scf"; tstr += eoln
         #tstr += "uhf"; tstr += eoln
         tstr += "rohf"; tstr += eoln
         tstr += "doublet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if (jobtheory=="qsharp_chem"):
            tstr += "thresh 1.0e-10"; tstr += eoln
            tstr += "tol2e 1.0e-10";  tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==3):
         tstr += "scf"; tstr += eoln
         #tstr += "uhf"; tstr += eoln
         tstr += "rohf"; tstr += eoln
         tstr += "triplet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if (jobtheory=="qsharp_chem"):
            tstr += "thresh 1.0e-10"; tstr += eoln
            tstr += "tol2e 1.0e-10";  tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==4):
         tstr += "scf"; tstr += eoln
         #tstr += "uhf"; tstr += eoln
         tstr += "rohf"; tstr += eoln
         tstr += "quartet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if (jobtheory=="qsharp_chem"):
            tstr += "thresh 1.0e-10"; tstr += eoln
            tstr += "tol2e 1.0e-10";  tstr += eoln
         tstr += "end"; tstr += eoln
      if (mult==5):
         tstr += "scf"; tstr += eoln
         #tstr += "uhf"; tstr += eoln
         tstr += "rohf"; tstr += eoln
         tstr += "quintet"; tstr += eoln
         tstr += "maxiter 501"; tstr += eoln
         if (jobtheory=="qsharp_chem"):
            tstr += "thresh 1.0e-10"; tstr += eoln
            tstr += "tol2e 1.0e-10";  tstr += eoln
         tstr += "end"; tstr += eoln

      if (jobtheory=="qsharp_chem"):
         tstr += eoln
         tstr += "tce"; tstr += eoln
         tstr += "ccsd"; tstr += eoln
         tstr += "io ga"; tstr += eoln
         tstr += "2eorb"; tstr += eoln
         tstr += "2emet 13"; tstr += eoln
         tstr += "tilesize 1"; tstr += eoln
         tstr += "thresh 1.0e-6"; tstr += eoln
         if "qsharp_chem_nroots" in job:
            if (job['qsharp_chem_nroots']!=''):
               tstr += "nroots " + job['qsharp_chem_nroots']; tstr += eoln
         tstr += "end"; tstr += eoln
         if "qsharp_chem_norbs" in job:
            tstr += eoln
            tstr += "set tce:print_integrals T"; tstr += eoln
            tstr += "set tce:qorb " + job['qsharp_chem_norbs']; tstr += eoln
            tstr += "set tce:qela " + job['qsharp_chem_nalpha']; tstr += eoln
            tstr += "set tce:qelb " + job['qsharp_chem_nbeta']; tstr += eoln
      else:
         if (mult>1):
            tstr += "tce"; tstr += eoln
            tstr += "freeze atomic"; tstr += eoln
            tstr += "ccsd(t)"; tstr += eoln
            tstr += "io ga"; tstr += eoln
            tstr += "2eorb"; tstr += eoln
            tstr += "2emet 13"; tstr += eoln
            tstr += "tilesize 20"; tstr += eoln
            tstr += "end"; tstr += eoln
         else:
            tstr += "ccsd"; tstr += eoln
            tstr += "   freeze atomic"; tstr += eoln
            tstr += "   maxiter 51"; tstr += eoln
            tstr += "end"; tstr += eoln
#      tstr += "set cphf:lshift 0.1"; tstr += eoln

   return tstr


def inertia_compute(rion,masses):
   # computes the inertia
   nion = len(rion)/3
   mass = array(masses)
   for i in range(nion): mass[i] *= 1822.89
   TMass = 0.0
   for i in range(nion): TMass += mass[i]

   ## determine Ixx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i+1]**2 + rion[3*i+2]**2)
   for i in range(nion): ty += mass[i]*(rion[3*i+1])
   for i in range(nion): tz += mass[i]*(rion[3*i+2]);
   Ixx = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Iyy ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i]**2 + rion[3*i+2]**2)
   for i in range(nion): ty += mass[i]*(rion[3*i])
   for i in range(nion): tz += mass[i]*(rion[3*i+2])
   Iyy = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Izz ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i]**2 + rion[3*i+1]**2)
   for i in range(nion): ty += mass[i]*(rion[3*i])
   for i in range(nion): tz += mass[i]*(rion[3*i+1])
   Izz = tx - ty*ty/TMass - tz*tz/TMass
   ## determine Ixy  and Iyx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i]*rion[3*i+1])
   for i in range(nion): ty += mass[i]*(rion[3*i])
   for i in range(nion): tz += mass[i]*(rion[3*i+1])
   Ixy = tx - ty*tz/TMass
   Iyx = Ixy
   ## determine Ixz  and Izx ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i]*rion[3*i+2])
   for i in range(nion): ty += mass[i]*(rion[3*i])
   for i in range(nion): tz += mass[i]*(rion[3*i+2])
   Ixz = tx - ty*tz/TMass
   Izx = Ixz
   ## determine Iyz  and Izy ##
   tx = 0.0
   ty = 0.0
   tz = 0.0
   for i in range(nion): tx += mass[i]*(rion[3*i+1]*rion[3*i+2]);
   for i in range(nion): ty += mass[i]*(rion[3*i+1]);
   for i in range(nion): tz += mass[i]*(rion[3*i+2]);
   Iyz = tx - ty*tz/TMass
   Izy = Iyz

   M = [[Ixx, -Iyx, -Izx], [-Ixy, Iyy, -Izy], [-Ixz, -Iyz, Izz]]
   MM = array(M)
   return MM



def rotate_about_axis(phi,x1,x2,r1):
   #
   t   = [0,0,0]
   c   = [0,0,0]
   n   = [0,0,0]
   eta = [0,0,0]
   p   = [0,0,0]
   g   = [0,0,0]
   gg  = [0,0,0]
   r2  = [0,0,0]
   A    = [0,0,0,0,0,0,0,0,0]
   Ainv = [0,0,0,0,0,0,0,0,0]
   RR   = [0,0,0,0,0,0,0,0,0]
   #define axis
   t[0] = x2[0]-x1[0]
   t[1] = x2[1]-x1[1]
   t[2] = x2[2]-x1[2]
   sum = sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])
   t[0] = t[0]/sum
   t[1] = t[1]/sum
   t[2] = t[2]/sum

   #find unit tangent
   c[0] = r1[0]-x1[0]
   c[1] = r1[1]-x1[1]
   c[2] = r1[2]-x1[2]
   sum = sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2])
   if (abs(sum-1.0) < 0.0001):
      c[0] = r1[0]-x2[0];
      c[1] = r1[1]-x2[1];
      c[2] = r1[2]-x2[2];
      sum = sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]);
   c[0] = c[0]/sum
   c[1] = c[1]/sum
   c[2] = c[2]/sum

   #find unit normal
   sum = (c[0]*t[0] + c[1]*t[1] + c[2]*t[2]);
   if (fabs(sum-1.0) < 0.0001):
      c[0] = 1.43434934
      c[1] = -348.4294
      c[2] = 0.482442
      sum = (c[0]*t[0] + c[1]*t[1] + c[2]*t[2])
   n[0] = c[0] - sum*t[0]
   n[1] = c[1] - sum*t[1]
   n[2] = c[2] - sum*t[2]
   sum = sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2])
   n[0] = n[0]/sum
   n[1] = n[1]/sum
   n[2] = n[2]/sum

   eta[0] = (t[1]*n[2] - t[2]*n[1]);
   eta[1] = (t[2]*n[0] - t[0]*n[2]);
   eta[2] = (t[0]*n[1] - t[1]*n[0]);

   p[0] = x2[0]
   p[1] = x2[1]
   p[2] = x2[2]

   Ainv[0] = n[0]
   Ainv[1] = n[1]
   Ainv[2] = n[2]
   Ainv[3] = eta[0]
   Ainv[4] = eta[1]
   Ainv[5] = eta[2]
   Ainv[6]    = t[0]
   Ainv[7]    = t[1]
   Ainv[8]    = t[2]
   A[0] = n[0]
   A[1] = eta[0]
   A[2] = t[0]
   A[3] = n[1]
   A[4] = eta[1]
   A[5] = t[1]
   A[6] = n[2]
   A[7] = eta[2]
   A[8] = t[2]

   g[0] = r1[0] - p[0]
   g[1] = r1[1] - p[1]
   g[2] = r1[2] - p[2]
   gg[0] = A[0]*g[0] + A[3]*g[1] + A[6]*g[2]
   gg[1] = A[1]*g[0] + A[4]*g[1] + A[7]*g[2]
   gg[2] = A[2]*g[0] + A[5]*g[1] + A[8]*g[2]

   RR[0] = cos(phi)
   RR[1] = -sin(phi)
   RR[2] = 0.0
   RR[3] = sin(phi)
   RR[4] = cos(phi)
   RR[5] = 0.0
   RR[6] = 0.0
   RR[7] = 0.0
   RR[8] = 1.0
   g[0] = RR[0]*gg[0] + RR[3]*gg[1] + RR[6]*gg[2]
   g[1] = RR[1]*gg[0] + RR[4]*gg[1] + RR[7]*gg[2]
   g[2] = RR[2]*gg[0] + RR[5]*gg[1] + RR[8]*gg[2]
   gg[0] = Ainv[0]*g[0] + Ainv[3]*g[1] + Ainv[6]*g[2]
   gg[1] = Ainv[1]*g[0] + Ainv[4]*g[1] + Ainv[7]*g[2]
   gg[2] = Ainv[2]*g[0] + Ainv[5]*g[1] + Ainv[8]*g[2]
   r2[0] = gg[0] + p[0]
   r2[1] = gg[1] + p[1]
   r2[2] = gg[2] + p[2]

   return r2



def rotor_thermo(rbond1,rgroup1,sym_num,xyzfile):
   #
   tstr = '\n'
   eoln = '\n'
   thermo = {}
   NNmax      = 2000
   R          = 1.986
   boltzman   = 1.38e-23
   plank      = 6.63e-34
   CONVERT_SI = 1.67e-47
   T = 298.15
   nphi = 72
  
   oprint = (1==1)
   symbol = makesymbols(xyzfile)
   rion   = makerion(xyzfile)
   rion2  = makerion(xyzfile)
   masses = makemasses(xyzfile)

   rbond2  = rbond1.split()
   rbond = []
   for i in range(len(rbond2)):
      rbond.append(evalnum(rbond2[i]))

   rgroup2 = rgroup1.split()
   rgroup = []
   for i in range(len(rgroup2)):
      rgroup.append(evalnum(rgroup2[i]))

   thermo['rbond']  = rbond
   thermo['rgroup'] = rgroup
   thermo['rion']   = rion
   thermo['masses'] = masses
   thermo['symbol'] = symbol
   thermo['nphi']   = nphi
   thermo['T']      = T
   thermo['NNmax']   = NNmax
   thermo['sym_num'] = sym_num
   tstr += '#@@ Hindered Rotor Calculation:' + eoln
   tstr += '#@@   Temperature = %.2f' % T + eoln
   tstr += '#@@   rbond    = '+ rbond1 + eoln
   tstr += '#@@   rgroup   = '+ rgroup1 + eoln
   tstr += '#@@   rsym_num = %d' % sym_num + eoln
   tstr += '#@@   nphi     = %d' % nphi + eoln
   tstr += '#@@   NNmax    = %d' % NNmax + eoln
   tstr += '#@@' + eoln

   ## compute the total inertia ##
   for i in range(len(rion)): rion[i] /= 0.5291770
   M = inertia_compute(rion,masses)
   (e,V) = eig(M)
   IA = e[0]
   IB = e[1]
   IC = e[2]
   if (oprint):    
      tstr += '#@@ Total inertia:' + eoln
      tstr += '#@@   I=' + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (M[0][0],M[1][0],M[2][0]) + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (M[0][1],M[1][1],M[2][1]) + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (M[0][2],M[1][2],M[2][2]) + eoln
      tstr += '#@@' + eoln
      tstr += '#@@   IA = %10.6e' % (IA) + eoln
      tstr += '#@@   IB = %10.6e' % (IB) + eoln
      tstr += '#@@   IC = %10.6e' % (IC) + eoln
      tstr += '#@@' + eoln
      tstr += '#@@   VA = <%10.6e %10.6e %10.6e>' % (V[0][0],V[1][0],V[2][0]) + eoln
      tstr += '#@@   VB = <%10.6e %10.6e %10.6e>' % (V[0][1],V[1][1],V[2][1]) + eoln
      tstr += '#@@   VC = <%10.6e %10.6e %10.6e>' % (V[0][2],V[1][2],V[2][2]) + eoln
   thermo['total_inertia'] = M

   ## compute the group inertia ##
   ia1=3*(rbond[0]-1)
   ia2=3*(rbond[1]-1)
   tx = rion[ia2]   - rion[ia1]
   ty = rion[ia2+1] - rion[ia1+1]
   tz = rion[ia2+2] - rion[ia1+2]
   tt = sqrt(tx*tx + ty*ty + tz*tz)
   bond = resize(0.0,3)
   bond[0] = tx/tt
   bond[1] = ty/tt
   bond[2] = tz/tt
   submass = resize(0.0,len(rgroup))
   subrion = resize(0.0,3*len(rgroup))
   for i in range(len(rgroup)):
      submass[i] = masses[rgroup[i]-1]
      subrion[3*i]   = rion[3*(rgroup[i]-1)]
      subrion[3*i+1] = rion[3*(rgroup[i]-1)+1]
      subrion[3*i+2] = rion[3*(rgroup[i]-1)+2]
   Msub = inertia_compute(subrion,submass)

   tx = Msub[0][0]*bond[0] + Msub[1][0]*bond[1] + Msub[2][0]*bond[2]
   ty = Msub[0][1]*bond[0] + Msub[1][1]*bond[1] + Msub[2][1]*bond[2]
   tz = Msub[0][2]*bond[0] + Msub[1][2]*bond[1] + Msub[2][2]*bond[2]
   tt = bond[0]*tx + bond[1]*ty + bond[2]*tz
   if (len(rgroup)==1):
      x = rion[3*(rgroup[0]-1)]   - rion[ia2]
      y = rion[3*(rgroup[0]-1)+1] - rion[ia2+1]
      z = rion[3*(rgroup[0]-1)+2] - rion[ia2+2]
      a  = bond[0]*x + bond[1]*y + bond[2]*z
      cc = x*x + y*y + z*z
      bb  = cc - a*a
      Im0 =  1822.89*masses[rgroup[0]-1]*bb
   else:
      Im0 = tt

   if (oprint):
      tstr += '#@@' + eoln
      tstr += '#@@ Group inertia:' + eoln
      tstr += '#@@   Isub=' + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (Msub[0][0],Msub[1][0],Msub[2][0]) + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (Msub[0][1],Msub[1][1],Msub[2][1]) + eoln
      tstr += '#@@    %13.6e %13.6e %13.6e' % (Msub[0][2],Msub[1][2],Msub[2][2]) + eoln
      tstr += '#@@'   + eoln
      tstr += '#@@   rotation axis  bt  = %10.6e %10.6e %10.6e' % (bond[0],bond[1],bond[2]) + eoln
      tstr += '#@@'    + eoln
      tstr += '#@@    Im0 =  bt*Isub*b  = %10.6e' % Im0 + eoln
      tstr += '#@@    bt*b              = %10.6e' % (bond[0]*bond[0]+bond[1]*bond[1]+bond[2]*bond[2]) + eoln
   tx = bond[0]*V[0][0] + bond[1]*V[0][1] + bond[2]*V[0][2]
   ty = bond[0]*V[1][0] + bond[1]*V[1][1] + bond[2]*V[1][2]
   tz = bond[0]*V[2][0] + bond[1]*V[2][1] + bond[2]*V[2][2]
   tx = tx*tx 
   ty = ty*ty
   tz = tz*tz
   Im = Im0*(1.0 - Im0*(tx/IA + ty/IB + tz/IC))
   thermo['group_inertia'] = Msub
   thermo['Im'] = Im


   ## Pitzer and Gwinn Calculation ##
   Qf = 8.0*pi*pi*pi*Im*CONVERT_SI*boltzman*T*0.529177*0.529177/1822.89
   Qf = sqrt(Qf)/(sym_num*plank)
   Qp = (1.0/(2.0*T))*Qf 
   Sf = R*log(Qf) + 0.5*R
   Uf = R*T*T*Qp/Qf
   if (oprint):
      tstr += '#@@' + eoln
      tstr += '#@@ Free Rotation, Pitzer-Gwinn Formula:' + eoln
      tstr += '#@@    T   = %f' % (T) + eoln
      tstr += '#@@    Im  = %f (%le Kg-m2)' % (Im,Im*CONVERT_SI*0.529177*0.529177/1822.89) + eoln
      tstr += '#@@    n   = %d' % (sym_num) + eoln
      tstr += '#@@    Qf  = %f' % (Qf) + eoln
      tstr += '#@@    Uf  = %f kcal/mol (%f au)' % (Uf/1000.0,Uf/(1000.0*23.06*27.2116)) + eoln
      tstr += '#@@    Sf  = %f cal/mol-K' % (Sf) + eoln
   thermo['pitzer-gwinn'] = [T,Im,sym_num,Qf,Qp,Uf,Sf]

   ## Direct Cannical Calculation ##
   a = 0.5/Im
   QQ = -1.0
   Qp = 0.0
   for i in range(5001):
      em = a*i*i*627.51*1000.0   ## convert to calories
      QQ += 2.0*exp(-em/(R*T))
      Qp += em*exp(-em/(R*T))
   Qp = 2.0/(R*T*T)*Qp
   SS = R*log(QQ)  + (R*T/QQ)*Qp - R*log(sym_num)
   Uf = (R*T*T)*Qp/QQ
   if (oprint):
      tstr += '#@@' + eoln
      tstr += '#@@ Free Rotation, Cannonical Formula, 5001 eigenvalues used:' + eoln
      tstr += '#@@    T      = %18.3f K' % (T) + eoln
      tstr += '#@@    sigma  = %18.6f' % (sym_num) + eoln
      tstr += '#@@    Im     = %18.6f' % (Im) + eoln
      tstr += '#@@    Qf     = %18.6f' % (QQ) + eoln
      tstr += '#@@    dQf/dT = %18.6f 1/K' % (Qp) + eoln
      tstr += '#@@    Uf     = %18.6f kcal/mol (%18.6f au)' % (Uf/1000.0,Uf/(1000.0*23.06*27.2116)) + eoln
      tstr += '#@@    Sf     = %18.6f cal/mol-K' % (SS) + eoln
      tstr += '#@@' + eoln
      tstr += '#@@ IA  = %f (%e Kg-m2)' % (IA,IA*CONVERT_SI*0.529177*0.529177/1822.89) + eoln
      tstr += '#@@ IB  = %f (%e Kg-m2)' % (IB,IB*CONVERT_SI*0.529177*0.529177/1822.89) + eoln
      tstr += '#@@ IC  = %f (%e Kg-m2)' % (IC,IC*CONVERT_SI*0.529177*0.529177/1822.89) + eoln
   thermo['direct'] = [T,Im,sym_num,QQ,Qp,Uf,SS]

   return tstr



def generate_rotor_pes(jobtheory,rbond1,rgroup1,xyzfile):
   #
   nphi = 72
  
   oprint = (1==1)
   symbol = makesymbols(xyzfile)
   rion   = makerion(xyzfile)
   rion2  = makerion(xyzfile)
   masses = makemasses(xyzfile)

   rbond2  = rbond1.split()
   rbond = []
   for i in range(len(rbond2)):
      rbond.append(evalnum(rbond2[i]))

   rgroup2 = rgroup1.split()
   rgroup = []
   for i in range(len(rgroup2)):
      rgroup.append(evalnum(rgroup2[i]))


   ## calculate the rotor potential ##
   eoln = '\n'
   tstr = eoln
   tstr += '#@@' + eoln
   tstr += '#@@ theory = ' + jobtheory + eoln
   tstr += '#@@' + eoln

   if (nphi > 0):
      tstr += '\n'
      ia1=3*(rbond[0]-1)
      ib1=ia1+3
      x1 = rion[ia1:ib1]
      ia1=3*(rbond[1]-1)
      ib1=ia1+3
      x2 = rion[ia1:ib1]
      dphi = (2*pi/nphi)

      ## calculate the dr/dphi numerically ##
      gphi = dphi*0.03125
      x = 1.0/gphi
      rionp = [0.0]*len(rion)
      rionm = [0.0]*len(rion)
      grad  = [0.0]*len(rion)
      for ii in range(len(rion)): 
         rionp[ii] = rion[ii]
         rionm[ii] = rion[ii]
      for ii in rgroup:
         ii1 = 3*(ii-1)
         ii2 = ii1 + 3
         rionp[ii1:ii2] = rotate_about_axis( 0.5*gphi,x1,x2,rionp[ii1:ii2])
         rionm[ii1:ii2] = rotate_about_axis(-0.5*gphi,x1,x2,rionm[ii1:ii2])
      for ii in range(len(rion)): grad[ii] = x*(rionp[ii]-rionm[ii])
      tstr += '#@@'
      ii = 0
      for g in grad: 
         if ((ii%10)==0): tstr += eoln + '#@@ drion/dphi ='
         tstr += " %.6f" % g
         ii += 1
      tstr += eoln
      tstr += '#@@' + eoln

      ## calculate the tphi  ##
      tphi  = [0.0]*len(rion)
      a = [x2[0]-x1[0],x2[1]-x1[1],x2[2]-x1[2]]
      aa = 1.0/math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
      a[0] *= aa
      a[1] *= aa
      a[2] *= aa
      for kk in rgroup:
         kk1 = 3*(kk-1)
         kk2 = kk1 + 3
         x3  = rion[kk1:kk2]
         r   = [x3[0]-x1[0],x3[1]-x1[1],x3[2]-x1[2]]
         ar  = a[0]*r[0] + a[1]*r[1] + a[2]*r[2]
         b   = [r[0]-a[0]*ar, r[1]-a[1]*ar, r[2]-a[2]*ar]
         bb  = 1.0/math.sqrt(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])
         b[0] *= bb
         b[1] *= bb
         b[2] *= bb
         c = [bb*(a[1]*b[2]-a[2]*b[1]),bb*(a[2]*b[0]-a[0]*b[2]),bb*(a[0]*b[1]-a[1]*b[0])]
         tphi[kk1:kk2] = c
      tstr += '#@@'
      ii = 0
      for g in tphi: 
         if ((ii%10)==0): tstr += eoln + '#@@ tphi ='
         tstr += " %.6f" % g
         ii += 1
      tstr += eoln
      tstr += '#@@' + eoln
      tstr += eoln


      for i in range(nphi):
         phi = i*dphi
         for ii in range(len(rion)): rion2[ii] = rion[ii]
         for ii in rgroup:
            ii1 = 3*(ii-1)
            ii2 = ii1 + 3
            rion2[ii1:ii2] = rotate_about_axis(phi,x1,x2,rion2[ii1:ii2])
         tstr += '#### phi=%0.3f radians ####\n' % phi
         tstr += 'geometry units angstroms print xyz noautosym\n'
         for ii in range(len(rion2)/3):
            tstr += '%s   %f %f %f\n' % (symbol[ii],rion2[3*ii],rion2[3*ii+1],rion2[3*ii+2])
         tstr += 'end\n'
         tstr += 'task ' + jobtheory + ' energy\n\n'
   return tstr



def maketasks(jobtype,jobtheory,radii,rbond,rgroup,mbond1,mbond2,xyzfile,zcoords,solvation_type,job):
   #
   eoln = "\n"
   tstr1 =eoln
   for i in range(len(jobtype)):
      tstr = ''
      ### Energy calculation ###
      if (jobtype[i]=='e'): tstr = "task %s energy ignore" % jobtheory

      ### Gradient calculation ###
      if (jobtype[i]=='g'): tstr = "task %s gradient" % jobtheory

      ### Geometry optimization calculation ###
      if (jobtype[i]=='o'): 

        if (job['diagonal_hessian']):
           dstr = "driver; default; diagonal_hessian; maxiter %d; clear; end\n" % (geom_maxiter)
        else:
           dstr = "driver; default; maxiter %d; clear; end\n" % (geom_maxiter)
        if (job['smear']>1.0e-6):
           dstr += "task %s energy ignore\n" % jobtheory
           dstr += "unset dft:smear_sigma\n"
           dstr += "unset dft:converged\n"
           if ('cgmin' in job['optimizer']):   
              dstr += "set dft:cgmin .true."; dstr += eoln

        dstr += "task %s optimize ignore\n" % jobtheory

        if (job['lower_tolerances']):
          tstr += eoln
          tstr += "#### reduced thresholds, since gaussian dft optimizers are clunky ####\n"
          tstr += "dft; "
          tstr += "convergence density 1.0e-3 gradient 1.0e-3; "
          tstr += "end\n"
          tstr += dstr
          tstr += eoln
          tstr += "#### regular dft thresholds ####\n"
          tstr += "dft; "
          tstr += "convergence density 1.0e-5 gradient 5.0e-4; "
          tstr += "end\n"
          tstr += dstr
        else:
          tstr += dstr

      ### vibrational calculation ###
      if (jobtype[i]=='v'): tstr = "task %s freq numerical" % jobtheory
      if (jobtype[i]=='w'): tstr = "task %s freq" % jobtheory

      ### COSMO calculation ###
      if (jobtype[i]=='c'): 
         if 'COSMO-SMD' in solvation_type:
            if (':') in solvation_type:
               svnt = solvation_type.split(':')[1]
            else:
               svnt = 'h2o'
            tstr += "cosmo\n"
            tstr += "   do_cosmo_smd .true.\n"
            tstr += "   solvent %s\n" % svnt
            tstr += "\nend\n"
            if ("pspw" in jobtheory): tstr += "set nwpw:cosmo2 .true.\n"
            tstr += "task %s energy ignore" % jobtheory
         elif (solvation_type=='COSMO'):
            if ("pspw" not in jobtheory):
               tstr = "unset dft:converged\n"
               tstr = "unset scf:converged\n"
            tstr += "cosmo\n"
            if ("pspw" not in jobtheory): tstr += "   do_gasphase .true.\n"
            #tstr += "   rsolv  0.5\n"
            tstr += "   rsolv  0.0\n"
            tstr += "   ifscrn 2\n"
            tstr += "   minbem 3\n"
            tstr += "   maxbem 3\n"
            tstr += "   radius "
            for j in range(len(radii)):
               tstr += "%f " % radii[j]
            tstr += "\nend\n"
            if ("pspw" in jobtheory): tstr += "set nwpw:cosmo2 .true.\n"
            tstr += "task %s energy ignore" % jobtheory
         elif (solvation_type=='Born'):
            if ("pspw" in jobtheory):
               tstr += "nwpw\n"
               tstr += "   born on\n"
               tstr += "end\n"
               tstr += "task %s energy ignore" % jobtheory

#      ### COSMO SMD calculation ###
#      if (jobtype[i]=='d'): 
#         tstr += "cosmo\n"
#         tstr += "   do_cosmo_smd .true.\n"
#         tstr += "   solvent water\n"
#         tstr += "\nend\n"
#         tstr += "task %s energy ignore" % jobtheory


      if (jobtype[i]=='r'): 
         tstr = rotor_thermo(rbond,rgroup,job['sym_num'],xyzfile)
         tstr += generate_rotor_pes(jobtheory,rbond,rgroup,xyzfile)
      if (jobtype[i]=='m'): 
         m1  = mbond1.split();
         m2  = mbond2.split();
         s1 = "[%s,%s]" % (m1[0],m1[1])
         s2 = "[%s,%s]" % (m2[0],m2[1])
         tstr  = "python\n"
         ofile = open(nwpythonlib,'r')
         tstr  += ofile.read()
         ofile.close()
         tstr += "result = nwgeom_2springoptimize(\'%s\',\'geometry\',101,%s,%s,0.25)\n" % (jobtheory,s1,s2)
         tstr += "end\n"
         tstr += "task python\n"

      ### NMR calculation ###
      if (jobtype[i]=='n'): 
         jobxc = ''
         if (job['theory_property']=='pspw' or job['theory_property']=='dft'):
            jobxc = job['xc_property']
       
         tstr += maketheory(job['theory_property'],jobxc,job['mult'],job['property_pspw4'],job['property_paw'],job['basis_property'],job['basisHZ_property'],job)
         tstr += "property\n"
         tstr += "   shielding\n"
         tstr += "\nend\n"
         tstr += "task %s property" % job['theory_property']


      ### hole (remove electron) calculation ###
      if (jobtype[i]=='h'): 
         jobxc = ''
         if (job['theory_property']=='pspw' or job['theory_property']=='dft'):
            jobxc = job['xc_property']

         hmult = job['mult_h']
         tstr += maketheory(job['theory_property'],jobxc,hmult,job['property_pspw4'],job['property_paw'],job['basis_property'],job['basisHZ_property'],job)
         tstr += "charge %d\n" % (job['charge']+1)
         tstr += "task %s energy" % job['theory_property']


      ### particle (extra electron)  calculation ###
      if (jobtype[i]=='p'): 
         jobxc = ''
         if (job['theory_property']=='pspw' or job['theory_property']=='dft'):
            jobxc = job['xc_property']

         pmult = job['mult_p']
         tstr += maketheory(job['theory_property'],jobxc,pmult,job['property_pspw4'],job['property_paw'],job['basis_property'],job['basisHZ_property'],job)
         tstr += "charge %d\n" % (job['charge']-1)
         tstr += "task %s energy" % job['theory_property']


      if (jobtype[i]=='z'): 
        tstr  = zcoords[i]
        #tstr += "driver; maxiter 50; clear; end\n"
        #tstr += "task %s optimize ignore" % jobtheory

      ### COSMO intrinsic calculation ###
      if (jobtype[i]=='y'): 
         if ('COSMO-SMD' in solvation_type):
            if (':') in solvation_type:
               svnt = solvation_type.split(':')[1]
            else:
               svnt = 'h2o'
            tstr += "cosmo\n"
            tstr += "   do_cosmo_smd .true.\n"
            tstr += "   solvent %s\n" % svnt
            tstr += "\nend\n"
         elif ('Born'==solvation_type):
            if ("pspw" in jobtheory):
               tstr += "nwpw\n"
               tstr += "   born on\n"
               tstr += "end\n"
         else:
            tstr += "cosmo\n"
            tstr += "   do_gasphase .false.\n"
            tstr += "   rsolv  0.5\n"
            tstr += "   minbem 3\n"
            tstr += "   maxbem 3\n"
            tstr += "   radius "
            for j in range(len(radii)):
               tstr += "%f " % radii[j]
            tstr += "\nend\n"

      ### intrinsic constraint optimization calculation ###
      if (jobtype[i]=='l'): 
         if (job['reaction_type']!='') and (job['reaction_indexes']!='') and (job['reaction_gamma']!='') and (job['reaction_hash']!=''):
            tstr += "\n"
            tstr += "################ reaction constraint ##################\n"
            tstr += "#Constraint: reaction_type="+job['reaction_type']+"\n"
            tstr += "#Constraint: reaction_indexes="+job['reaction_indexes']+"\n"
            tstr += "#Constraint: reaction_gamma="+job['reaction_gamma']+"\n"
            tstr += "#Constraint: reaction_kappa="+job['reaction_kappa']+"\n"
            rstr = job['reaction_hash']
            nr = len(rstr)
            istart = 0
            for ii in range(nr/72):
               tstr += "#Constraint: reaction_hash:"+rstr[istart:(istart+72)]+":reaction_hash\n"
               istart += 72
            tstr += "#Constraint: reaction_hash:"+rstr[istart:] + ":reaction_hash\n"
            cmd9 = chemdb_balance_reaction + "-c \"" + job['reaction_indexes'] + "\" \"" + job['reaction_type'] + "\""
            result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
            bondings = result9.split("spring bondings K gamma")[1].split("\n")[0].strip()
            with open(job['xyzfile'],'r') as ff:
               aa = ff.read() 
            nion = evalnum(aa.split('\n')[0]) 
            lines = aa.split('\n')[2:]
            rxyz = []
            for ii in range(nion):
               ss = lines[ii].split()
               x = evalnum(ss[1])/0.529177
               y = evalnum(ss[2])/0.529177
               z = evalnum(ss[3])/0.529177
               rxyz.append(x)
               rxyz.append(y)
               rxyz.append(z)
            bbb = bondings.split()
            nbonds = len(bbb)/3
            sgamma = 0.0
            for b in range(nbonds):
               coef = evalnum(bbb[3*b])
               ii   = evalnum(bbb[3*b+1])-1
               jj   = evalnum(bbb[3*b+2])-1
               x = rxyz[3*ii]   - rxyz[3*jj]
               y = rxyz[3*ii+1] - rxyz[3*jj+1]
               z = rxyz[3*ii+2] - rxyz[3*jj+2]
               d = math.sqrt(x*x + y*y + z*z)
               sgamma += coef*d
            tstr += "#Constraint: start_gamma=%.3f\n\n" % sgamma
            dstr = "\n#### partial gamma with reduced thresholds, since gaussian dft optimizers are clunky ####\n"
            if (jobtheory=="dft"):
               dstr += "dft; convergence density 1.0e-3 gradient 1.0e-3; end\n"
            dstr += "driver; loose; maxiter 20; clear; end\n"
            dstr += "task %s optimize ignore\n\n" % jobtheory
            egamma = evalnum(job['reaction_gamma'])
            while (abs(sgamma-egamma)>2.0):
               if (sgamma<egamma):
                  sgamma += 2.0
               else:
                  sgamma -= 2.0
               tstr += "##### current gamma=%f ######\n" % sgamma
               tstr += "constraints\n"
               tstr += "   clear\n"
               tstr += "   spring bondings " + job['reaction_kappa'] + " %f " % sgamma  + " " +  bondings + "\n"
               tstr += "end\n"
               tstr += dstr

            tstr += "constraints\n"
            tstr += "   clear\n"
            tstr += "   spring bondings " + job['reaction_kappa'] + " " + job['reaction_gamma'] + " " +  bondings + "\n"
            tstr += "end\n"
            if (not job['diagonal_hessian']) and (jobtheory=='dft'):
               job['lower_tolerances'] = True
            


      #### COSMO-SMD intrinsic calculation ###
      #if (jobtype[i]=='f'):
      #   tstr += "cosmo\n"
      #   tstr += "   do_cosmo_smd .true.\n"
      #   tstr += "   solvent water\n"
      #   tstr += "\nend\n"

      ### Saddle calculation ###
      if (jobtype[i]=='s'): 
        tstr += "task %s saddle ignore" % jobtheory

      if (jobtype[i]=='a'): 
         tstr = "neb\n"
         tstr += "   impose\n"
         tstr += "   algorithm 0\n"
         tstr += "   maxiter 10\n"
         tstr += "   nbeads 10\n"
         tstr += "   stepsize 1.0\n"
         tstr += "   kbeads 0.001\n"
         tstr += "end\n"
         tstr += "task %s neb ignore" % jobtheory
         tstr += "neb\n"
         tstr += "   kbeads 0.01\n"
         tstr += "end\n"
         tstr += "task %s neb ignore" % jobtheory
         tstr += "neb\n"
         tstr += "   kbeads 0.1\n"
         tstr += "end\n"
         tstr += "task %s neb ignore" % jobtheory
         tstr += "cosmo\n"
         tstr += "   lineq 0\n"
         tstr += "   rsolve 0.5\n"
         tstr += "   minbem 3\n"
         tstr += "   maxbem 3\n"
         tstr += "   radius "
         for j in range(len(radii)):
            tstr += "%f " % radii[j]
         tstr += "\nend\n"
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000001:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000002:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000003:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000004:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000005:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000006:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000007:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000008:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000009:geom\n"
         tstr += "task %s energy ignore" % jobtheory
         tstr += "unset dft:converged\n"
         tstr += "unset scf:converged\n"
         tstr += "set geometry neb_bead_000010:geom\n"
         tstr += "task %s energy ignore" % jobtheory

      ### equilibrium aimd calculation ###
      if (jobtype[i]=='q'):
         temp   = job['equilibrium_temperature']
         nouter = int((job['equilibrium_time']*1.e-12/2.41889e-17)/50.0)+1
         tstr =  "\n"
         tstr += "nwpw\n"
         tstr += "   initial_velocities %f %d\n" % (temp,job['seed'])
         tstr += "   car-parrinello\n"
         tstr += "      temperature %f start\n" %  temp
         tstr += "      time_step 5.0\n"
         tstr += "      scaling 0.0 1.0\n"
         tstr += "      fake_mass 750.0\n"
         tstr += "      loop 10 %d\n" % nouter
         tstr += "      xyz_filename        tequil-%d.xyz\n" % job['queue_number']
         tstr += "      ion_motion_filename tequil-%d.ion_motion\n" % job['queue_number']
         tstr += "      emotion_filename    tequil-%d.emotion\n" % job['queue_number']
         tstr += "      fei                 tequil-%d.fei\n" % job['queue_number']
         tstr += "      eigmotion_filename  tequil-%d.eigmotion\n" % job['queue_number']
         tstr += "   end\n"
         tstr += "   cpmd_properties off\n"
         tstr += "   mulliken\n"
         tstr += "   rotation off\n"
         tstr += "end\n"
         tstr += "task pspw energy\n"
         tstr += "task pspw car-parrinello\n\n"

      ### constant energy aimd calculation ###
      if (jobtype[i]=='k'):
         nouter = int((job['equilibrium_time']*1.e-12/2.41889e-17)/50.0)+1
         tstr = "\n"
         tstr += "nwpw\n"
         tstr += "   dipole_motion energy-%d.dipole_motion\n" % job['queue_number']
         tstr += "   car-parrinello\n"
         tstr += "      energy\n"
         tstr += "      time_step 5.0\n"
         tstr += "      scaling 0.0 1.0\n"
         tstr += "      fake_mass 750.0\n"
         tstr += "      loop 10 %d\n" % nouter
         tstr += "      xyz_filename        energy-%d.xyz\n" % job['queue_number']
         tstr += "      ion_motion_filename energy-%d.ion_motion\n" % job['queue_number']
         tstr += "      emotion_filename    energy-%d.emotion\n" % job['queue_number']
         tstr += "      fei                 energy-%d.fei\n" % job['queue_number']
         tstr += "   end\n"
         tstr += "   cpmd_properties on\n"
         tstr += "   mulliken off\n"
         tstr += "   rotation off\n"
         tstr += "end\n"
         tstr += "task pspw energy\n"
         tstr += "task pspw car-parrinello\n\n"

      ### sampling aimd calculation ###
      if (jobtype[i]=='d'):
         temp   = job['sampling_temperature']
         nouter = int((job['sampling_time']*1.e-12/2.41889e-17)/50.0)+1
         tstr =  "nwpw\n"
         tstr += "   car-parrinello\n"
         tstr += "      temperature %f\n" %  temp
         tstr += "      time_step 5.0\n"
         tstr += "      scaling 1.0 1.0\n"
         tstr += "      fake_mass 750.0\n"
         tstr += "      loop 10 %d\n" % nouter
         tstr += "      xyz_filename        tsample-%d.xyz\n" % job['queue_number']
         tstr += "      ion_motion_filename tsample-%d.ion_motion\n" % job['queue_number']
         tstr += "      emotion_filename    tsample-%d.emotion\n" % job['queue_number']
         tstr += "      fei                 tsample-%d.fei\n" % job['queue_number']
         tstr += "      eigmotion_filnemae  tsample-%d.eigmotion\n" % job['queue_number']
         tstr += "   end\n"
         tstr += "   cpmd_properties on\n"
         tstr += "   mulliken\n"
         tstr += "   rotation off\n"
         tstr += "end\n"
         tstr += "task pspw car-parrinello\n\n"

      ### Gaussian cube calculation ###
      if (jobtype[i]=='b'):
         if (job['theory']=='pspw') and (job['mult']==1):
            tstr =  "\n\n### Generating HOMO and LUMO Gaussian cube files ###\n"
            tstr +=  "nwpw\n"
            tstr += "   virtual 8\n"
            tstr += "   dplot\n"
            tstr += "      orbital 1 homo-restricted.cube\n"
            tstr += "      density total density.cube\n"
            #tstr += "      density potential potential.cube\n"
            tstr += "   end\n"
            tstr += "end\n"
            tstr += "task pspw energy ignore\n"
            tstr += "task pspw pspw_dplot\n\n"
            tstr +=  "nwpw\n"
            tstr += "   dplot\n"
            tstr += "      vectors %s.emovecs\n" % job['name']
            tstr += "      orbital 1 lumo-restricted.cube\n"
            tstr += "   end\n"
            tstr += "end\n"
            tstr += "task pspw pspw_dplot\n\n"
         if (job['theory']=='pspw') and (job['mult']>1):
            ncharge = xyz2ncharge(job['xyzfile'],job['charge'])
            ndn = (ncharge-mult+1)/2
            nup = ndn + mult - 1
            tstr =  "\n\n### Generating HOMO and LUMO Gaussian cube files ###\n"
            tstr +=  "nwpw\n"
            tstr += "   virtual 8\n"
            tstr += "   dplot\n"
            tstr += "      orbital 1         homo-alpha.cube\n"
            if (ndn>0):
               tstr += "      orbital 123456789 homo-beta.cube\n"
            else:
               tstr += "      orbital 1 homo-beta.cube\n"
            tstr += "      density total density.cube\n"
            #tstr += "      density potential potential.cube\n"
            tstr += "   end\n"
            tstr += "end\n"
            tstr += "task pspw energy ignore\n"
            tstr += "task pspw pspw_dplot\n\n"
            tstr +=  "nwpw\n"
            tstr += "   dplot\n"
            tstr += "      vectors %s.emovecs\n" % job['name']
            tstr += "      orbital 1 lumo-alpha.cube\n"
            tstr += "      orbital 123456789 lumo-beta.cube\n"
            tstr += "   end\n"
            tstr += "end\n"
            tstr += "task pspw pspw_dplot\n\n"

         if ((job['theory']=='dft') or (job['theory']=='hf')) and (job['mult']==1):
            ncharge = xyz2ncharge(job['xyzfile'],job['charge'])
            nup = ncharge/2
            tstr =  "\n\n### Generating HOMO and LUMO Gaussian cube files ###\n"
            tstr += "dplot\n"
            tstr += "   TITLE HOMO_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin total\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            tstr += "   %d\n" % nup
            tstr += "   gaussian\n"
            tstr += "   output homo-restricted.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"
            tstr += "dplot\n"
            tstr += "   TITLE LUMO_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin total\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            tstr += "   %d\n" % (nup+1)
            tstr += "   gaussian\n"
            tstr += "   output lumo-restricted.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"

         if ((job['theory']=='dft') or (job['theory']=='hf')) and (job['mult']>1):
            ncharge = xyz2ncharge(job['xyzfile'],job['charge'])
            ndn = (ncharge-mult+1)/2
            nup = ndn + mult - 1
            tstr =  "\n\n### Generating HOMO and LUMO Gaussian cube files ###\n"
            tstr += "dplot\n"
            tstr += "   TITLE HOMO_Alpha_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin alpha\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            tstr += "   %d\n" % nup
            tstr += "   gaussian\n"
            tstr += "   output homo-alpha.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"
            tstr += "dplot\n"
            tstr += "   TITLE LUMO_Alpha_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin alpha\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            tstr += "   %d\n" % (nup+1)
            tstr += "   gaussian\n"
            tstr += "   output lumo-alpha.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"
            tstr += "dplot\n"
            tstr += "   TITLE HOMO_Beta_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin beta\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            if (ndn>0):
               tstr += "   %d\n" % ndn
            else:
               tstr += "   %d\n" % (ndn+1)
            tstr += "   gaussian\n"
            tstr += "   output homo-beta.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"
            tstr += "dplot\n"
            tstr += "   TITLE LUMO_Beta_Orbital\n"
            tstr += "   vectors %s.movecs\n" % job['name']
            tstr += "   LimitXYZ\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   -15.0 15.0 96\n"
            tstr += "   spin beta\n"
            tstr += "   orbitals view\n"
            tstr += "   1\n"
            tstr += "   %d\n" % (ndn+1)
            tstr += "   gaussian\n"
            tstr += "   output lumo-beta.cube\n"
            tstr += "end\n"
            tstr += "task dplot\n"

         #if (job['theory_property']=='dft'):
         #tstr = "task %s energy ignore" % jobtheory




      tstr1 += tstr+eoln

   return tstr1



def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().strip()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula




def make_jobname(job):
   #
   dash = "-"
   mformula = xyz_molecular_formula(job['xyzfile'])
   if (job['theory']=='pspw' or job['theory']=='dft'):
      jobxc = job['xc']
   else:
      jobxc = 'xxx'
   jtheory = job['theory'].replace('(','').replace(')','').replace('[','').replace(']','').replace('{','').replace('}','')

   #jobname = jtheory+dash+jobxc+dash+mformula+dash+"%d" % job['queue_number']
   jobname = jtheory+dash+jobxc+dash+"%d" % job['queue_number']
   jobname = ''.join(jobname.split())
   jobname = jobname.replace(" ","")
   return jobname
   


def make_nwinputdeck(job):
   #

   tstr = ''

   mformula = xyz_molecular_formula(job['xyzfile'])
   jobxc = ''
   if (job['theory']=='pspw' or job['theory']=='dft' or job['theory']=='tddft'): jobxc = job['xc']

 

   ## appendfile ##
   if ('appendfile' in job):
      for line in job['appendfile'].split("\n"): tstr += "#"+line+"\n"

   ## header ##
   tstr += makeheader(job['name'],job['theory'],jobxc,job['type'],mformula,job['charge'],job['mult'],job['vtag'],job['machine'],job['permdir'],job['mem'])

   ## geometry ##
   if (job['type'].find('a') != -1):
      tstr += makegeom_neb(job['xyzfile'],job['xyzfile2'])
   else:
      vv = job['diagonal_hessian'] or (job['solvation_type']=='aimdmm')
      tstr += makegeom(job['xyzfile'],vv)

   ## theory ##
   tstr += maketheory(job['theory'],jobxc,job['mult'],job['pspw4'],job['paw'],job['basis'],job['basisHZ'],job)

   ## tasks ##
   tstr += maketasks(job['type'],taskjobtheory(job['theory'],job['mult']),makecosmoradii(job['xyzfile']),job['rbond'],job['rgroup'],job['mbond1'],job['mbond2'],job['xyzfile'],job['zcoords'],job['solvation_type'],job)

   return tstr




def make_nwchemjob(job):
   #
   eoln = "\n"
   nwtstr = ''
   nwtstr += "nwchem_input  %s\n" % job['nwchem_input']
   nwtstr += "nwchem_output %s\n" % job['nwchem_output']
   nwtstr += "nwchem_done   %s\n" % job['nwchem_done']
   nwtstr += eoln
   nwtstr += "transfer_files *.xyz *.ion_motion *.emotion *.fei *.cif *.hist *.gr *.dat *.meta_gaussians *.cube PAIR_DISTRIBUTION VEL_CORRELATION POWER_SPECTRUM\n"
   nwtstr += eoln
   nwtstr += "permdir %s\n" % job['permdir']
   nwtstr += "deletescratch yes\n"
   nwtstr += "queuesave no\n"
   nwtstr += "addtochemdb yes\n"
   nwtstr += eoln
   
   if ('medium_' in job['machine']):
      machine = job['machine'].lstrip('medium_')
      nwtstr += "machine %s\n" % machine
      nwtstr += "cputime 16:00:00\n"
      nwtstr += "ncpus 32\n"
   elif ('large_' in job['machine']):
      machine = job['machine'].lstrip('large_')
      nwtstr += "machine %s\n" % machine
      nwtstr += "cputime 24:00:00\n"
      nwtstr += "ncpus 64\n"
   elif ('small_' in job['machine']):
      machine = job['machine'].lstrip('small_')
      nwtstr += "machine %s\n" % machine
      nwtstr += "cputime 12:00:00\n"
      nwtstr += "ncpus 8\n"
   elif ('tiny_' in job['machine']):
      machine = job['machine'].lstrip('tiny_')
      nwtstr += "machine %s\n" % machine
      nwtstr += "cputime 12:00:00\n"
      nwtstr += "ncpus 2\n"
   elif ('serial_' in job['machine']):
      machine = job['machine'].lstrip('serial_')
      nwtstr += "machine %s\n" % machine
      nwtstr += "cputime 12:00:00\n"
      nwtstr += "ncpus 1\n"
   else:
      theory  = job['theory']
      machine = job['machine']
      nwtstr += "machine %s\n" % machine
      if (machine=='olympus'):
         nwtstr += "cputime 48:00:00\n"
         nwtstr += "ncpus 16\n"
      elif (machine=='constance'):
         nwtstr += "cputime 48:00:00\n"
         if theory=="ccsd(t)":
            nwtstr += "ncpus 240\n"
         else:
            nwtstr += "ncpus 24\n"
      elif (machine=='cascade'):
         if theory=="ccsd(t)":
            nwtstr += "ncpus 256\n"
            nwtstr += "cputime 40:00:00\n"
         else:
            nwtstr += "ncpus 32\n"
            nwtstr += "cputime 24:00:00\n"
      else:
         nwtstr += "cputime 24:00:00\n"
         if (machine=='hopper'):
            nwtstr += "ncpus 48\n"
         elif (machine=='hdevelop'):
            nwtstr += "ncpus 48\n"
         else:
            nwtstr += "ncpus 32\n"
   if (machine=='magellan'):
      nwtstr += "queue magellan\n"
   else:
      nwtstr += "queue regular\n"

   if ('priority' in job):     nwtstr += "priority " + job['priority']     + eoln
   if ('emailresults' in job): nwtstr += "email "    + job['emailresults'] + eoln

   nwtstr += "\n"
   #nwtstr += "@remote_directory /Users/bylaska/Projects/TNTQ/%d\n" % ddrand)
   #nwtstr += "@remote_directory " + submitdir + "\n"
   #if (remote_computer!=None):
   #   #nwtstr += "@remote_computer  we24397.emsl.pnl.gov\n")
   #   nwtstr += "@remote_computer " + remote_computer + "\n"

   return nwtstr




##################################### main program ##########################################
usage = \
"""
Generates an nwchem job for a molecule

  Usage: tnt_submit -v tag:value -e email -m machine -t theory -b basis -c calculation_type -x exchange-correlation -y solvation -q charge -s multiplicity -g maxiter -r -h   xyz file / cml file / esmiles string

  -m machine
  -t theory
  -b basis
  -z basisHZ
  -p property
  -k theory_property
  -l xc_property
  -o basis_property
  -n basisHZ_property
  -c calculation_type, e.g. ovc or owc
  -x exchange_correlation
  -y solvation
  -q charge of molecule
  -s multiplicity of molecule
  -p property
  -r rotate the rotamers
  -g number of geometry optimization iterations
  -i check the queue
  -f don't submit jobs, inputdeck to stdout
  -d deletes the job files 
  -w use diagonal hessian
  -e email results
  -v qtag:qvalue
  -u priority
  -a append file to input

  --mo_coefficients include mo coefficients in the output
  --arrows_api=url enter arrows url

  -h,--help prints this message


"""

#print('TNT NWChem Submission Program\n')
tt   = time.localtime()
gt   = time.gmtime()
dd   = "-%d-%d-%d-%d:%d" % (tt[0],tt[1],tt[2],tt[3],tt[4])
ddlt = time.asctime(tt)
job  = {}
job['submit_time'] = pickle.dumps(tt)
job['submit_gm_time'] = pickle.dumps(gt)


emailresults = ''
machine  = ''
theory   = ''
basis    = ''
basisHZ  = ''
xc       = ''
property = ''
optimizer = ''
smear = 0.0
theory_property   = ''
basis_property    = ''
basisHZ_property  = ''
xc_property       = ''
calctype = ''
xyzdata  = ''
solvation_type = ''
solvent_type = ''
molarity = ''
equilibrium_time = ''
equilibrium_temperature = ''
sampling_time    = ''
sampling_temperature    = ''
constraint_string = ''
constraint_value  = ''
enroots = ''
estate = ''
esurface = ''
unitcell = ''
seed     = -1
q        = 0
mult     = 1
vtag     = ''
notmultset   = True
notchargeset = True
rotamer      = False
reaction_type = ''
reaction_indexes = ''
reaction_gamma = ''
reaction_kappa = '1.0'
reaction_hash  = ''
rbond = ''
rgroup= ''
sym_num = 1
diagonal_hessian = False
lower_tolerances = False
include_mocoefficients = False
jobname  = "tntjob"
submitthejob = True
qsharp_chem_nroots = ''
qsharp_chem_norbs  = '2'
qsharp_chem_nalpha = '1'
qsharp_chem_nbeta  = '1'
opts, args = getopt.getopt(sys.argv[1:], "a:e:u:v:m:t:b:n:z:p:c:x:y:q:g:s:j:k:l:o:idfrwh",['help','arrows_api=']) 
for o, a in opts:
  if o=='-a':
     job['appendfilename'] = a
     with open(a,'r') as ff: job['appendfile'] = datafile_prune(ff.read())
  if o=='-e':
     emailresults = a
  if o=='-v':
     vtag = a
     print("# - adding tag " + vtag + " to input deck.\n" )
  if o=='-m':
     machine = a
  if o=='-t':
     theory = a
  if o=='-b':
     basis = a
  if o=='-z':
     basisHZ = a
  if o=='-p':
     property = a
  if o=='-k':
     theory_property = a
  if o=='-l':
     xc_property = a
  if o=='-o':
     basis_property = a
  if o=='-n':
     basisHZ_property = a
  if o=='-c':
     calctype = a
  if o=='-x':
     xc = a
  if o=='-y':
     solvation_type = a
  if o=='-q':
     q = evalnum(a)
     notchargeset = False
  if o=='-g':
     geom_maxiter = evalnum(a)
  if o=='-s':
     mult = evalnum(a)
     notmultset = False
  if o=='-j':
     jobname = a
  if o=='-u':
     job['priority'] = a

  if o=='-i':
    exit()
  if o=='-r':
     rotamer = True
  if o=='-w':
     diagonal_hessian = True
  if o=='-d':
    exit()
  if o=='-f':
    submitthejob = False
  if o=="--arrows_api":
     ARROWS_API_HOME = a

  if o in ("-h","--help"):
    print(usage)
    exit()

print('# NWChem Input Generation (tnt_submit5)  - The current time is ' + ddlt)

if (len(args)<1):
   print("\nEnter xyz file / cml file / esmiles string:")
   xyzsmiles  = sys.stdin.readline()[:-1]
else:
   xyzsmiles  = args[0]

esmiles = addspaces_esmiles(xyzsmiles.strip())

##### this is an aimd-mm simulation #####
if "theory{aimd-mm}" in esmiles.lower():
   cmd6 = solvatedsolute_esmiles + '\"' + esmiles + '\"'
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   print(result)
   exit()

isdatafile = False
if (os.path.isfile(xyzsmiles.split()[0])):
   isdatafile = True
   if (xyzsmiles.find('.cml') != -1):
      #job['cmlfile'] = xyzsmiles.split()[0]
      job['cmlfile'] = wrkdir + "/" + tmpjob + ".cml"
      with open(xyzsmiles.split()[0],'r') as ff: aa = ff.read()
      with open(job['cmlfile'],'w') as ff:   ff.write(aa)
      job['smiles']  = cml2smiles(xyzsmiles.split()[0])
      job['xyzfile'] = wrkdir + "/" + tmpjob + ".xyz"
      cml2xyz(xyzsmiles,job['xyzfile'])
   else:
      #job['xyzfile'] = xyzsmiles.split()[0]
      job['xyzfile'] = wrkdir + "/" + tmpjob + ".xyz"
      with open(xyzsmiles.split()[0],'r') as ff: aa = ff.read()
      with open(job['xyzfile'],'w') as ff:   ff.write(aa)
      job['smiles']  = xyz2smiles(xyzsmiles.split()[0])
      job['cmlfile'] = wrkdir + "/" + tmpjob + ".cml"
      xyz2cml(xyzsmiles.split()[0],job['cmlfile'])
else:
   #esmiles = addspaces_esmiles(xyzsmiles.strip())
   #print("tnt_submit esmiles = " + esmiles)
   xyzsmiles = esmiles.split()[0]
   job['smiles']  = nametosmiles(xyzsmiles)
   job['xyzfile'] = wrkdir + "/" + tmpjob + ".xyz"
   job['cmlfile'] = wrkdir + "/" + tmpjob + ".cml"
   smiles2xyz(xyzsmiles,job['xyzfile'])

if 'qsharp_chem_filling{' in esmiles: 
   qsharp_chem_norbs  = esmiles.split('qsharp_chem_filling{')[1].split('}')[0].strip().split()[0]
   qsharp_chem_nalpha = esmiles.split('qsharp_chem_filling{')[1].split('}')[0].strip().split()[1]
   qsharp_chem_nbeta  = esmiles.split('qsharp_chem_filling{')[1].split('}')[0].strip().split()[2]
if 'qsharp_chem_nroots{' in esmiles: qsharp_chem_nroots  = esmiles.split('qsharp_chem_nroots{')[1].split('}')[0].strip()
if 'qsharp_chem_norbs{' in esmiles:  qsharp_chem_norbs   = esmiles.split('qsharp_chem_norbs{')[1].split('}')[0].strip()
if 'qsharp_chem_nalpha{' in esmiles: qsharp_chem_nalpha  = esmiles.split('qsharp_chem_nalpha{')[1].split('}')[0].strip()
if 'qsharp_chem_nbeta{'  in esmiles: qsharp_chem_nbeta   = esmiles.split('qsharp_chem_nbeta{')[1].split('}')[0].strip()


if 'reaction_type{' in    esmiles: reaction_type    = esmiles.split('reaction_type{')[1].split('}')[0].strip()
if 'reaction_indexes{' in esmiles: reaction_indexes = esmiles.split('reaction_indexes{')[1].split('}')[0].strip()
if 'reaction_gamma{' in   esmiles: reaction_gamma   = esmiles.split('reaction_gamma{')[1].split('}')[0].strip()
if 'reaction_kappa{' in   esmiles: reaction_kappa   = esmiles.split('reaction_kappa{')[1].split('}')[0].strip()
if 'reaction_hash{' in esmiles: reaction_hash = esmiles.split('reaction_hash{')[1].split('}')[0].strip()
if 'reaction_genhash{' in esmiles: 
   #reaction_genhash = esmiles.split('reaction_genhash{')[1].split('}')[0].strip()
   #reaction_genhash = esmiles.split('reaction_genhash{')[1].strip().rstrip('}')
   reaction_genhash = ''
   jjj = esmiles.split('reaction_genhash{')[1]
   nj = len(jjj)
   i = 0
   pc = 0
   done = False
   while (not done):
      cc = jjj[i]
      if ((cc == '}') and (pc<1)) or (i>(nj-2)):
         done = True
      else:
         if (cc == '{'): pc += 1
         if (cc == '}'): pc -= 1
         reaction_genhash += cc
         i += 1
   cmd9 = chemdb_balance_reaction + "-x \"0 0 0 0 0 " + reaction_genhash + "\""
   #print("cmd9=",cmd9)
   result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
   if "bstringsall =" in result9:
      bstringsall = eval(result9.split("bstringsall = ")[1].split('\n')[0].strip())
      reaction_hash = bstringsall[0][3]
   #print("cmd9 reaction_hash=",reaction_hash)

if (reaction_hash=='') and (reaction_type!='') and (reaction_indexes!=''):
   cmd9 = chemdb_balance_reaction + "-r " + job['xyzfile'] + " \"" + reaction_indexes + "\" \"" + reaction_type + "\""
   result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
   reaction_hash = result9.split("rhash =")[1].split("\n")[0].strip()
elif (reaction_hash!='') and (reaction_type=='') and (reaction_indexes==''):
   reaction_type = reaction_hash.split(":")[1].strip()
   cmd9 = chemdb_balance_reaction + "-e " + job['xyzfile'] + " \"" + reaction_hash + "\""
   result9 = subprocess.check_output(cmd9,shell=True).decode("utf-8")
   indexes = eval(result9.split("reaction indexes=")[1].split("\n")[0])
   #print("indexes=",indexes)
   if (len(indexes)>0):
      for ii in indexes[0][0]:
         reaction_indexes += "%d " % (ii+1)
   #print("result9=",result9)
   #print("reaction_type=",reaction_type)
   #print("reaction_indexes=",reaction_indexes)
   

if 'rotamer{' in esmiles:
   tt = esmiles.split('rotamer{')[1].split('}')[0]
   if tt.lower()=='true' or tt.lower()=='on' or tt.lower()=='yes':
      rotamer = True
   else:
      rotamer = False

if 'rbond{' in esmiles:  rbond  = esmiles.split('rbond{')[1].split('}')[0]
if 'rgroup{' in esmiles: rgroup = esmiles.split('rgroup{')[1].split('}')[0]
if 'rsym_num{' in esmiles: sym_num = evalnum(esmiles.split('sym_num{')[1].split('}')[0])
if 'vtag{' in esmiles: 
   tvtag = esmiles.split('vtag{')[1].split('}')[0].strip()
   if tvtag not in vtag:
      vtag += " " + tvtag
   #vtag += " " + esmiles.split('vtag{')[1].split('}')[0]

if 'client{' in esmiles: 
   client = esmiles.split("client{")[1].split("}")[0]
   tvtag = "client:"+client+":client"
   if tvtag not in vtag:
      vtag += " " + tvtag

if 'appendfile{' in esmiles:
   afile = esmiles.split('appendfile{')[1].split('}')[0]
   with open(afile,'r') as ff: job['appendfile'] = datafile_prune(ff.read())

if xyzdata==''  and 'xyzdata{' in esmiles: xyzdata = esmiles.split('xyzdata{')[1].split('}')[0]
if theory==''   and 'theory{' in esmiles: theory   = esmiles.split('theory{')[1].split('}')[0]
if unitcell==''   and 'unitcell{' in esmiles: unitcell = esmiles.split('unitcell{')[1].split('}')[0]
if xc==''       and 'xc{' in esmiles:     xc       = esmiles.split('xc{')[1].split('}')[0]
if theory_property==''   and 'theory_property{' in esmiles: theory_property   = esmiles.split('theory_property{')[1].split('}')[0]
if xc_property==''       and 'xc_property{' in esmiles:     xc_property       = esmiles.split('xc_property{')[1].split('}')[0]
if calctype=='' and 'calculation_type{' in esmiles: calctype = esmiles.split('calculation_type{')[1].split('}')[0]
if solvation_type=='' and 'solvation_type{' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
if solvent_type=='' and 'solvent_type{' in esmiles: solvent_type = esmiles.split('solvent_type{')[1].split('}')[0]
if molarity=='' and 'molarity{' in esmiles: molarity = esmiles.split('molarity{')[1].split('}')[0]
if equilibrium_time=='' and 'equilibrium_time{' in esmiles: equilibrium_time = esmiles.split('equilibrium_time{')[1].split('}')[0]
if equilibrium_temperature=='' and 'equilibrium_temperature{' in esmiles: equilibrium_temperature = esmiles.split('equilibrium_temperature{')[1].split('}')[0]
if sampling_time=='' and 'sampling_time{' in esmiles: sampling_time = esmiles.split('sampling_time{')[1].split('}')[0]
if sampling_temperature=='' and 'sampling_temperature{' in esmiles: sampling_temperature = esmiles.split('sampling_temperature{')[1].split('}')[0]

if constraint_string=='' and 'constraint_string{' in esmiles: constraint_string = esmiles.split('constraint_string{')[1].split('}')[0].strip()
if constraint_value==''  and 'constraint_value{'  in esmiles: constraint_value  = esmiles.split('constraint_value{')[1].split('}')[0].strip()


if enroots==''  and 'enroots{'  in esmiles: enroots  = esmiles.split('enroots{')[1].split('}')[0].strip()
if estate==''   and 'estate{'   in esmiles: estate   = esmiles.split('estate{')[1].split('}')[0].strip()
if esurface=='' and 'esurface{' in esmiles: esurface = esmiles.split('esurface{')[1].split('}')[0].strip()


if optimizer=='' and 'optimizer{' in esmiles: optimizer = esmiles.split('optimizer{')[1].split('}')[0]
if (smear==0.0) and 'smear{' in esmiles: smear = evalnum(esmiles.split('smear{')[1].split('}')[0])
if property=='' and 'property{' in esmiles: property = esmiles.split('property{')[1].split('}')[0]
if basis==''    and 'basis{' in esmiles:
   basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
   if 'ry' in basis.lower():
     xb = evalnum(basis.strip().split()[0])*0.5
     basis = '%f' % xb
   if 'hartree' in basis.lower():
     xb = evalnum(basis.strip().split()[0])*1.0
     basis = '%f' % xb
if basis_property==''    and 'basis_property{' in esmiles:
   basis_property  = removespace_basis(esmiles.split('basis_property{')[1].split('}')[0])
   if 'ry' in basis_property.lower():
     xb = evalnum(basis_property.strip().split()[0])*0.5
     basis_property = '%f' % xb
   if 'hartree' in basis_property.lower():
     xb = evalnum(basis_property.strip().split()[0])*1.0
     basis_property = '%f' % xb
if basisHZ==''    and 'basisHZ{' in esmiles:
   basisHZ = removespace_basis(esmiles.split('basisHZ{')[1].split('}')[0])
   if 'ry' in basisHZ.lower():
     xb = evalnum(basisHZ.strip().split()[0])*0.5
     basisHZ = '%f' % xb
   if 'hartree' in basisHZ.lower():
     xb = evalnum(basisHZ.strip().split()[0])*1.0
     basisHZ = '%f' % xb
if basisHZ_property==''    and 'basisHZ_property{' in esmiles:
   basisHZ_property = removespace_basis(esmiles.split('basisHZ_property{')[1].split('}')[0])
   if 'ry' in basisHZ_property.lower():
     xb = evalnum(basisHZ_property.strip().split()[0])*0.5
     basisHZ_property = '%f' % xb
   if 'hartree' in basisHZ_property.lower():
     xb = evalnum(basisHZ_property.strip().split()[0])*1.0
     basisHZ_property = '%f' % xb


if 'priority{' in esmiles: 
   job['priority'] = esmiles.split('priority{')[1].split('}')[0]
if 'emailresults' in esmiles: 
   emailresults = esmiles.split('email{')[1].split('}')[0]
if 'geometry_generation{' in esmiles: 
   job['geometry_generation'] = esmiles.split('geometry_generation{')[1].split('}')[0]
   if "cactus"  in job['geometry_generation']: reset_use_cactus_geom()
   if "norotat" in job['geometry_generation']: rotamer = False

if 'seed{' in esmiles:
   seed = evalnum(esmiles.split('seed{')[1].split('}')[0])
if 'mult{' in esmiles: 
   mult = evalnum(esmiles.split('mult{')[1].split('}')[0])
   notmultset = False
if '^{' in esmiles:
   q = evalnum(esmiles.split('^{')[1].split('}')[0])
   notchargeset = False

if (mult>1):
   mult_p = mult-1
   mult_h = mult-1
else:
   mult_p = mult+1
   mult_h = mult+1
if 'mult_p{' in esmiles: mult_p = evalnum(esmiles.split('mult_p{')[1].split('}')[0])
if 'mult_h{' in esmiles: mult_h = evalnum(esmiles.split('mult_h{')[1].split('}')[0])


if (xyzdata==''):
   if (solvation_type=='aimdmm'):
      job['solutejob'] = smilespmf2xyz(esmiles,job['xyzfile'])
   elif ("appendfile" in job):
      print("# Generating xyz data from appendfile.")
      datafile_xyzfile(job['appendfile'],job['xyzfile'])
      if (theory=="mp2") or (theory=="ccsd(t)") or (theory=="qsharp_chem") or (theory=="ccsd"): 
         rotamer = False

if (xyzdata!=''):
   if xyzdata.strip().split()[0].isalpha():
       nion = len(xyzdata.strip().split("|"))
       with open(job['xyzfile'],'w') as f:
          f.write("%d\n\n" % nion)
          f.write(xyzdata.replace('|','\n').strip())
   else:
       with open(job['xyzfile'],'w') as f: f.write(xyzdata.replace('|','\n').strip())

   job['cmlfile']  = wrkdir + "/" + tmpjob + ".cml"
   xyz2cml(job['xyzfile'],job['cmlfile'])


### define kindatoms ###
kindatoms = []
with  open(job['xyzfile'],"r") as ff:
   natoms =  evalnum(ff.readline())
   ff.readline()
   for i in range(natoms):
      line = ff.readline().split()
      found = False
      for ka in kindatoms:
         if (ka==line[0]):
            found = True
      if (not found):
         kindatoms.append(line[0])
job['kindatoms'] = kindatoms



## set seed number ##
if (seed>0):
   job['seed'] = seed
else:
   #if (qnumber_collection.find({'queue':'seed'}).count()>0):
   if (qnumber_collection.find_count({'queue':'seed'})>0):
      job['seed']  = qnumber_collection.find_one({'queue':'seed'})['count']
   else:
      job['seed'] = 1
      qqq = qnumber_collection.insert({'queue':'seed', 'count':1})
   if ismongo:
      qqq = qnumber_collection.update({'queue':'seed'},{'$inc':{'count':1}},upsert=False,multi=False)
   else:
      seedp1 = job['seed']+1
      qqn = {'count': seedp1}
      qqq = qnumber_collection.update_one({'queue':'seed'},{'$set':qqn})




if (rotamer):
   jkj = xyzrotamer(job['xyzfile'])
   print("# Rotating single bonds in " + job['xyzfile'] + "." + jkj)


#if (machine ==''): machine= 'constance'
if (submitthejob):
   if  (machine ==''): 
      machine = theorysmiles2machine(theory,job['smiles'])
else:
   machine = "Shirky"
   #machine = "email_machine"

if (theory=='qsharp_chem') and (basis==''):   basis = 'sto-3g'
if (theory=='qsharp_chem') and (basisHZ==''): basisHZ = 'sto-3g'

if (theory == ''): theory ='dft'
if (basis==''):    basis  ='default'
if (basisHZ==''):  basisHZ  ='default'

if (reaction_hash!=''):
  if (calctype=='' and solvation_type=='COSMO'):     calctype='lovcb'
  if (calctype=='' and ('COSMO-SMD' in solvation_type)): calctype='lovcb'
  if (calctype=='' and ('Born' in solvation_type)): calctype='lovcb'
  if (calctype=='' and solvation_type=='None'):      calctype='lovb'
  if (calctype=='' and theory=='pspw'):    calctype='lovb'
  if (calctype=='' and theory=='paw'):     calctype='lovb'
  if (calctype=='' and theory=='pspw4'):   calctype='lovb'
  if (calctype=='' and theory=='paw4'):    calctype='lovb'
  if (calctype=='' and (theory=='dft' or theory=='hf' or theory=='uhf' or theory=='am1' or theory=='pm3' or theory=='mndo' or theory=='mindo3')):
     solvation_type = 'COSMO'
     calctype='lovcb'

if (calctype=='' and solvation_type=='COSMO'):     calctype='ovcb'
if (calctype=='' and ('COSMO-SMD' in solvation_type)): calctype='ovcb'
if (calctype=='' and ('Born' in solvation_type)): calctype='ovcb'
if (calctype=='' and solvation_type=='aimdmm'):    calctype='eqd'
if (calctype=='' and solvation_type=='None'):      calctype='ovb'
if (calctype=='' and theory=='paw'):     calctype='ov'
if (calctype=='' and theory=='paw4'):    calctype='ov'
if (calctype=='' and theory=='aimd'):    calctype='eqkb'
if (calctype=='' and theory=='aimd4'):    calctype='eqkb'
if (calctype=='' and (theory=='pspw4' or theory=='dft' or theory=='hf' or theory=='uhf' or theory=='am1' or theory=='pm3' or theory=='mndo' or theory=='mindo3')):
      solvation_type = 'COSMO'
      calctype='ovcb'
if (calctype=='' and (theory=='pspw')):
      solvation_type = 'Born'
      calctype='ovcb'

if (theory=='qsharp_chem') and (calctype!='r'): calctype='e'
if (theory=='ccsd') and (calctype!='r'): calctype='e'
if (theory=='ccsd(t)') and (calctype!='r'): calctype='e'
if (theory=='mp2') and (calctype!='r'):     calctype='e'
if ((esurface!='') and (theory=='dft')):
   theory = 'tddft'
elif ((estate!='') and (theory=='dft')):
   theory = 'tddft'
   if (solvation_type=='COSMO' or ('COSMO-SMD' in solvation_type)):
      calctype='c'
   else:
      calctype='e'

if ('nmr' in property): calctype += 'n'
if 'mo_coefficients' in property: include_mocoefficients = True


if (xc==''):
   if ((theory=='pspw') or (theory=='pspw4') or (theory=='paw') or (theory=='paw4') or (theory=='aimd') or (theory=='aimd4')):
       xc='pbe'
   else:
       xc='b3lyp'
if (theory_property == ''):  theory_property  = theory
if (basis_property  == ''):  basis_property   = basis
if (basisHZ_property == ''): basisHZ_property = basisHZ
if (xc_property == ''):      xc_property      = xc

if (solvent_type=='' and solvation_type=='aimdmm'): solvent_type = 'spcwater'

if (equilibrium_time=='' and (theory=='aimd' or theory=='aimd4')):        equilibrium_time = "10.0"
if (equilibrium_temperature=='' and (theory=='aimd' or theory=='aimd4')): equilibrium_temperature = "300.0"
if (sampling_time=='' and (theory=='aimd' or theory=='aimd4')):           sampling_time = "10.0"
if (sampling_temperature=='' and (theory=='aimd' or theory=='aimd4')):      sampling_temperature = "300.0"

if (equilibrium_time=='' and solvation_type=='aimdmm'):        equilibrium_time = "1.0"
if (equilibrium_temperature=='' and solvation_type=='aimdmm'): equilibrium_temperature = "300.0"
if (sampling_time=='' and solvation_type=='aimdmm'):        sampling_time = "10.0"
if (sampling_temperature=='' and solvation_type=='aimdmm'): sampling_temperature = "300.0"

job['emailresults'] = emailresults
job['machine'] = machine
job['basis']   = basis
job['basisHZ'] = basisHZ
job['basis_property']   = basis_property
job['basisHZ_property'] = basisHZ_property
job['type']    = calctype
job['xc']      = xc
job['xc_property']  = xc_property
job['charge']  = q
job['mult']    = mult
job['vtag']    = vtag
job['solvation_type'] = solvation_type
job['solvent_type']   = solvent_type
job['esurface'] = esurface
job['estate']   = estate
job['enroots']  = enroots
job['unitcell'] = unitcell.replace('|','\n').strip()

job['mult_p']    = mult_p
job['mult_h']    = mult_h

if (molarity==''): job['molarity']   = 1.0

if (equilibrium_time!=''):        job['equilibrium_time'] = evalnum(equilibrium_time)
if (equilibrium_temperature!=''): job['equilibrium_temperature'] = evalnum(equilibrium_temperature)

if (sampling_time!=''):        job['sampling_time'] = evalnum(sampling_time)
if (sampling_temperature!=''): job['sampling_temperature'] = evalnum(sampling_temperature)


if 'bonddiff' in constraint_string:
   if (constraint_value == ''):
      constraint_value1 = 2.0
      constraint_value2 = 2.0
   else:
      print("# constraint_value=",constraint_value)
      constraint_value1 = evalnum(constraint_value.split(',')[0])
      constraint_value2 = evalnum(constraint_value.split(',')[1])
   job['constraint_value1'] = constraint_value1
   job['constraint_value2'] = constraint_value2
   a = constraint_value1/0.529177
   b = constraint_value2/0.529177
   constraint_value = a*a - b*b
elif 'bond' in constraint_string:
   if (constraint_value == ''):
      constraint_value = 2.0
   else:
      constraint_value = evalnum(constraint_value)

else:
   constraint_string = ''
   constraint_value = 0.0

job['constraint_string'] = constraint_string
job['constraint_value']  = constraint_value



job['theory'] = theory
if (job['theory']=='pspw4'):
   job['theory'] = 'pspw'
   job['pspw4']  = True
   job['paw']    = False
elif (job['theory']=='paw'):
   job['theory'] = 'pspw'
   job['pspw4']  = False
   job['paw']    = True
elif (job['theory']=='paw4'):
   job['theory'] = 'pspw'
   job['pspw4']  = True
   job['paw']    = True
elif (job['theory']=='aimd'):
   job['theory'] = 'pspw'
   job['pspw4']  = False
   job['paw']    = False
   job['aimd']   = True
elif (job['theory']=='aimd4'):
   job['theory'] = 'pspw'
   job['pspw4']  = True
   job['paw']    = False
   job['aimd']   = True
else:
   job['pspw4'] = False
   job['paw']   = False

job['theory_property'] = theory_property
if (job['theory_property']=='pspw4'):
   job['theory_property'] = 'pspw'
   job['property_pspw4']  = True
   job['property_paw']    = False
elif (job['theory_property']=='paw'):
   job['theory_property'] = 'pspw'
   job['property_pspw4']  = False
   job['property_paw']    = True
elif (job['theory_property']=='paw4'):
   job['theory_property'] = 'pspw'
   job['property_pspw4']  = True
   job['property_paw']    = True
else:
   job['property_pspw4'] = False
   job['property_paw']   = False

#if ((machine!='cascade')  and \
#   (machine!='we29676')   and \
#   (machine!='constance') and \
#   (machine!='gorgon')    and \
#   (machine!='we13550')   and \
#   (machine!='we18535')   and \
#   (machine!='we19993')   and \
#   (machine!='we16124')   and \
#   (machine!='wd37710')   and \
#   (machine!='we25447')   and \
#   (machine!='arrows')   and \
#   (machine!='seattle-1') and \
#   (machine!='edison')    and \
#   (machine!='emslcs00')  and \
#   (machine!='emslcs01')  and \
#   (machine!='emslcs02')  and \
#   (machine!='arrow1')  and \
#   (machine!='Shirky')  and \
#   (machine!='felectron')  and \
#   (machine!='we22258')  and \
#   (machine!='coheed')  and \
#   (machine!='orbital')  and \
#   (machine!='we20961')): diagonal_hessian = False
job['diagonal_hessian'] = diagonal_hessian
job['lower_tolerances'] = lower_tolerances
job['include_mocoefficients'] = include_mocoefficients
job['optimizer'] = optimizer
job['smear'] = smear

job['reaction_type']    = reaction_type
job['reaction_hash']    = reaction_hash
job['reaction_indexes'] = reaction_indexes
job['reaction_gamma']   = reaction_gamma
job['reaction_kappa']   = reaction_kappa

job['qsharp_chem_norbs']    = qsharp_chem_norbs
job['qsharp_chem_nalpha']   = qsharp_chem_nalpha
job['qsharp_chem_nbeta']    = qsharp_chem_nbeta
job['qsharp_chem_nroots']   = qsharp_chem_nroots

job['rbond'] = rbond
job['rgroup']= rgroup
job['sym_num'] = sym_num
job['mbond1'] = " "
job['mbond2'] = " "
job['zcoords'] = []

job['jobname'] = jobname
job['curdir']  = curdir
job['deletetmpfiles']  = True

job['csmiles'] = cannonicalsmiles(job['smiles'])

if (notchargeset):
   job['charge'] = smiles2charge(job['smiles'])

if (notmultset):
   mult_test  = xyz2mult(job['xyzfile'],job['charge'])
   if (((mult_test+mult)%2)==1): 
      mult = mult_test
      job['mult'] = mult

job['pubchem_cid']       = pubchem_smiles2cid(job['smiles'])
job['pubchem_cid_link']  = pubchem_smiles2cid_link(job['smiles'])
job['pubchem_iupac']     = pubchem_smiles2iupac(job['smiles'])
job['pubchem_synonyms']  = pubchem_smiles2synonyms(job['smiles'])
job['pubchem_synonym0']  = pubchem_smiles2synonym0(job['smiles'])
job['pubchem_smiles']    = pubchem_cid2smiles(job['pubchem_cid'])
job['InChI']             = smiles2InChI(job['smiles'])
job['InChIKey']          = smiles2InChIKey(job['smiles'])
job['twirl']             = smiles2twirl(job['smiles'])
job['nmrdb']             = smiles2nmrdb(job['smiles'])
job['image']             = smiles2image(job['smiles'])
job['chemical_structure_asciiart']  = smiles2ascii(job['smiles'])

job['mformula'] = xyz_molecular_formula(job['xyzfile'])
job['cosmoradii'] = makecosmoradii(job['xyzfile'])

#print("\nEnter memory:")
#job['mem']=sys.stdin.readline()[:-1]
if (job['theory']=="ccsd(t)") or (job['theory']=="qsharp_chem") or (job['theory']=='ccsd'):
   job['mem'] = "stack 800 mb heap 100 mb global 1000 mb"
else:
   job['mem']="1900 mb"

## set queue number  and submitdir ##
#queue_number00  = qnumber_collection.find_one({'queue':'tnt'})['count']
#if (qnumber_collection.find({'queue':'tnt'}).count()>0):
if (qnumber_collection.find_count({'queue':'tnt'})>0):
   queue_number00  = qnumber_collection.find_one({'queue':'tnt'})['count']
else:
   queue_number00 = 1
   qqq = qnumber_collection.insert({'queue':'tnt', 'count':1})
if ismongo:
   qqq = qnumber_collection.update({'queue':'tnt'},{'$inc':{'count':1}},upsert=False,multi=False)
else:
   qp1 = queue_number00+1
   qqn = {'count': qp1}
   qqq = qnumber_collection.update_one({'queue':'tnt'},{'$set':qqn})


## set queue number ##
job['queue_number']  = queue_number00


print("# ")
print("#  - pubchem_synonyms = ",job['pubchem_synonyms'])
print("# ")
print("#  - queue_number     = ",job['queue_number'])
print("#  - mformula         = ",job['mformula'])
print("#  - name             = ",xyzsmiles)
print("#  - smiles           = ",job['smiles'])
print("#  - csmiles          = ",job['csmiles'])
print("#  - InChI            = ",job['InChI'])
print("#  - InChIKey         = ",job['InChIKey'])
print("#  - pubchem_cid      = ",job['pubchem_cid_link'])
print("#  - pubchem_smiles   = ",job['pubchem_smiles'])
print("#  - pubchem_iupac    = ",job['pubchem_iupac'])
print("#  - pubchem_synonym0 = ",job['pubchem_synonym0'])
print("#  - theory           = ",job['theory'])
if ('aimd' in job): print("#  - aimd simulation  = ",job['aimd'])
print("#  - pspw4            = ",job['pspw4'])
print("#  - paw              = ",job['paw'])
if (job['theory']=='dft' or job['theory']=='pspw' or job['theory']=='tddft'):
   print("#  - xc               =",job['xc'])
print("#  - basis            = ",job['basis'])
print("#  - basisHZ          = ",job['basisHZ'])
print("#  - theory_property       = ",job['theory_property'])
print("#  - property_pspw4        = ",job['property_pspw4'])
print("#  - property_paw          = ",job['property_paw'])
if (job['theory_property']=='dft' or job['theory_property']=='pspw' or job['theory']=='tddft'):
   print("#  - xc_property      =",job['xc_property'])
print("#  - basis_property   = ",job['basis_property'])
print("#  - basisHZ_property = ",job['basisHZ_property'])
print("#  - type             = ",job['type'])
print("#  - solvation_type   = ",job['solvation_type'])
print("#  - charge           = ",job['charge'])
print("#  - mult             = ",job['mult'])
print("#  - babel gen. xyz   = ", (not bad_smiles2xyz_geom))
print("#  - cactus gen. xyz  = ", use_cactus_geom)
print("#  - bonds rotated    = ", rotamer)
print("#  - machine          = ",job['machine'])
print("#  - emailresults     = ",job['emailresults'])
print("# ")
print("#  - twirl webpage    = ",job['twirl'])
print("#  - image webpage    = ",job['image'])
print(job['nmrdb'])
print("# ")
for line in job['chemical_structure_asciiart'].split("\n"): print("#" + line)
print("# ")

###############################
#### submit the input deck ####
###############################


if (submitthejob):

   ### submit to shirky queue ###
   if (machine=="Shirky"):
      tmp_esmiles = esmiles.strip()
      if (isdatafile):
         tmp_esmiles += " theory{%s}" % theory
         tmp_esmiles += " xc{%s}" % xc
         tmp_esmiles += " basis{%s}" % basis
         tmp_esmiles += " solvation_type{%s}" % solvation_type
         tmp_esmiles += " calculation_type{%s}" % calctype
         tmp_esmiles += " ^{%d}" % q
         if (basisHZ!=""): tmp_esmiles += " basisHZ{%s}" % basisHZ
         if (mult>1):      tmp_esmiles += " mult{%d}" % mult
         if (property!=''): tmp_esmiles += " property{%s}" % property

      if ('appendfile' not in tmp_esmiles) and ('appendfilename' in job):
         tmp_esmiles += ' appendfile{' + job['appendfilename'] + '} '
      if ('rotamer' not in tmp_esmiles) and (rotamer): 
         tmp_esmiles += ' rotamer{true} '
      cmd1_submit = chemdb_queue +  '-a \"' + tmp_esmiles + '\"'
      if (vtag!=''): cmd1_submit += ' -v "' + vtag + '"'
      print("cmd1_submit=",cmd1_submit)
      result1 = subprocess.check_output(cmd1_submit,shell=True).decode("utf-8")
      print("cmd1_submit RESULT = ", result1)
      job['status']  = "submitted"

   ### submit to nwchem queue ###
   else:
      #### create the submitdir ####
      submitdir = submitdir0 + "/%d" % queue_number00
      os.system("mkdir " + submitdir)

      job['name']              = make_jobname(job)
      job['nwchem_input']      = job['name'] + ".nw"
      job['nwchem_output']     = job['name'] + ".out"
      job['nwchem_done']       = job['name'] + ".done"

      job['permdir']               = jobname + "_%d" % job['queue_number']
      job['submitdir']             = submitdir
      job['nwchem_input_submit']   = submitdir + "/" + job['name'] + ".nw"
      job['nwchemjob_submit']      = submitdir + "/nwchem-%d.job" % job['queue_number']

      job['nwchem_input_deck']     = make_nwinputdeck(job)
      job['nwchemjob_submit_deck'] = make_nwchemjob(job)

      #copy input to queue directory and call submit_nwchem
      with open(job['nwchem_input_submit'],'w') as ofile:
         ofile.write(job['nwchem_input_deck'])
      with open(job['nwchemjob_submit'],'w') as ofile:
         ofile.write(job['nwchemjob_submit_deck'])

      inputfile  = submitdir   + "/" + job['nwchem_input']
      donefile   = submitdir   + "/" + job['nwchem_done']

      #cmd_submit = remote_nwchem + " -r " + submitdir + " " + job['nwchemjob_submit']
      cmd_submit = "cd " + submitdir + "; " + remote_nwchem + " " +  job['nwchemjob_submit']
      result1 = subprocess.check_output(cmd_submit,shell=True).decode("utf-8")
      print("cmd_submit= ", result1)

      job['status']  = "submitted"


#############################################
#### just print the input deck to stdout ####
#############################################
else:
   ## set queue number ##
   #job['queue_number']  = 1234

   job['name']              = make_jobname(job)
   job['nwchem_input']      = job['name'] + ".nw"
   job['nwchem_output']     = job['name'] + ".out"
   job['nwchem_done']       = job['name'] + ".done"
   job['permdir']           = jobname + "_%d" % job['queue_number']
   job['nwchem_input_deck'] = make_nwinputdeck(job)
   print(job['nwchem_input_deck'])



#### removing tmp files ####
try:
   os.unlink(wrkdir + "/" + tmpsmi1)
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpsmi1

try:
   os.unlink(wrkdir + "/" + tmpsmi2)
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpsmi2

try:
   os.unlink(wrkdir + "/" + tmpsdf1)
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpsdf1

try:
   os.unlink(wrkdir + "/" + tmpsdf2)
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpsdf2

try:
   os.unlink(wrkdir + "/" + tmpjunk)
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpjunk

try:
   os.unlink(wrkdir + "/" + tmpjob + ".xyz")
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpjob+ ".xyz"

try:
   os.unlink(wrkdir + "/" + tmpjob + ".cml")
except:
   a = 1 
   #print "tnt_submit failed unlinking " + wrkdir + "/" + tmpjob+ ".cml"


