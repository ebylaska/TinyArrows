#!/usr/local/bin/python

import sys,os,time,pickle,math,MySQLdb,urllib2,getopt,subprocess,pexpect,random,operator
from math import *

############## machine parameters #########################
babel              = "/usr/local/bin/babel"
obabel             = "/usr/local/bin/obabel "
esmiles2xyz        = "/Users/bylaska/bin/esmiles2xyz "
chemdb_add_request = "/Users/bylaska/bin/chemdb_add_request "
chemdb_freq        = "/Users/bylaska/bin/chemdb_freq -v "
chemdb_add_Hf      = "/Users/bylaska/bin/chemdb_add_Hf "
chemdb_image0      = "/Users/bylaska/bin/chemdb_image0 "
chemdb_reaction_image = "/Users/bylaska/bin/chemdb_reaction_image "
tnt_submit         = "/Users/bylaska/bin/tnt_submit "
queue_nwchem_em    = "/Users/bylaska/bin/queue_nwchem_em "
wrkdir             = "/Users/bylaska/Projects/Work"
arrowslogo         = wrkdir + "/arrowslogo2.html"
arrowslogosvg      = wrkdir + "/arrowslogo2.svg"
gnuplot            = "/usr/local/bin/gnuplot "
#gnuplot            = "/usr/local/octave/3.8.0/bin/gnuplot "
with open('/Users/bylaska/bin/.chemdb','r') as f:
   hup0            = f.readline().strip()
   archivemachine  = f.readline().strip()
   archivepassword = f.readline().strip()
ddrand = random.randint(0,999999)
tmpsmi1 = "tmpsmi1-%d.smi" % ddrand
tmpsmi2 = "tmpsmi2-%d.smi" % ddrand
tmpxyz1 = "tmpxyz1-%d.xyz" % ddrand
tmperxn = "tmperxn-%d.dat" % ddrand
tmperxn2= "tmperxn2-%d.dat" % ddrand
tmperxn3= "tmperxn3-%d.dat" % ddrand
tmpnwout= "tmpnwout-%d.out" % ddrand
############## machine parameters #########################

headerfigure = ['<a href="http://dl.dropboxusercontent.com/s/1fdkluujb97tr0b/banner2.gif"><img src="http://dl.dropboxusercontent.com/s/1fdkluujb97tr0b/banner2.gif" alt="Arrows Banner Movie"> </a>', '<a href="http://dl.dropboxusercontent.com/s/en5l9l7l31ggz6e/EMSL_banner.jpg"><img src="http://dl.dropboxusercontent.com/s/en5l9l7l31ggz6e/EMSL_banner.jpg" alt="EMSL Computing Banner" border=0 /></a>', '<a href="http://dl.dropboxusercontent.com/s/rcoee0m9urc4e3o/Surface-uprot.gif"><img src="http://dl.dropboxusercontent.com/s/rcoee0m9urc4e3o/Surface-uprot.gif" alt="Arrows Movie" width="200" height="200"> </a>']

##### define the arrows logos #####
ArrowsHeader = '''
   <center> <p><b>EMSL Arrows: Evolultion of Chemical and Materials Simulations</b></p></center>
   <center> <p>Making molecular modeling accessible by combining NWChem, databases, and email</p> </center>
   <center> %s </center>
''' % headerfigure[1]


alogosvg = "</pre>\n"
with open(arrowslogosvg,'r') as f: alogosvg += f.read()
alogosvg += '''

<pre style=\"font-size:0.6em;color:darkgreen\">
KEYWORDs -
   reaction: :reaction
   molecule: :molecule
   nmr: :nmr
   submitesmiles: :submitesmiles
   submitmissingesmiles
   submitmachines: :submitmachines
   useallentries
   nomodelcorrect
   eigenvalues: :eigenvalues
   frequencies: :frequencies
   nwoutput: :nwoutput
   alleigs: :alleigs
   allfreqs: :allfreqs

   reactionenumerate:
      energytype:[erxn(gas) hrxn(gas) grxn(gas) delta_solvation grxn(aq)] :energytype
      energytype:[kcal/mol kj/mol ev cm-1 ry hartree au] :energytype
      tablereactions:
         reaction: ... :reaction
         reaction: ... :reaction
         ...
      :tablereactions
      tablemethods:
         method: ... :method
         method: ... :method
         ...
      :tablemethods
   :reactionenumerate

   rotatebonds
   xyzinput:
      label:  :label
      xyzdata:
       ... xyz data ...
      :xyzdata
   :xyzinput

   submitHf: :submitHf
   nmrexp: :nmrexp

   findreplace: old text | new text :findreplace

   listnwjobs
   fetchnwjob: :fetchnwjob
   pushnwjob:  :pushnwjob

   printcsv: :printcsv
   printeig: :printeig
   printfreq: :printfreq
   printxyz: :printxyz
   printjobinfo: :printjobinfo
   printnwout: :printnwout
   badids: :badids
   hup_string: 
   database:
   table:
   request_table:
   queuecheck                     </pre> <pre style=\"font-size:0.6em;color:black\">

'''


alogo = '''
</pre> <pre style=\"font-size:0.6em;color:darkgreen\">


                                                                                    
                                             Qk,                    
                                             Q  R,                  
                                             Q   .KQ                
                                             Q      ?Q              
 w                                           Q        "g            
 Q h                                         @          `W          
 Q   ",                                      @            `k,       
 Q     `g      [Thermodynamics and Kinetics] @               RQ     
 h       `v..................................@     EMSL        KQ   
`k````````x``````````````````````````````````@```````````````````R  
 [      m        [  of Molecules and Solids] @    Arrows      ,#    
 [    4.                                     @              ,R      
 [ ,4                                        @            yR.       
 $^                                          ]          #L          
                                             ]        #^            
                                             ]     ,#^              
                                             ]   ,R.                
                                             ] yR                   
                                             |^                     
KEYWORDs - 
   reaction: :reaction
   molecule: :molecule
   nmr: :nmr
   submitesmiles: :submitesmiles
   submitmissingesmiles
   submitmachines: :submitmachines
   useallentries
   nomodelcorrect
   eigenvalues: :eigenvalues
   frequencies: :frequencies
   nwoutput: :nwoutput
   alleigs: :alleigs
   allfreqs: :allfreqs

   reactionenumerate:
      energytype:[erxn(gas) hrxn(gas) grxn(gas) delta_solvation grxn(aq)] :energytype
      energytype:[kcal/mol kj/mol ev cm-1 ry hartree au] :energytype
      tablereactions:
         reaction: ... :reaction
         reaction: ... :reaction
         ...
      :tablereactions
      tablemethods:
         method: ... :method
         method: ... :method
         ...
      :tablemethods
   :reactionenumerate


   rotatebonds
   xyzinput:
      label:  :label
      xyzdata:
       ... xyz data ...
      :xyzdata
   :xyzinput


   submitHf: :submitHf
   nmrexp: :nmrexp

   findreplace: old text | new text :findreplace

   listnwjobs
   fetchnwjob: :fetchnwjob
   pushnwjob: :pushnwjob

   printcsv: :printcsv
   printeig: :printeig
   printfreq: :printfreq
   printxyz: :printxyz
   printjobinfo: :printjobinfo
   printnwout: :printnwout
   badids: :badids
   hup_string: 
   database:
   table:
   request_table:
   queuecheck                              </pre> <pre style=\"font-size:0.6em;color:black\">

'''

alogowww = '''
</pre>
<a href="http://dl.dropboxusercontent.com/s/ttekdmkebqdfjma/arrows4.png">
   <img src="http://dl.dropboxusercontent.com/s/ttekdmkebqdfjma/arrows4.png" alt="Copyright Arrows Logo" width="500" height="250">
</a>
<pre style=\"font-size:0.6em;color:darkgreen\">
KEYWORDs - 
   reaction: :reaction
   molecule: :molecule
   nmr: :nmr
   submitesmiles: :submitesmiles
   submitmissingesmiles
   submitmachines: :submitmachines
   useallentries
   nomodelcorrect
   eigenvalues: :eigenvalues
   frequencies: :frequencies
   nwoutput: :nwoutput
   alleigs: :alleigs
   allfreqs: :allfreqs

   reactionenumerate:
      energytype:[erxn(gas) hrxn(gas) grxn(gas) delta_solvation grxn(aq)] :energytype
      energytype:[kcal/mol kj/mol ev cm-1 ry hartree au] :energytype
      tablereactions:
         reaction: ... :reaction
         reaction: ... :reaction
         ...
      :tablereactions
      tablemethods:
         method: ... :method
         method: ... :method
         ...
      :tablemethods
   :reactionenumerate


   rotatebonds
   xyzinput:
      label:  :label
      xyzdata:
       ... xyz data ...
      :xyzdata
   :xyzinput


   submitHf: :submitHf
   nmrexp: :nmrexp

   findreplace: old text | new text :findreplace

   listnwjobs
   fetchnwjob: :fetchnwjob
   pushnwjob: :pushnwjob

   printcsv: :printcsv
   printeig: :printeig
   printfreq: :printfreq
   printxyz: :printxyz
   printjobinfo: :printjobinfo
   printnwout: :printnwout
   badids: :badids
   hup_string: 
   database:
   table:
   request_table:
   queuecheck                              </pre> <pre style=\"font-size:0.6em;color:black\">

'''




periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}



covalentstr = '''
H 32 0 0 0
He 46 0 0 0
Li 133 124 0 0
Be 102 90 85 0
B 85 78 73 0
C 75 67 60 68
N 71 60 54 0
O 63 57 53 0
F 64 59 53 0
Ne 67 96 0 0
Na 155 160 0 0
Mg 139 132 127 0
Al 126 113 111 0
Si 116 107 102 0
P 111 102 94 0
S 103 94 95 0
Cl 99 95 93 0
Ar 96 107 96 0
K 196 193 0 0
Ca 171 147 133 0
Sc 148 116 114 0
Ti 136 117 108 0
V 134 112 106 0
Cr 122 111 103 0
Mn 119 105 103 0
Fe 116 109 102 0
Co 111 103 96 0
Ni 110 101 101 0
Cu 112 115 120 0
Zn 118 120 0 0
Ga 124 116 121 0
Ge 121 111 114 0
As 121 114 106 0
Se 116 107 107 0
Br 114 109 110 0
Kr 117 121 108 0
Rb 210 202 0 0
Sr 185 157 139 0
Y 163 130 124 0
Zr 154 127 121 0
Nb 147 125 116 0
Mo 138 121 113 0
Tc 128 120 110 0
Ru 125 114 103 0
Rh 125 110 106 0
Pd 120 117 112 0
Ag 128 139 137 0
Cd 136 144 0 0
In 142 136 146 0
Sn 140 130 132 0
Sb 140 133 127 0
Te 136 128 121 0
I 133 129 125 0
Xe 131 135 122 0
Cs 232 196 0 0
Ba 196 161 149 0
La 180 139 139	 0
Ce 163 137 131 0
Pr 176 138 128 0
Nd 174 137 0 0
Pm 173 135 0 0
Sm 172 134 0 0
Eu 168 134 0 0
Gd 169 135 132 0
Tb 168 135 0 0
Dy 167 133 0 0
Ho 166 133 0 0
Er 165 133 0 0
Tm 164 131 0 0
Yb 170 129 0 0
Lu 162 131 131	 0
Hf 152 128 122	 0
Ta 146 126 119	 0
W 137 120 115	 0
Re 131 119 110	 0
Os 129 116 109	 0
Ir 122 115 107	 0
Pt 123 112 110	 0
Au 124 121 123 0
Hg 133 142 0 0
Tl 144 142 150 0
Pb 144 135 137 0
Bi 151 141 135 0
Po 145 135 129 0
At 147 138 138 0
Rn 142 145 133 0
Fr 223 218 0 0
Ra 201 173 159 0
Ac 186 153 140 0
Th 175 143 136	 0
Pa 169 138 129	 0
U 170 134 118 0
Np 171 136 116 0
Pu 172 135 0  0
Am 166 135 0 0
Cm 166 136 0 0
Bk 168 139 0 0
Cf 168 140 0 0
Es 165 140 0 0
Fm 167 0 0 0
Md 173 139 0 0
No 176 0 0  0
Lr 161 141 0 0
Rf 157 140 131 0
Db 149 136 126 0
Sg 143 128 121 0
Bh 141 128 119 0
Hs 134 125 118 0
Mt 129 125 113 0
Ds 128 116 112 0
Rg 121 116 118	 0
Cn 122 137 130 0
Uut 136 0 0 0
Fl 143 0 0 0
Uup 162  0 0 0
Lv 175 0 0 0
Uus 165 0 0 0
Uuo 157  0 0 0
'''
rcovalent = {}
for ln in covalentstr.strip().split('\n'):
   ss = ln.split()
   rcovalent[ss[0]] = (0.01*eval(ss[1]),0.01*eval(ss[2]),0.01*eval(ss[3]),0.01*eval(ss[4]))


###########################################
#                                         #
#              bond_order                 #
#                                         #
###########################################
def bond_order(rc1,rc2,r12):
   dd = 0.0001
   cov = (abs(r12-(rc1[0]+rc2[0]))/(rc1[0]+rc2[0]+dd),
          abs(r12-(rc1[1]+rc2[1]))/(rc1[1]+rc2[1]+dd),
          abs(r12-(rc1[2]+rc2[2]))/(rc1[2]+rc2[2]+dd),
          abs(r12-(rc1[3]+rc2[3]))/(rc1[3]+rc2[3]+dd))
   imin = 0
   dmin = cov[0]
   if (cov[1]<dmin):
      dmin = cov[1]
      imin = 1
   if (cov[2]<dmin):
      dmin = cov[2]
      imin = 2
   if (cov[3]<dmin):
      dmin = cov[3]
      imin = 3
   b = 0
   if (cov[imin]<0.10): 
      b = 1+imin
      if (imin==3): 
         b = 1.5
   return b

###########################################
#                                         #
#          xyz_bonding_strings            #
#                                         #
###########################################

def xyz_bonding_strings(xyzfilename):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   #### generate bonding ####
   covbondcount = {}
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (bondcount.has_key(key)):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
            covkey = key + "(%.1f)" % (adjmat[i][j])
            if (covbondcount.has_key(covkey)):
               covbondcount[covkey] += 1
            else:
               covbondcount[covkey] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]
   covbonding = ''
   for x  in sorted(covbondcount.items(), key=operator.itemgetter(0)):
      covbonding += x[0] + "=%d," % x[1]
   covbonding = covbonding.strip(',')

   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (bond2count.has_key(key)):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (neighborcount.has_key(key)):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  (mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors,  covbonding)



def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)


def ireplace(old, new, text):
    idx = 0
    while idx < len(text):
        index_l = text.lower().find(old.lower(), idx)
        if index_l == -1:
            return text
        text = text[:index_l] + new + text[index_l + len(old):]
        idx = index_l + len(old)
    return text


def stripWARNINGS(str):
   str1 = ''
   for s in str.split('\n'):
      if 'WARNING' not in s:
         str1 += s + '\n'
   return str1

################################################
#                                              #
#             text2speech                      #
#                                              #
################################################
# calls the mac osx system call say with foo string.
def text2speech(foo):
   os.system('say ' + "\'" + foo + "\'")


#### geturlresult function ####
def geturlresult(url):
    try:
        connection = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        return ""
    else:
        return connection.read().rstrip()

def pexpect_command(pcmd,mypassword):
   if (mypassword=="nopassword"):
      os.system(pcmd)
   else:
      ssh_newkey = 'Are you sure you want to continue connecting'
      # my ssh command line
      p=pexpect.spawn(pcmd,timeout=300)
      i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==0:
          print "I say yes"
          p.sendline('yes')
          i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==1:
          print "sending password",
          p.sendline(mypassword)
          p.expect(pexpect.EOF)
      elif i>=2:
          print "either received key or connection timeout"
          pass
      print p.before # print out the result



#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result


#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    return result

#### pubchem_smiles2cas function ####
def pubchem_smiles2cas(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    cas = ''
    for s in ss:
       if ((len(s.split('-'))==3) and (cas=='')):
          t = s.split('-')
          if (t[0].isdigit() and t[1].isdigit() and t[2].isdigit()):
             cas = s
       if 'CAS-' in s: cas = s.strip('CAS-')
    return cas

#### pubchem_smiles2kegg function ####
def pubchem_smiles2kegg(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    ckegg = ''
    dkegg = ''
    for s in ss:
       if ((s[0]=='C') and (len(s)==6) and s[1:].isdigit()): ckegg = s
       if ((s[0]=='D') and (len(s)==6) and s[1:].isdigit()): dkegg = s
    kegg = ckegg + " " + dkegg

    return kegg.strip()




#### mol2smiles function ####
def mol2smiles(mol):
   eoln = "\n"
   try:
      molfile    = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(molfile,'w')
      ofile.write(mol); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -imol " + molfile + " -ocan " + smilefile2 + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = "nosmiles"
   ### special cases ###
   if ((smiles2=='[HH]') or
       (smiles2=='[H2]') or
       (smiles2=='HH')   or
       (smiles2=='[H].[H]')): smiles2 = '[HH]'
   return smiles2


####################################
#                                  #
#         nametosmiles             #
#                                  #
####################################
def nametosmiles(name):
 try:
   #
   hup    = hup0
   dbfile = "TNT_Project"
   table  = "nametosmiles"
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   sqlinsert = "insert into " + table + " (name,smiles) values (?,?);"
   sqlcheck  = "select * from " + table + " where name=?;"
   if (not issqlite3):
      sqlcheck = sqlcheck.replace('?','%s')
      sqlinsert = sqlinsert.replace('?','%s')

   checklist = []
   checklist.append(name)
   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)==0):
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         if smiles != "":
            ss = smiles.strip().split()
            smiles = ss[0]
            insertlist = []
            insertlist.append(name)
            insertlist.append(smiles)
            print "inserting "+ name + " " + smiles + " into " + table
            cur.execute(sqlinsert,insertlist)
      else:
         smiles = rows[0][2]
   dbcon.close()

 except:
   smiles = ""

 return smiles


####################################
#                                  #
#           esmiles_hasname        #
#                                  #
####################################
def esmiles_hasname(esmiles):
   if (("id=" in esmiles.lower())   or 
       ("kegg=" in esmiles.lower()) or
       ("cas=" in esmiles.lower())  or
       ("cid=" in esmiles.lower())  or
       ("name=" in esmiles.lower()) or
       ("label=" in esmiles.lower())):
      hasname = False
   else:
      try:
         smiles = esmiles.strip().split()[0]
         cmd = obabel + ' -:\"' + smiles + '\" -ocan'
         result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
         #print "result=",result
         if "0 molecules converted" in result:
            hasname = True
         else:
            hasname = False
      except:
         hasname = False

   return hasname

####################################
#                                  #
#    esmileswithname_to_esmiles    #
#                                  #
####################################

def esmileswithname_to_esmiles(esmiles0):
   try:
      if esmiles_hasname(esmiles0):
         sss = esmiles0.split()
         ss = []
         for s in sss:
            if "{" not in s:
               ss.append(s)
         name = ''
         for ll in range(len(ss)-1):
            name += ss[ll] + "%20"
         name += ss[len(ss)-1]

         esmiles1 = nametosmiles(name)

         if esmiles1=='': esmiles1='C'
         for s in sss:
            if "{" in s:
               esmiles1 += " " + s
      else:
         esmiles1 = esmiles0

   except:
      esmiles1 = esmiles0

   return esmiles1





#### parsetosmiles function ####
def parsetosmiles(str):
   global xyzdata
   ss = str.split()
   str2 = ''
   for s in ss:
      if 'kegg=' in s:
         kegg = s.split('=')[1]
         mol = geturlresult("http://rest.kegg.jp/get/%s/mol" % kegg)
         smiles = mol2smiles(mol)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'cid=' in s:
         cid = s.split('=')[1]
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%s/property/CanonicalSMILES/TXT" % cid)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'cas=' in s:
         cas = s.split('=')[1]
         smiles = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/smiles" % cas)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'name=' in s:
         name = s.split('=')[1]
         #smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         smiles = nametosmiles(name)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'label=' in s:
         tag = s.split('=')[1]
         for dd in xyzdata:
            if tag==dd[0]: smiles = dd[1] + ' xyzdata{' + dd[2] + '} '
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      else:
         str2 += ' '
         str2 += s
   str2 = str2.strip()

   return str2


def parse_xyzdata(rstring):
   global xyzdata

   eoln = "\n"
   success = True
   xyzdata = []
   toolongcountmax = 20
   toolongcount = 0
   toolong      = False
   rstring = ireplace("XYZINPUT", "xyzinput", rstring)
   while ((len(rstring.split("xyzinput:"))>1) and (not toolong)):
      msg2 = rstring.split("xyzinput:")
      msg3 = msg2[1].split(":xyzinput")[0]
      rstring  = rstring.replace("xyzinput:"+msg3+":xyzinput","")
      xyzlabel = msg3.split("label:")[1].split(":label")[0].strip()
      xyz0 = msg3.split("xyzdata:")[1].split(":xyzdata")[0].strip()
      xyz = ""
      for x in xyz0.split("\n"):
         xyz += x.strip() + eoln
      xyz = xyz.strip()
      if (xyz.strip().split()[0].isalpha()): 
         nion = len(xyz.strip().split("\n"))
         with open(tmpxyz1,'w') as f:
            f.write("%d\n\n" % nion)
            f.write(xyz+eoln)
      else:
         with open(tmpxyz1,'w') as f: f.write(xyz+eoln)
      smiles = xyz2smiles(tmpxyz1)
      xyzdata.append([xyzlabel,smiles,xyz.replace('\n',' | ')])
      toolong = (toolongcount > toolongcountmax)
      toolongcount += 1
   if (toolong): success = False

   return (rstring,success)





#### cannonicalsmiles function ####
def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      cmd6 = babel + " -ismi " + smilefile + " -ocan " + smilefile2 + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   try:
      smiles = ''
      smilefile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -ocan " + smilefile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(smilefile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles = sdat[0].split()[0]
   except:
      smiles = ''
   return smiles

#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result

##### smiles2xyz function ####
#def smiles2xyz(smiles,xyzfile):
#   eoln = "\n"
#   smilefile = wrkdir + "/"+tmpsmi1
#   ofile = open(smilefile,'w')
#   ofile.write(smiles); ofile.write(eoln)
#   ofile.close()
#   cmd6 = babel + " --ffuff --gen3d -ismi " + smilefile + " -oxyz " + xyzfile + " >& junk.err"
#   os.system(cmd6)
#
#   #### if nan's are produced then use cactus smiles2xyz rest interface ####
#   with open(xyzfile,'r') as ff:
#      test = ff.read()
#   if 'nan' in test:
#      xyzdata = cactus_smiles2xyz(smiles)
#      with open(xyzfile,'w') as ff:
#         ff.write(xyzdata+eoln)

#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "' + smiles.strip() + '" ' +xyzfile
   os.system(cmd6)

   #### if nan's are produced then use cactus smiles2xyz rest interface ####
   with open(xyzfile,'r') as ff:
      test = ff.read()
   if 'nan' in test:
      xyzdata = cactus_smiles2xyz(smiles)
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+eoln)



#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+ tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchi " + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchikey " + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchi " + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchikey " + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi



def smiles2charge(smiles):
  charge = 0
  ss = smiles.split('[')
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge

def smiles2mult(smiles,q):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpxyz1)
  pcharge = q
  count = 0
  xyzfile = open(wrkdir + "/"+tmpxyz1,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult

def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult









#### functions ####
def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().strip()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula



###########################################
#                                         #
#            ascii_plotter                #
#                                         #
###########################################
maxrow_ascii = 30
maxcol_ascii = 75
shift1_ascii = 2
shift2_ascii = 11
#maxcol_ascii = 86
xmin_ascii = 0.0
ymin_ascii = 0.0
xmax_ascii = 1.0
ymax_ascii = 1.0
def ascii_xscale(x):
   return int(round((x-xmin_ascii)*(maxcol_ascii-1)/(xmax_ascii-xmin_ascii)))

def ascii_yscale(y):
   return int(round((y-ymax_ascii)*(maxrow_ascii-1)/(ymin_ascii-ymax_ascii)))

def ascii_plotter(x,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,plotzero):
   global xmin_ascii
   global ymin_ascii
   global xmax_ascii
   global ymax_ascii

   xmin_ascii = xmin
   ymin_ascii = ymin
   xmax_ascii = xmax
   ymax_ascii = ymax
   shift_ascii = shift1_ascii+shift2_ascii
   point = []
   for k in range(maxrow_ascii):
      row = [' ']*(maxcol_ascii+shift_ascii)
      point.append(row)

   ### set y-axis ###
   for j in range(maxrow_ascii):
      point[j][shift1_ascii+10] = ":"

   if ((ascii_xscale(0.0)<(maxcol_ascii-1)) and (ascii_xscale(0.0)>0)):
      for j in range(maxrow_ascii):
         point[j][shift_ascii-1+ascii_xscale(0.00)] = "." 

   ### set x-axis ###
   for i in range(shift_ascii,maxcol_ascii+shift_ascii):
      point[ascii_yscale(0.0)][i] = "."


   ### set ylabels ###
   nstru = "%10.3e" % ymax
   nstrd = "%10.3e" % ymin
   for i in range(10):
      point[0][shift1_ascii+i] = nstru[i]
      point[maxrow_ascii-1][shift1_ascii+i] = nstrd[i]
   if ((ascii_yscale(0.0)<(maxrow_ascii-1)) and (ascii_yscale(0.0)>0)):
      point[ascii_yscale(0.00)][shift1_ascii+0]  = " "
      point[ascii_yscale(0.00)][shift1_ascii+1]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+2]  = "."
      point[ascii_yscale(0.00)][shift1_ascii+3]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+4]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+5]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+6]  = "e"
      point[ascii_yscale(0.00)][shift1_ascii+7]  = "+"
      point[ascii_yscale(0.00)][shift1_ascii+8]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+9] = "0"

   ### set ylabel ###
   jj = (maxrow_ascii-len(ylabel))/2
   for j in range(len(ylabel)):
       point[jj+j][0] = ylabel[j]

   ### plot points ###
   n = len(x)
   if (plotzero):
      for j in range(len(y)):
         s = symbols[j]
         for i in range(n):
            u = ascii_xscale(x[i])
            v = ascii_yscale(y[j][i])
            point[v][shift_ascii+u] = s
   else:
      yzero = ascii_yscale(0.0)
      for j in range(len(y)):
         s  = symbols[j]
         u  = ascii_xscale(x[0])
         v  = ascii_yscale(y[j][0])
         va = ascii_yscale(y[j][1])
         if ((v!=yzero) and (va!=yzero)): point[v][shift_ascii+u] = s
         for i in range(1,n-1):
            u  = ascii_xscale(x[i])
            vb = ascii_yscale(y[j][i-1])
            v  = ascii_yscale(y[j][i])
            va = ascii_yscale(y[j][i+1])
            if ((v!=yzero) and (vb!=yzero) and (va!=yzero)):
               point[v][shift_ascii+u] = s
         u  = ascii_xscale(x[n-1])
         vb = ascii_yscale(y[j][n-2])
         v  = ascii_yscale(y[j][n-1])
         if ((v!=yzero) and (vb!=yzero)): point[v][shift_ascii+u] = s
         


   msg = "\n"
   for i in range(shift_ascii+(maxcol_ascii-len(title))/2): msg += " " 
   msg += title+ "\n\n"
   for row in point:
      for col in row:
         msg += col
      msg += "\n"


   ### set xlabels ###
   for i in range(shift_ascii-1): msg += " "
   msg += "|"
   for i in range(shift_ascii+1,shift_ascii+(maxcol_ascii)/2): msg += "-"
   msg += "|"
   for i in range(shift_ascii+(maxcol_ascii)/2+1,(maxcol_ascii+shift_ascii)): msg += "-"
   msg += "|\n"
   msg += "      %10.3e                           %10.3e                            %10.3e\n" % (xmin_ascii,0.5*(xmin_ascii+xmax_ascii),xmax_ascii)
   msg += "\n"
   for i in range(shift_ascii+(maxcol_ascii-len(xlabel))/2): msg += " "
   msg += xlabel +"\n"
      #write(lunit,900) ,XL,(XL+XR)/2.0d0,XR
      #write(lunit,MyformatX) Xlabel
  #900 format(5x,E10.3,27x,E10.3,27x,E10.3)


   return msg






#############################################
#                                           #
#             clean_smiles                  #
#                                           #
#############################################

def clean_smiles(smiles):
   smiles2 = smiles[:]
   tags = ['^','mult','theory','xc','solvation_type','basis','theory_base','xc_base','basis_base','geometry_generation']
   for tt in tags:
      if tt in smiles2:
         tag1 = tt+"{"
         tag2 = "}"
         msg2 = smiles2.split(tag1)
         msg3 = msg2[1].split(tag2)[0]
         smiles2 = smiles2.replace(tag1+msg3+tag2,"")
   return smiles2

#############################################
#                                           #
#             addspaces_reaction            #
#                                           #
#############################################
def addspaces_reaction(reaction):
   tags = ['^','mult','theory','xc','solvation_type','basis','calculation_type','property','priority','geometry_generation']
   reaction2 = reaction[:]
   if (reaction2.find(">")!=-1):
      reaction2 = reaction2.replace(">","")
   if (reaction2.find("-->")==-1):
      reaction2 = reaction2.replace("--","-->")
   for tag1 in tags: reaction2 = reaction2.replace(tag1," " + tag1)
   return reaction2


#############################################
#                                           #
#             fetch_esmiles_full            #
#                                           #
#############################################
def fetch_esmiles_full(hup,dbfile,table,esmiles):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   esmiles1=esmiles.strip()
   ss = esmiles1.split()

   smiles  = clean_smiles(ss[0])
   csmiles = cannonicalsmiles(smiles)

   inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
   inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

   xyzfile = wrkdir + "/" + tmpxyz1
   smiles2xyz(smiles,xyzfile)
   inchi2    = xyz2InChI(xyzfile)     #inchi does not include charge
   inchikey2 = xyz2InChIKey(xyzfile)  #inchikey does not include charge

   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"

   if 'theory{' in esmiles: 
      theory = esmiles.split('theory{')[1].split('}')[0]
      checklist.append(theory)
      wherestr += " and theory=?"

   if 'xc{' in esmiles:
      xc  = esmiles.split('xc{')[1].split('}')[0]
      checklist.append(xc)
      wherestr += " and xc=?"

   if 'basis{' in esmiles:
      basis  = esmiles.split('basis{')[1].split('}')[0]
      if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
      if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
      checklist.append(basis)
      wherestr += " and basis=?"

   if '^{' in esmiles:
      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      checklist.append(charge)
      wherestr += " and charge=?"

   if 'mult{' in esmiles:
      mult = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      checklist.append(mult)
      wherestr += " and mult=?"

   if 'solvation_type' in esmiles:
      solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      checklist.append(solvation_type)
      wherestr += " and solvation_type=?"

   if 'calculation_type' in esmiles:
      calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
      checklist.append(calculation_type)
      wherestr += " and calculation_type=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   return rows
 except:
   return []


def quote_comma_name(name):
   if ',' in name:
      cc = "\"" + name + "\""
   else:
      cc = name
   return cc

def fetch_csv_esmiles_full(hup,dbfile,table,columns_list,esmiles_list):
   eoln = "\n"
   csv_msg = "csv data block:" + eoln + eoln
   for c in columns_list:
      csv_msg += quote_comma_name(c) + ","
   csv_msg = csv_msg.rstrip(",")
   csv_msg += eoln

   for esmiles in esmiles_list:
      rows = fetch_esmiles_full(hup,dbfile,table,esmiles)
      for molecule in rows:
         msg = ""
         for column in columns_list:
            if (column.lower()=='id'):                msg += "%d," % molecule[0]
            if (column.lower()=='iupac'):             msg += "%s," % quote_comma_name(molecule[1])
            if (column.lower()=='mformula'):          msg += "%s," % molecule[2]
            if (column.lower()=='inchi'):             msg += "%s," % quote_comma_name(molecule[3])
            if (column.lower()=='smiles'):            msg += "%s," % molecule[4]
            if (column.lower()=='csmiles'):           msg += "%s," % molecule[5]
            if (column.lower()=='esmiles'):           msg += "%s," % quote_comma_name(molecule[6])
            if (column.lower()=='program'):           msg += "%s," % molecule[7]
            if (column.lower()=='calculation_type'):  msg += "%s," % molecule[8]
            if (column.lower()=='theory'):            msg += "%s," % molecule[9]
            if (column.lower()=='xc'):                msg += "%s," % molecule[10]
            if (column.lower()=='basis'):             msg += "%s," % quote_comma_name(molecule[11])
            if (column.lower()=='charge'):            msg += "%d," % molecule[12]
            if (column.lower()=='mult'):              msg += "%d," % molecule[13]
            if (column.lower()=='energy'):            msg += "%.6f," % molecule[14]
            if (column.lower()=='enthalpy'):          msg += "%.6f," % molecule[15]
            if (column.lower()=='entropy'):           msg += "%.3f," % molecule[16]
            if (column.lower()=='solvation_type'):    msg += "%s,"   % molecule[17]
            if (column.lower()=='solvation_energy'):  msg += "%.3f," % molecule[18]
            if (column.lower()=='sitkoff'):           msg += "%.3f," % molecule[19]
            if (column.lower()=='honig'):             msg += "%.3f," % molecule[20]
            if (column.lower()=='asa'):               msg += "%.3f," % molecule[21]
            if (column.lower()=='sav'):               msg += "%.3f," % molecule[22]
            if (column.lower()=='xyz_blob'):          msg += "%s,"   % molecule[23]
            if (column.lower()=='frequencies_blob'):  msg += "%s,"   % molecule[24]
            if (column.lower()=='eigenvalues_blob'):  msg += "%s,"   % molecule[25]
            if (column.lower()=='radial_distribution_blob'): msg += "%s," % molecule[26]
            if (column.lower()=='power_spectrum_blob'):      msg += "%s," % molecule[27]
            if (column.lower()=='filename'):                 msg += "%s," % quote_comma_name(molecule[28])
         msg = msg.rstrip(",")
         csv_msg += msg + eoln

   csv_msg += eoln + ":csv data block" + eoln

   return csv_msg


#############################################
#                                           #
#             fetch_jobinfo                 #
#                                           #
#############################################
def fetch_jobinfo(hup,dbfile,table,id):
 try:
   eoln = "\n"
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False


   checklist = []
   checklist.append(id)

   wherestr =  " where Id=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()


   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg  = "jobinfo: Id=%d, iupac=%s, filename=%s\n\n" % (id,molecule[1],molecule[28])
      cmd1 = "scp " + molecule[28] + " " + wrkdir +"/nwout.txt"
      print "cmd1=",cmd1
      pexpect_command(cmd1,archivepassword)
      offile = open(wrkdir+"/nwout.txt","r")
      ttt = offile.read()
      offile.close()
      uuu = ttt.split("Job information")[1].split("Memory information")[0]
      uuu = uuu.rstrip()
      msg += "           Job information" + eoln
      msg += uuu + eoln
      msg += "    program version = %s\n\n" % molecule[7]
      msg += ":jobinfo Id=%d, iupac=%s, filename=%s\n" % (id,molecule[1],molecule[28])

   else:
      msg = "jobinfo:\n no nwout file for Id=%d\n:jobinfo\n" % id

   return msg

 except:
   return "fetch_jobinfo failed\n"





#############################################
#                                           #
#             fetch_nwout                   #
#                                           #
#############################################
def fetch_nwout(hup,dbfile,table,id):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)

   wherestr =  " where Id=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg = "nwout file for Id=%d\n\n" % id
      msg += molecule[28]
      msg += "\n\n"
      cmd1 = "scp " + molecule[28] + " " + wrkdir +"/nwout.txt"
      print "cmd1=",cmd1
      pexpect_command(cmd1,archivepassword)
      cmd2 = "cat " + wrkdir +"/nwout.txt"
      print "cmd2=",cmd2
      result = subprocess.check_output(cmd2,shell=True)
      msg += result
   else:
      msg = "no nwout file for Id=%d\n\n" % id

   return msg

 except:
   return "fetch_nwout failed\n"




#############################################
#                                           #
#             fetch_xyz                     #
#                                           #
#############################################

def fetch_xyz(hup,dbfile,table,id):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)
   wherestr =  " where Id=?"
   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg = "xyz data for Id=%d\n\n" % id
      msg += molecule[23]
   else:
      msg = "no xyz data for Id=%d\n\n" % id

   return msg



#######################################  fetch_freq functions ##################################


#############################################
#                                           #
#           fetch_frequency_data            #
#                                           #
#############################################
def fetch_all_frequency_data(hup,dbfile,table,id):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   wherestr =  " where id=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')
   checklist = []
   checklist.append(id)

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      row = cur.fetchone()
   dbcon.close()

   return row

 except:
   return ("","","","","","","","","")


#############################################
#                                           #
#             get_frequency_geometry        #
#                                           #
#############################################

# returns the geometry

def get_frequency_geometry(frequency_data):

   all_lines1 = frequency_data[23].split("\n")
   ### get the geometry ###
   nion = eval(all_lines1[0])
   name = []
   rxyz = []
   for ii in range(nion):
      ss = all_lines1[2+ii].split()
      name.append(ss[0])
      rxyz.append(eval(ss[1]))
      rxyz.append(eval(ss[2]))
      rxyz.append(eval(ss[3]))

   return (nion,name,rxyz)


#############################################
#                                           #
#             get_frequency                 #
#                                           #
#############################################

# returns the freqency and eigvector for a given frequency number, fnum.

def get_frequency(frequency_data,fnum):

   all_lines2 = frequency_data[24].split("\n")
   pcount_num = (fnum-1)/6
   shift      = (fnum-1)%6
   freqs = []
   freqdat = []
   count  = 0
   pcount = -1
   done = False
   for line in all_lines2:
     if (not done):
        if (pcount==pcount_num):
           count += 1
           if (count>1):
              if (len(line)<=5):
                 done = True
              else:
                 freqdat.append(line)
        if (not done):
           if (line.find("P.Frequency") != -1):
              count = 0
              pcount += 1
              if (pcount==pcount_num):
                 freqs.append(line)

   splt = freqs[0].split()
   w = eval(splt[shift+1])

   freq = []
   n = len(freqdat)
   for i in range(n):
      split = freqdat[i].split()
      #print split[0],"  ",split[shift+1]
      freq.append(eval(split[shift+1]))

   return (w,freq)

def simpson(h,f):
   n = len(f)
   ss = f[0] + f[n-1]
   for i in range(1,n-1,2): ss += (4.0*f[i])
   for i in range(2,n-2,2): ss += (2.0*f[i])
   return ss*h/3.0

#############################################
#                                           #
#           dos_frequencies                 #
#                                           #
#############################################

def dos_frequencies(plotdos,frequency_data):
   eoln = '\n'
   ngrid   = 501
   maxfreq = 4500.0
   minfreq = 0.1
   threshfreq = 500.0
   sigmas  = [10.0,50.0,100.0]
   pi      = 4.0*atan(1.0)

   all_lines2 = frequency_data[24].split("\n")
   freqs = []
   for line in all_lines2:
      if (line.find("P.Frequency") != -1):
         freqs += [ eval(s) for s in line.split()[1:]]

   nfreqs  = 0
   nlowest = 0
   for f in freqs:
      if (f<(-0.01)): nfreqs += 1
      if ((f>minfreq) and (f<threshfreq)): nlowest += 1

   exact_dos_norm = len(freqs)-6.0
   msg0 =  "Total number of frequencies = %d" % len(freqs) + eoln
   msg0 += "Total number of negative frequencies = %d" % nfreqs + eoln
   for i in range(nfreqs):
      msg0 += "  - w_negative = %.1f cm-1" % freqs[i] + eoln
   msg0 += "Number of lowest frequencies = %d" % nlowest 
   msg0 +=  " (frequency threshold = %d " % threshfreq + ")" + eoln
   msg0 += "Exact dos norm = %.3f" % exact_dos_norm + eoln + eoln
   
   dw  = ((maxfreq-minfreq)/float(ngrid-1))
   ww  = []

   msg0 += "Generating vibrational DOS" + eoln
   doss  = []
   doss_lowest   = []
   for sigma in sigmas:
      scale  = 1.0/(sigma*sqrt(2.0*pi))
      omega2 = 1.0/(2.0*sigma*sigma)
      dos = []
      dos_lowest = []
      for i in range(ngrid):
         w = minfreq + i*dw
         ww.append(w)
         pp = 0.0
         pplow = 0.0
         low = 0
         for f in freqs:
            if (f>minfreq):
               x2 = (w-f)**2
               tt = scale*exp(-omega2*x2)
               pp += tt
               if (low<nlowest):
                  pplow += tt
                  low += 1
         dos.append(pp)
         dos_lowest.append(pplow)
      doss.append(dos)
      doss_lowest.append(dos_lowest)


   msg0 +=  "Generating model vibrational DOS to have a proper norm" + eoln
   doss_fixed =[]
   for k in range(len(doss)):
      dos = doss[k]
      dos_lowest = doss_lowest[k]
      dos_fixed = []
      dos_norm = simpson(dw,dos)
      dos_lowest_norm = simpson(dw,dos_lowest)
      if (dos_lowest_norm > 1.0e-8):
         fac = (exact_dos_norm-dos_norm)/dos_lowest_norm
      else:
         fac = 0.0
      for i in range(ngrid):
         pp = dos[i] + fac*dos_lowest[i]
         dos_fixed.append(pp)

      dos_fixed_norm = simpson(dw,dos_fixed)
      doss_fixed.append(dos_fixed)
      msg0 += "%.2f %.2f %.2f %.2f\n\n\n" % (sigmas[k],dos_norm,dos_lowest_norm,dos_fixed_norm)

   ## set up temporary gnuplot files
   dumbfilename       = wrkdir + "/dosplot-%d.dumb"    % ddrand
   gnufilename        = wrkdir + "/dosplot-%d.gnuplot" % ddrand
   vdosfilename       = wrkdir + "/vdos-%d.dat"        % ddrand
   vdos_modelfilename = wrkdir + "/vdos_model-%d.dat"  % ddrand
   freqfilename       = wrkdir + "/freq_data-%d.dat"   % ddrand


   if plotdos:
      msg0 += "Writing vibrational density of states (DOS) to vdos.dat" + eoln
      ofile = open("vdos.dat",'w')
      for i in range(ngrid):
         ofile.write("%f" % ww[i])
         for k in range(len(doss)):
            ofile.write(" %f" % doss[k][i])
         ofile.write("\n")
      ofile.close()
      msg0 += "Writing model vibrational density of states (DOS_FIXED) to vdos-model.dat" + eoln + eoln
      ofile = open("vdos-model.dat",'w')
      for i in range(ngrid):
         ofile.write("%f" % ww[i])
         for k in range(len(doss_fixed)):
            ofile.write(" %f" % doss_fixed[k][i])
         ofile.write("\n")
      ofile.close()

   # write tempory data files for gnuplot
   ofile = open(vdosfilename,'w')
   for i in range(ngrid):
      ofile.write("%f" % ww[i])
      for k in range(len(doss)):
         ofile.write(" %f" % doss[k][i])
      ofile.write("\n")
   ofile.close()
   ofile = open(vdos_modelfilename,'w')
   for i in range(ngrid):
      ofile.write("%f" % ww[i])
      for k in range(len(doss_fixed)):
         ofile.write(" %f" % doss_fixed[k][i])
      ofile.write("\n")
   ofile.close()


   ### get database energies ###
   energy           = frequency_data[14]
   enthalpy         = frequency_data[15]
   entropy          = frequency_data[16]
   solvation_type   = frequency_data[17]
   solvation_energy = frequency_data[18]
   sitkoff          = frequency_data[19]
   if solvation_type=='COSMO': solvation_energy = -solvation_energy + sitkoff

   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL

   msg0 += "Temperature=%7.2f " % (temp) + eoln + eoln
   ethermal0 = 0.0
   Svib0     = 0.0
   for w in freqs:
      if (w>0.1):
         thetav = w*(h*c/kgas)
         if (temp>0.0):
            xdum   = exp(-thetav/temp)
         else:
            xdum = 0.0
         xdum   = xdum/(1.00-xdum)
         ethermal0 +=  (thetav*(0.50 + xdum)*Rgas)
         xdum   = thetav/temp
         if (xdum>0.0):
            Svib0 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)

   #ethermal0 += Rgas*temp*2.5 #translaton+(pv=RT) - atom
   #ethermal0 += Rgas*temp*3.5 #translaton+rotation+(pv=RT) - linear
   #ethermal0 += Rgas*temp*4.0 #translaton+rotation+(pv=RT) - not linear
   msg0 += "vibrational contribution to enthalpy correction = %8.3f kcal/mol (%10.6f)"%(ethermal0*AUKCAL,ethermal0) + eoln
   msg0 += "vibrational contribution to Entropy             = %8.3f cal/mol-k"%(Svib0*AUKCAL*1000.0) + eoln + eoln

   jmagelist = []
   pmsg1 = ''
   hmsg1 = ''
   msg2 = ''
   for k in range(len(doss)):

      ## thermo for original DOS ##
      dos      = doss[k]
      ethermal = 0.0
      Svib     = 0.0
      for i in range(ngrid):
         w = ww[i]
         thetav = w*(h*c/kgas)
         xdum   = exp(-thetav/temp)
         xdum   = xdum/(1.00-xdum)
         ethermal +=  (thetav*(0.50 + xdum)*Rgas)*dos[i]*dw
         xdum   = thetav/temp
         if (xdum>0.0):
            Svib += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos[i]*dw

      ## thermo for model DOS ##
      dos_fixed = doss_fixed[k]
      ethermal_fixed = 0.0
      Svib_fixed     = 0.0
      for i in range(ngrid):
         w = ww[i]
         thetav = w*(h*c/kgas)
         xdum   = exp(-thetav/temp)
         xdum   = xdum/(1.00-xdum)
         ethermal_fixed +=  (thetav*(0.50 + xdum)*Rgas)*dos_fixed[i]*dw
         xdum   = thetav/temp
         if (xdum>0.0):
            Svib_fixed += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos_fixed[i]*dw

      ## plot DOS and model DOS ##
      if (k==1):

         #### ASCII PLOT ####
         dosplot = 'set output \"%s\"; set term dumb; set grid; set title \"Original and Model Vibrational Density of States (sigma=%.1f cm-1)\"; set ylabel \"VDOS\"; set xlabel \"w (cm-1)\";  plot \"%s\" using 1:%d with l title \"Original VDOS\",\"%s\" using 1:%d with l title \"Model VDOS\" ' % (dumbfilename,sigmas[k],vdosfilename,k+2,vdos_modelfilename,k+2)
         with open(gnufilename,'w') as f: 
            f.write(dosplot)
         try:
            os.system(gnuplot + gnufilename)
         except:
            print "failed system cmd=",gnuplot+gnufilename
         with open(dumbfilename,'r') as f:
            msg = f.read()
            pmsg1 += msg + eoln

         #### PNG PLOT ####
         ddrand2     = random.randint(0,999999)
         pngfilename = wrkdir + "/dosplot-%d-%d.png" % (ddrand,ddrand2)
         pngname     = "dosplot-image-%d-%d"         % (ddrand,ddrand2)
         dosplot     = 'set output \"%s\"; set term png; set grid; set title \"Original and Model Vibrational Density of States (sigma=%.1f cm-1)\"; set ylabel \"VDOS\"; set xlabel \"w (cm-1)\";  plot \"%s\" using 1:%d with l title \"Original VDOS\",\"%s\" using 1:%d with l title \"Model VDOS\", \"%s\" using 1:2 with impulses title \"states\" ' % (pngfilename,sigmas[k],vdosfilename,k+2,vdos_modelfilename,k+2,freqfilename)
         jmagelist += [(pngfilename,pngname)]
         hmsg1 +='</pre><br><center><img src="cid:%s" align="middle"></center><br>\n' % pngname
         hmsg1 +="<pre style=\"font-size:0.6em;color:black\">\n"
         scale0 = 1.0/(sigmas[k]*sqrt(2.0*pi))
         with open(freqfilename,"w") as ff:
            for f0 in freqs:
               ff.write("%e %e\n" % (f0,scale0))
         with open(gnufilename,'w') as f: f.write(dosplot)
         try:
            os.system(gnuplot + gnufilename)
         except:
            print "failed system cmd=",gnuplot+gnufilename

      
      gas_enthalpy0      = energy + enthalpy
      gas_enthalpy       = energy + enthalpy - ethermal0 + ethermal
      gas_enthalpy_fixed = energy + enthalpy - ethermal0 + ethermal_fixed

      gas_entropy0       = entropy/(AUKCAL*1000.0)
      gas_entropy        = entropy/(AUKCAL*1000.0)  + (Svib - Svib0)
      gas_entropy_fixed  = entropy/(AUKCAL*1000.0)  + (Svib_fixed - Svib0)

      gas_free_energy0      = gas_enthalpy0      - temp*gas_entropy0
      gas_free_energy       = gas_enthalpy       - temp*gas_entropy
      gas_free_energy_fixed = gas_enthalpy_fixed - temp*gas_entropy_fixed

      sol_free_energy0      = gas_free_energy0      + solvation_energy/AUKCAL
      sol_free_energy       = gas_free_energy       + solvation_energy/AUKCAL
      sol_free_energy_fixed = gas_free_energy_fixed + solvation_energy/AUKCAL

      msg2 += "DOS sigma = %f" % sigmas[k]
      msg2 += "  -       vibrational DOS enthalpy correction = %10.6f kcal/mol (%8.3f kcal/mol)\n" %  (ethermal,ethermal*AUKCAL)
      msg2 += "  - model vibrational DOS enthalpy correction = %10.6f kcal/mol (%8.3f kcal/mol)\n" %  (ethermal_fixed,ethermal_fixed*AUKCAL)
      msg2 += "  -       vibrational DOS Entropy             = %10.6f (%8.3f cal/mol-k)\n"  %  (Svib,Svib*AUKCAL*1000.0)
      msg2 += "  - model vibrational DOS Entropy             = %10.6f (%8.3f cal/mol-k)\n\n"  %  (Svib_fixed,Svib_fixed*AUKCAL*1000.0)
      msg2 += "  - orginal       gas Energy       = %12.6f (%8.3f kcal/mol)\n\n"  % (energy,                  energy*AUKCAL)
      msg2 += "  - orginal       gas Enthalpy     = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n"  % (gas_enthalpy0,     gas_enthalpy0*AUKCAL,(gas_enthalpy0-gas_enthalpy0)*AUKCAL)
      msg2 += "  - unajusted DOS gas Enthalpy     = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n"  % (gas_enthalpy,      gas_enthalpy*AUKCAL,(gas_enthalpy-gas_enthalpy0)*AUKCAL)
      msg2 += "  - model     DOS gas Enthalpy     = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n\n"  % (gas_enthalpy_fixed,gas_enthalpy_fixed*AUKCAL,(gas_enthalpy_fixed-gas_enthalpy0)*AUKCAL)
      msg2 += "  - orginal       gas Entropy      = %12.6f (%8.3f cal/mol-k,delta=%8.3f)\n" % (gas_entropy0,     gas_entropy0*AUKCAL*1000.0,(gas_entropy0-gas_entropy0)*AUKCAL*1000.0)
      msg2 += "  - unajusted DOS gas Entropy      = %12.6f (%8.3f cal/mol-k,delta=%8.3f)\n" % (gas_entropy,      gas_entropy*AUKCAL*1000.0,(gas_entropy-gas_entropy0)*AUKCAL*1000.0)
      msg2 += "  - model     DOS gas Entropy      = %12.6f (%8.3f cal/mol-k,delta=%8.3f)\n\n" % (gas_entropy_fixed,gas_entropy_fixed*AUKCAL*1000.0,(gas_entropy_fixed-gas_entropy0)*AUKCAL*1000.0)
      msg2 += "  - orginal        gas Free Energy = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n"  % (gas_free_energy0,     gas_free_energy0*AUKCAL,(gas_free_energy0-gas_free_energy0)*AUKCAL)
      msg2 += "  - unadjusted DOS gas Free Energy = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n"  % (gas_free_energy,      gas_free_energy*AUKCAL,(gas_free_energy-gas_free_energy0)*AUKCAL)
      msg2 += "  - model      DOS gas Free Energy = %12.6f (%8.3f kcal/mol, delta=%8.3f)\n\n"  % (gas_free_energy_fixed,gas_free_energy_fixed*AUKCAL,(gas_free_energy_fixed-gas_free_energy0)*AUKCAL)
      msg2 += "  - orginal        sol Free Energy = %12.6f (%8.3f kcal/mol)\n"  % (sol_free_energy0,     sol_free_energy0*AUKCAL)
      msg2 += "  - unadjusted DOS sol Free Energy = %12.6f (%8.3f kcal/mol)\n"  % (sol_free_energy,      sol_free_energy*AUKCAL)
      msg2 += "  - model      DOS sol Free Energy = %12.6f (%8.3f kcal/mol)\n\n"  % (sol_free_energy_fixed,sol_free_energy_fixed*AUKCAL)

   try:
      os.unlink(dumbfilename)
      os.unlink(gnufilename)
      os.unlink(vdosfilename)
      os.unlink(vdos_modelfilename)
      os.unlink(freqfilename)
   except:
      print "chemdb_freq: Failed to delete temporary gnuplot files"

   pmsg = msg0 + pmsg1 + msg2
   hmsg = msg0 + hmsg1 + msg2
   return (pmsg,hmsg,jmagelist)

# Thermal correction to Enthalpy   =  217.652 kcal/mol  (  0.346851 au)
#- Vibrational                  =  107.470 cal/mol-K


#############################################
#                                           #
#             plot_frequency                #
#                                           #
#############################################

def plot_frequency(frequency_data,fnum):
 try:
   
   ### get the geometry ###
   (nion,name,rxyz) =  get_frequency_geometry(frequency_data)

   ### get the frequency ###
   (w,freq) = get_frequency(frequency_data,fnum)

   xyzfile = wrkdir + "/" + "tmpxyz1-%d.xyz" % ddrand
   print "\n\nTrajectory for freq id=",id," fnum=",fnum,"  w(cm-1)=",w," - Generating xyzfile = ",xyzfile
   xfile = open(xyzfile,'w')
   for k in range(-20,21):
      xfile.write("%d\n\n" % nion)
      for i in range(nion):
         x = rxyz[3*i]   + 0.11*k*freq[3*i]
         y = rxyz[3*i+1] + 0.11*k*freq[3*i+1]
         z = rxyz[3*i+2] + 0.11*k*freq[3*i+2]
         xfile.write("%s   %f %f %f\n" % (name[i],x,y,z))
   xfile.close()

   #cmd6 = "/Applications/\"VMD 1.8.6.app\"/Contents/Resources/VMD.app/Contents/MacOS/VMD " + xyzfile
   cmd6 = "/Applications/iMol.app/Contents/MacOS/iMol " + xyzfile
   #cmd6 = "/home/bylaska/bin/vmd " + xyzfile
   os.system(cmd6)

   ### remove temporary xyzfile ###
   try:
      os.unlink(xyzfile)
   except:
      print "chemdb_freq: Failed to remove " + xyzfile


 except:
   print "frequency %d in id=%d not found" % (fnum,id)

#############################################
#                                           #
#             analyze_frequency             #
#                                           #
#############################################
def analyze_frequency(fnum,w):
   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL

   msg = "Temperature=%7.2f  freq(%d)= %8.3f cm-1\n" % (temp,fnum,w)

   if (w>1.0e-8):
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal =  thetav*(0.50 + xdum)*Rgas
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib   =  (xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas
      else:
         Svib = 0.0
      msg += "  - contribution to thermal correction to enthalpy= %8.3f kcal/mol (%10.6f)\n" %  (ethermal*AUKCAL,ethermal)
      msg += "  - contribution to Entropy                       = %8.3f cal/mol-k\n"       %  (Svib*AUKCAL*1000.0)

   return msg



#############################################
#                                           #
#             fetch_freq                    #
#                                           #
#############################################
def fetch_freq(hup,dbfile,table,id):

   imgagelist = []
   pmsg = ''
   hmsg = ''

   eoln = "\n"
   msg0 =  "+----------------------------------------+" + eoln
   msg0 += "| Vibrational Density of States Analysis |" + eoln
   msg0 += "+----------------------------------------+" + eoln + eoln

   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   msg0 += "table name      =" + table
   msg0 += "arrows id       = %d " % id + eoln

   freqdata = fetch_all_frequency_data(hup,dbfile,table,id)

   iupac    = freqdata[1]
   mformula = freqdata[2]
   inchi    = freqdata[3]
   inchikey = freqdata[29]
   esmiles  = freqdata[6]
   asciiart = freqdata[34]
   calculation_type = freqdata[8]
   theory           = freqdata[9]
   xc               = freqdata[10]
   basis            = freqdata[11]
   charge           = freqdata[12]
   mult             = freqdata[13]
   energy           = freqdata[14]
   enthalpy         = freqdata[15]
   entropy          = freqdata[16]
   solvation_type   = freqdata[17]
   solvation_energy = freqdata[18]
   sitkoff          = freqdata[19]
   honig            = freqdata[20]
   area             = freqdata[21]
   volume           = freqdata[22]
   if solvation_type=='COSMO': solvation_energy = -solvation_energy + sitkoff
   msg0 += "iupac    = " + iupac + eoln
   msg0 += "mformula = " + mformula + eoln
   msg0 += "inchi    = " + inchi + eoln
   msg0 += "inchikey = " + inchikey + eoln
   msg0 += "esmiles  = " + esmiles + eoln

   msg0 += "calculation_type = " + calculation_type + eoln
   msg0 += "theory           = " + theory + eoln
   msg0 += "xc               = " + xc + eoln
   msg0 += "basis            = " + basis + eoln
   msg0 += "charge,mult      = %d %d" % (charge,mult) + eoln
   msg0 += "energy           = %14.6f Hartrees"  % energy + eoln
   msg0 += "enthalpy correct.= %14.6f Hartrees"  % enthalpy + eoln
   msg0 += "entropy          = %14.3f cal/mol-K" % entropy + eoln
   msg0 += "solvation energy = %14.3f kcal/mol  solvation_type = %s" % (solvation_energy,solvation_type) + eoln
   msg0 += "Sitkoff cavity dispersion          = %14.3f kcal/mol" % sitkoff + eoln
   msg0 += "Honig cavity dispersion            = %14.3f kcal/mol" %  honig + eoln
   msg0 += "ASA solvent accesible surface area = %14.3f Angstrom2" % area + eoln
   msg0 += "ASA solvent accesible volume       = %14.3f Angstrom3" % volume + eoln

   msg1  = "chemical_structure_asciiart  = " +eoln
   msg1 += asciiart +eoln

   (pmsg2,hmsg2,jmagelist) = dos_frequencies(True,freqdata)

   msg4 = ''
   #msg4 =  "+---------------------------+"
   #msg4 += "| Analyzing Low Frequencies |"
   #msg4 += "+---------------------------+\n"
   #for f in range(len(freqdata)):
   #   (w,freq) = get_frequency(freqdata,f)
   #   if (w<250.0):
   #      msg4 += analyze_frequency(f,w)

   pmsg = msg0 + msg1 + pmsg2 + msg4
   hmsg = msg0        + hmsg2 + msg4

   return (pmsg,hmsg,jmagelist)



#############################################
#                                           #
#           model_energies_frequencies      #
#                                           #
#############################################

def model_correct_frequencies(frequency_data,sigma=50.0,threshfreq=500.0,minfreq=0.1,maxfreq=4500.0):
   #maxfreq = 4500.0
   #minfreq = 0.1
   #threshfreq = 500.0
   ngrid   = 501
   pi      = 4.0*atan(1.0)

   all_lines2 = frequency_data[24].split("\n")
   freqs = []
   for line in all_lines2:
      if (line.find("P.Frequency") != -1):
         freqs += [ eval(s) for s in line.split()[1:]]

   nfreqs  = 0
   nlowest = 0
   for f in freqs:
      if (f<(-0.01)): nfreqs += 1
      if ((f>minfreq) and (f<threshfreq)): nlowest += 1

   exact_dos_norm = len(freqs)-6.0

   dw  = ((maxfreq-minfreq)/float(ngrid-1))
   ww  = []
   
   scale  = 1.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   dos = []
   dos_lowest = []
   for i in range(ngrid):
      w = minfreq + i*dw
      ww.append(w)
      pp = 0.0
      pplow = 0.0
      low = 0
      for f in freqs:
         if (f>minfreq):
            x2 = (w-f)**2
            tt = scale*exp(-omega2*x2)
            pp += tt
            if (low<nlowest):
               pplow += tt
               low += 1
      dos.append(pp)
      dos_lowest.append(pplow)

   dos_fixed = []
   dos_norm = simpson(dw,dos)
   dos_lowest_norm = simpson(dw,dos_lowest)
   if (dos_lowest_norm > 1.0e-8):
      fac = (exact_dos_norm-dos_norm)/dos_lowest_norm
   else:
      fac = 0.0
   for i in range(ngrid):
      pp = dos[i] + fac*dos_lowest[i]
      dos_fixed.append(pp)

   dos_fixed_norm = simpson(dw,dos_fixed)

   ### get database energies ###
   energy           = frequency_data[14]
   enthalpy         = frequency_data[15]
   entropy          = frequency_data[16]
   solvation_type   = frequency_data[17]
   solvation_energy = frequency_data[18]
   sitkoff          = frequency_data[19]
   if solvation_type=='COSMO': solvation_energy = -solvation_energy + sitkoff

   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL

   
   ethermal0 = 0.0
   Svib0     = 0.0
   for w in freqs:
      if (w>0.1):
         thetav = w*(h*c/kgas)
         if (temp>0.0):
            xdum   = exp(-thetav/temp)
         else:
            xdum = 0.0
         xdum   = xdum/(1.00-xdum)
         ethermal0 +=  (thetav*(0.50 + xdum)*Rgas)
         xdum   = thetav/temp
         if (xdum>0.0):
            Svib0 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)


   ### thermo for original DOS ###
   ethermal = 0.0
   Svib     = 0.0
   for i in range(ngrid):
      w = ww[i]
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal +=  (thetav*(0.50 + xdum)*Rgas)*dos[i]*dw
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos[i]*dw

   ### thermo for model DOS ###
   ethermal_fixed = 0.0
   Svib_fixed     = 0.0
   for i in range(ngrid):
      w = ww[i]
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal_fixed +=  (thetav*(0.50 + xdum)*Rgas)*dos_fixed[i]*dw
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib_fixed += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos_fixed[i]*dw

   gas_enthalpy0      = enthalpy
   gas_enthalpy       = enthalpy - ethermal0 + ethermal
   gas_enthalpy_fixed = enthalpy - ethermal0 + ethermal_fixed

   gas_entropy0       = entropy
   gas_entropy        = entropy  + (Svib - Svib0)*(AUKCAL*1000.0)
   gas_entropy_fixed  = entropy  + (Svib_fixed - Svib0)*(AUKCAL*1000.0)

   #gas_free_energy0      = gas_enthalpy0      - temp*gas_entropy0
   #gas_free_energy       = gas_enthalpy       - temp*gas_entropy
   #gas_free_energy_fixed = gas_enthalpy_fixed - temp*gas_entropy_fixed

   #sol_free_energy0      = gas_free_energy0      + solvation_energy/AUKCAL
   #sol_free_energy       = gas_free_energy       + solvation_energy/AUKCAL
   #sol_free_energy_fixed = gas_free_energy_fixed + solvation_energy/AUKCAL

   return (gas_enthalpy_fixed,gas_entropy_fixed)






#######################################  fetch_freq functions ##################################




#######################################  fetch_eig functions ##################################

###########################################
#                                         #
#         ascii_eig_level                 #
#                                         #
###########################################
def ascii_eig_level(p,n):
   level  = "          "
   if ((p==1) and (n==0)): level = "++++++++++"
   if ((p==2) and (n==0)): level = "++++  ++++"
   if ((p==3) and (n==0)): level = "+++ ++ +++"
   if ((p==4) and (n==0)): level = "++ ++ ++ +"
   if ((p==5) and (n==0)): level = "+ + + + ++"
   if ((p>5)  and (n==0)):
      num = "%d" % p
      if   (len(num)==1):
         level = num + "  + + + +"
      elif (len(num)==2):
         level = num + " + + + +"
      elif (len(num)==3):
         level = num + "+ + + +"
      elif (len(num)==4):
         level = num + " + + +"
      elif (len(num)==5):
         level = num + "+ + +"
      elif (len(num)==6):
         level = num + " + +"
      else:
         level = ">>>+ + + +"

   if ((p==0) and (n==1)): level = "----------"
   if ((p==0) and (n==2)): level = "----  ----"
   if ((p==0) and (n==3)): level = "--- -- ---"
   if ((p==0) and (n==4)): level = "-- -- -- -"
   if ((p==0) and (n==5)): level = "- - - - --"
   if ((p==0) and (n>5) ):
      num = "%d" % n
      if   (len(num)==1):
         level = num + "  - - - -"
      elif (len(num)==2):
         level = num + " - - - -"
      elif (len(num)==3):
         level = num + "- - - -"
      elif (len(num)==4):
         level = num + " - - -"
      elif (len(num)==5):
         level = num + "- - -"
      elif (len(num)==6):
         level = num + " - -"
      else:
         level = ">>>- - - -"

   if ((p>0) and (n>0)):
      np = n + p
      if (np==1): level = "**********"
      if (np==2): level = "****  ****"
      if (np==3): level = "*** ** ***"
      if (np==4): level = "** ** ** *"
      if (np==5): level = "* * * * **"
      if (np>5 ):
         num = "%d" % np
         if   (len(num)==1):
            level = num + "  * * * *"
         elif (len(num)==2):
            level = num + " * * * *"
         elif (len(num)==3):
            level = num + "* * * *"
         elif (len(num)==4):
            level = num + " * * *"
         elif (len(num)==5):
            level = num + "* * *"
         elif (len(num)==6):
            level = num + " * *"
         else:
            level = ">>>* * * *"

   return level

###########################################
#                                         #
#      ascii_unrestricted_eig_plot        #
#                                         #
###########################################
def ascii_unrestricted_eig_plot(eigup,occup,eigdn,occdn):
   maxrow = 50
   maxcol = 80
   point = []
   for k in range(maxrow):
      row = [' ']*maxcol
      point.append(row)

   emin0 = min(eigup+eigdn)*27.2114
   emax0 = max(eigup+eigdn)*27.2114

   emin = min(eigup)
   emax = max(eigup)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eigup)):
      e = eigup[k]
      o = occup[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+5] = tt[k]

   yscale = int(round((ehomo-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = 'HOMO=%7.2f eV' % ehomo
   for k in range(15): point[yscale][k+0] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'LUMO=%7.2f eV' % elumo 
      for k in range(15): point[yscale][k+25] = tt[k]

      yscale = int(round((emax-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = '%7.2f eV' % emax 
      for k in range(10): point[yscale][k+26] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eigup)):
      e = eigup[k]*27.2114
      o = occup[k]
      yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
      if (o > 1.0e-3):
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1
         
   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+15]  = level[j]

   #for k in range(len(eigup)):
   #   e = eigup[k]*27.2114
   #   o = occup[k]
   #   yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
   #   if (o > 1.0e-3): 
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(15,23):
   #      point[yscale][j]  = cch


   emin = min(eigdn)
   emax = max(eigdn)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eigdn)):
      e = eigdn[k]
      o = occdn[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+42] = tt[k]

   yscale = int(round((ehomo-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = 'HOMO=%7.2f eV' % ehomo
   for k in range(15): point[yscale][k+37] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'LUMO=%7.2f eV' % elumo
      for k in range(15): point[yscale][k+62] = tt[k]

      yscale = int(round((emax-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = '%7.2f eV' % emax
      for k in range(10): point[yscale][k+63] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eigdn)):
      e = eigdn[k]*27.2114
      o = occdn[k]
      yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
      if (o > 1.0e-3):
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1

   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+52]  = level[j]


   #for k in range(len(eigdn)):
   #   e = eigdn[k]*27.2114
   #   o = occdn[k]
   #   yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
   #   if (o > 1.0e-3):
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(50,58):
   #      point[yscale][j]  = cch


   msg  = '                      Unrestricted Eigevalue Spectra\n\n'
   msg += '                alpha                               beta\n'
   for row in point:
      for col in row:
         msg += col
      msg += "\n"

   html = msg

   ### plot the density of states  ###
   emin0 -= 2.0
   emax0 += 2.0
   sigma  = 0.25
   ngrid  = 1501
   pi     = 4.0*atan(1.0)
   dw     = (emax0-emin0)/float(ngrid-1)
   scale  = 1.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   ww = []
   up_filled  = []
   up_virtual = []
   dn_filled  = []
   dn_virtual = []
   for i in range(ngrid):
      w = emin0 + i*dw
      ww.append(w)
      pp = 0.0
      qq = 0.0
      for k in range(len(eigup)):
         e = eigup[k]*27.2114
         o = occup[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp += tt
         else:
            qq += tt
      up_filled.append(pp)
      up_virtual.append(qq)

      pp = 0.0
      qq = 0.0
      for k in range(len(eigdn)):
         e = eigdn[k]*27.2114
         o = occdn[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp -= tt
         else:
            qq -= tt
      dn_filled.append(pp)
      dn_virtual.append(qq)

   y = (up_filled,up_virtual,dn_filled,dn_virtual)
   symbols = ('*','#','o','@')
   title = 'Density of States (sigma=%.2f eV)' % sigma
   xlabel = 'Energy (eV)'
   ylabel = 'DOS'
   xmin = emin0
   xmax = emax0
   ymin = min(up_filled+up_virtual+dn_filled+dn_virtual)
   ymax = max(up_filled+up_virtual+dn_filled+dn_virtual)
   msg += "\n"
   msg += ascii_plotter(ww,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)

   pdrand     = random.randint(0,999999)
   pdrand2    = random.randint(0,999999)
   dosgnuplot = wrkdir + "/udos-%d-%d.gnuplot" % (pdrand,pdrand2)
   dospng     = wrkdir + "/udos-%d-%d.png" % (pdrand,pdrand2)
   dosdatafile  = wrkdir+"/"+ tmperxn
   dosdatafile2 = wrkdir+"/"+ tmperxn2
   dosdatafile3 = wrkdir+"/"+ tmperxn3
   scale0 = 1.0/(sigma*sqrt(2.0*pi))
   with open(dosdatafile,'w') as ff:
      for i in range(ngrid):
        ff.write("%e %e %e %e %e\n" % (ww[i],up_filled[i],up_virtual[i],dn_filled[i],dn_virtual[i]))
   with open(dosdatafile2,'w') as ff:
      for k in range(len(eigup)):
         e = eigup[k]*27.2114
         o = occup[k]
         if (o>1.0e-6):
            ff.write("%e %e\n" % (e,o*scale0))
         else:
            ff.write("%e %e\n" % (e,scale0))
   with open(dosdatafile3,'w') as ff:
      for k in range(len(eigdn)):
         e = eigdn[k]*27.2114
         o = occdn[k]
         if (o>1.0e-6):
            ff.write("%e %e\n" % (e,-o*scale0))
         else:
            ff.write("%e %e\n" % (e,-scale0))

   dos = 'set output \"%s\"; set term png; set grid; set title \"%s\"; set xlabel \"energy (eV)\"; set ylabel \"DOS\";  plot \"%s\" using 1:2 with l lw 2 title \"filled alpha DOS\", \"%s\" using 1:3 with l lw 2 title \"virtual alpha DOS\",\"%s\" using 1:4 with l lw 2 title \"filled beta DOS\", \"%s\" using 1:5 with l lw 2 title \"virtual beta DOS\", \"%s\" using 1:2 with impulses title \"alpha states\", \"%s\" using 1:2 with impulses title \"beta states\" ' % (dospng,title,dosdatafile,dosdatafile,dosdatafile,dosdatafile,dosdatafile2,dosdatafile3)

   with open(dosgnuplot,'w')  as f: f.write(dos+eoln)
   os.system(gnuplot + dosgnuplot)
   try:
      os.unlink(dosgnuplot)
      os.unlink(dosdatafile)
      os.unlink(dosdatafile2)
      os.unlink(dosdatafile3)
   except:
      print "Failed to delete temporary gnuplot files"

   pngname     = "image-%d-%d" % (pdrand,pdrand2)
   imagelist = [(dospng,pngname)]
   html += "</pre>\n"
   html += '<br><center><img src="cid:%s" align="middle"></center><br>\n' % pngname
   html += "<pre style=\"font-size:0.6em;color:black\">\n"

   return (msg,html,imagelist)




#########################################
#                                       #
#      ascii_restricted_eig_plot        #
#                                       #
#########################################

def ascii_restricted_eig_plot(eig,occ):
   maxrow = 50
   maxcol = 75
   point = []
   for k in range(maxrow):
      row = [' ']*maxcol
      point.append(row)

   emin = min(eig)
   emax = max(eig)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eig)):
      e = eig[k]
      o = occ[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   e = 0.0
   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax)*(maxrow-1)/(emin-emax)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+5] = tt[k]
   yscale = int(round((ehomo-emax)*(maxrow-1)/(emin-emax)))
   tt = 'HOMO=%7.2f eV' % ehomo
   for k in range(15): point[yscale][k+0] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax)*(maxrow-1)/(emin-emax)))
      tt = 'LUMO=%7.2f eV' % elumo 
      for k in range(15): point[yscale][k+27] = tt[k]
      yscale = int(round((emax-emax)*(maxrow-1)/(emin-emax)))
      tt = '%7.2f eV' % emax 
      for k in range(10): point[yscale][k+27] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eig)):
      e = eig[k]*27.2114
      o = occ[k]
      yscale = int(round((e-emax)*(maxrow-1)/(emin-emax)))
      if (o > 1.0e-3): 
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1

   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+16]  = level[j]

   #for k in range(len(eig)):
   #   e = eig[k]*27.2114
   #   o = occ[k]
   #   yscale = int(round((e-emax)*(maxrow-1)/(emin-emax)))
   #   if (o > 1.0e-3): 
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(16,26):
   #      point[yscale][j]  = cch

   msg = '          Eigevalue Spectra\n'
   for row in point:
      for col in row:
         msg += col
      msg += "\n"

   html = msg


   ### plot the density of states  ###
   emin -= 2.0
   emax += 2.0
   sigma  = 0.25
   ngrid  = 1501
   pi     = 4.0*atan(1.0)
   dw     = (emax-emin)/float(ngrid-1)
   scale  = 2.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   ww = []
   rs_filled  = []
   rs_virtual = []
   for i in range(ngrid):
      w = emin + i*dw
      ww.append(w)
      pp = 0.0
      qq = 0.0
      for k in range(len(eig)):
         e = eig[k]*27.2114
         o = occ[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp += tt*o
         else:
            qq += tt*2
      rs_filled.append(pp)
      rs_virtual.append(qq)

   y = (rs_filled,rs_virtual)
   symbols = ('*','#')
   title = 'Density of States (sigma=%.2f eV)' % sigma
   xlabel = 'Energy (eV)'
   ylabel = 'DOS'
   xmin = emin
   xmax = emax
   ymin = min(rs_filled+rs_virtual)
   ymax = max(rs_filled+rs_virtual)
   msg += "\n"
   msg += ascii_plotter(ww,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)

   pdrand     = random.randint(0,999999)
   pdrand2    = random.randint(0,999999)
   dosgnuplot = wrkdir + "/rdos-%d-%d.gnuplot" % (pdrand,pdrand2)
   dospng     = wrkdir + "/rdos-%d-%d.png" % (pdrand,pdrand2)
   dosdatafile  = wrkdir+"/"+ tmperxn
   dosdatafile2 = wrkdir+"/"+ tmperxn2
   scale0 = 1.0/(sigma*sqrt(2.0*pi))
   with open(dosdatafile,'w') as ff:
      for i in range(ngrid):
        ff.write("%e %e %e\n" % (ww[i],rs_filled[i],rs_virtual[i]))
   with open(dosdatafile2,'w') as ff:
      for k in range(len(eig)):
         e = eig[k]*27.2114
         o = occ[k]
         if (o>1.0e-6):
            ff.write("%e %e\n" % (e,o*scale0))
         else:
            ff.write("%e %e\n" % (e,2.0*scale0))


   dos = 'set output \"%s\"; set term png; set grid; set title \"%s\"; set xlabel \"energy (eV)\"; set ylabel \"DOS\";  plot \"%s\" using 1:2 with l lw 2 title \"filled DOS\", \"%s\" using 1:3 with l lw 2 title \"virtual DOS\", \"%s\" using 1:2 with impulses title \"states\" ' % (dospng,title,dosdatafile,dosdatafile,dosdatafile2)

   with open(dosgnuplot,'w')  as f: f.write(dos+eoln)
   os.system(gnuplot + dosgnuplot)
   try:
      os.unlink(dosgnuplot)
      os.unlink(dosdatafile)
      os.unlink(dosdatafile2)
   except:
      print "Failed to delete temporary gnuplot files"

   pngname     = "image-%d-%d" % (pdrand,pdrand2)
   imagelist = [(dospng,pngname)]
   html += "</pre>\n"
   html += '<br><center><img src="cid:%s" align="middle"></center><br>\n' % pngname
   html += "<pre style=\"font-size:0.6em;color:black\">\n"


   return (msg,html,imagelist)

def mymedian(x):
    if len(x)%2 != 0:
        return sorted(x)[len(x)/2]
    else:
        midavg = (sorted(x)[len(x)/2] + sorted(x)[len(x)/2-1])/2.0
        return midavg

#############################################
#                                           #
#             fetch_eig                     #
#                                           #
#############################################
def fetch_eig(hup,dbfile,table,id):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)
   wherestr =  " where Id=?"
   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   msg0 = ''
   msg1 = ''
   msg2 = ''
   msg3 = ''
   msg4 = ''
   html = ''
   ### id found? ###
   if (len(rows)>0):
      msg0 = "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"
      msg0 += "+-----------------+\n"
      msg0 += "| Eigenvalue Data |\n"
      msg0 += "+-----------------+\n"
      msg0 += "Id       = %d\n" % (rows[0][0])
      msg0 += "iupac    = %s\n" % (rows[0][1])
      msg0 += "mformula = %s\n" % (rows[0][2])
      msg0 += "InChI    = %s\n" % (rows[0][3])
      msg0 += "smiles   = %s\n" % (rows[0][4])
      msg0 += "esmiles  = %s\n" % (rows[0][6])
      msg0 += "theory   = %s\n" % (rows[0][9])
      msg0 += "xc       = %s\n" % (rows[0][10])
      msg0 += "basis    = %s\n" % (rows[0][11])
      msg0 += "charge   = %d\n" % (rows[0][12])
      msg0 += "mult     = %d\n" % (rows[0][13])
      msg0 += "solvation_type = %s\n\n" % (rows[0][17])
      msg1 = "chemical_structure_asciiart  = </pre> <pre style=\"font-size:0.5em;color:magenta\"> \n"
      msg1 += stripWARNINGS(rows[0][34])
      msg1 += "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"

      eigall = rows[0][25]
      #restricted = eigall.split("\n")[0].strip() == "restricted"
      eigtype = eigall.split("\n")[0].strip()

      ### rdft calculation ###
      if (eigtype=="restricted"):
         eig = []
         occ = []
         for line in eigall.strip().split("\n")[1:]:
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            eig.append(evalnum(e))
            occ.append(evalnum(o))
         emid = mymedian(eig)
         peig = []
         pocc = []
         for k in range(len(eig)):
            if (eig[k]>(emid-2.0)):
               peig.append(eig[k])
               pocc.append(occ[k])
         (msg2,html,imagelist) = ascii_restricted_eig_plot(peig,pocc)
         msg3  = "\n"
         msg3 += "spin            eig      occ\n"
         msg3 += "----------------------------\n"
         for k in range(len(eig)):
           msg3 += "restricted  %7.2f  %7.2f\n" % (eig[k]*27.2114,occ[k])
         msg3 += "\n"

      ### udft calculation ###
      elif (eigtype=="alpha"):
         eigup = []
         occup = []
         for line in  eigall.split('beta')[0].strip().split("\n")[1:]:
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            eigup.append(evalnum(e))
            occup.append(evalnum(o))
         emidup = mymedian(eigup)
         peigup = []
         poccup = []
         for k in range(len(eigup)):
            if (eigup[k]>(emidup-2.0)):
               peigup.append(eigup[k])
               poccup.append(occup[k])

         eigdn = []
         occdn = []
         for line in  eigall.split('beta')[1].strip().split("\n"):
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            eigdn.append(evalnum(e))
            occdn.append(evalnum(o))
         emiddn = mymedian(eigdn)
         peigdn = []
         poccdn = []
         for k in range(len(eigdn)):
            if (eigdn[k]>(emiddn-2.0)):
               peigdn.append(eigdn[k])
               poccdn.append(occdn[k])

         (msg2,html,imagelist) = ascii_unrestricted_eig_plot(peigup,poccup,peigdn,poccdn)
         msg3  = "\n"
         msg3 += "spin            eig      occ\n"
         msg3 += "----------------------------\n"
         for k in range(len(eigup)):
            msg3 += "alpha       %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
         msg3 += "\n"
         for k in range(len(eigdn)):
            msg3 += "beta        %7.2f  %7.2f\n" % (eigdn[k]*27.2114,occdn[k])
         msg3 += "\n"

      ### pspw calculation ###
      elif (eigtype=="orbital energies:"):
         eigup = []
         occup = []
         eigdn = []
         occdn = []
         ff    = 1.0
         for line in eigall.strip().split("\n")[1:]:
            if "virtual" in line:
               ff = 0.0
            else:
               ss = line.split()
               e = ss[0]
               eigup.append(evalnum(e))
               occup.append(ff)
               if (len(ss)>3):
                  e2 = ss[3]
                  eigdn.append(evalnum(e2))
                  occdn.append(ff)

         ## restricted calculation ###
         if (len(eigdn)==0):
            for k in range(len(occup)):
               occup[k] *= 2.0
            (msg2,html,imagelist)  = ascii_restricted_eig_plot(eigup,occup)
            msg3  = "\n"
            msg3 += "spin            eig      occ\n"
            msg3 += "----------------------------\n"
            for k in range(len(eigup)):
               msg3 += "restricted  %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
         else:
            (msg2,html,imagelist) = ascii_unrestricted_eig_plot(eigup,occup,eigdn,occdn)
            msg3  = "\n"
            msg3 += "spin            eig      occ\n"
            msg3 += "----------------------------\n"
            for k in range(len(eigup)):
               msg3 += "alpha       %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
            msg3 += "\n"
            for k in range(len(eigdn)):
               msg3 += "beta        %7.2f  %7.2f\n" % (eigdn[k]*27.2114,occdn[k])
            msg3 += "\n"

  

      msg4 += "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"
   else:
      msg4 = "no eigenvalue data for Id=%d\n\n" % id

   return (msg0+msg1+msg2+msg3+msg4,msg0+html+msg3+msg4,imagelist)

#######################################  fetch_eig functions ##################################

################################################
#                                              #
#           lowest_energy_esmiles              #
#                                              #
################################################

#returns only the lowest energy row

def lowest_energy_esmiles(rows):
   if (len(rows)>1):
      newrows = []
      emin = 99.99e99

      ### search for lowest energy with no negative frequencies ###
      negative_freq = True
      for molecule in rows:
         if (molecule[14]<emin) and (molecule[35]==0):
            negative_freq = False
            emin = molecule[14]
            molecule_min = molecule

      ### if there are always negative frequencies then just search for lowest energy entry ###
      if (negative_freq):
         for molecule in rows:
            if (molecule[14]<emin):
               emin = molecule[14]
               molecule_min = molecule

      newrows.append(molecule_min)
   else:
      newrows = rows

   return newrows




#############################################
#                                           #
#         fetch_esmiles_base_datafile       #
#                                           #
#############################################

def fetch_esmiles_base_datafile(hup,dbfile,table,esmiles):

 datafile = ''
 if ('ccsd(t)' not in esmiles) and ('mp2' not in esmiles): return datafile

 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())

   ss = esmiles1.split()

   smiles  = clean_smiles(ss[0])
   if "id=" in smiles.lower():
      try:
         smiles = smiles.replace(")","")
         smiles = smiles.replace("]","")
         smiles = smiles.replace("(","")
         smiles = smiles.replace("[","")
         id = evalnum(smiles.split("=")[1].strip())
      except:
         id = 1001
      wherestr =  " where Id=? "
      checklist = []
      checklist.append(id)

   else:
      csmiles = cannonicalsmiles(smiles)
      inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
      inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

      xyzfile = wrkdir + "/" + tmpxyz1
      smiles2xyz(smiles,xyzfile)
      inchi2    = xyz2InChI(xyzfile)    #inchi2 does not include charge
      inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge

      if 'theory_base{' in esmiles: theory = esmiles.split('theory_base{')[1].split('}')[0]
      if 'xc_base{' in esmiles:     xc     = esmiles.split('xc_base{')[1].split('}')[0]
      if 'basis_base{' in esmiles:  basis  = esmiles.split('basis_base{')[1].split('}')[0]
      charge = smiles2charge(smiles)
      if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      mult   = smiles2mult(smiles,charge)
      if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
      if 'ry' in  basis_base.lower():      basis_base = '%.1f Ry' % (evalnum(basis_base.strip().split()[0]))
      if 'hartree' in  basis_base.lower(): basis_base = '%.1f Ry' % (2*evalnum(basis_base.strip().split()[0]))

      print
      print "fetch_esmiles_base_datafile table  =",table
      print "fetch_esmiles_base_datafile inchi  =",inchi
      print "fetch_esmiles_base_datafile inchi2 =",inchi2
      print "fetch_esmiles_base_datafile inchikey  =",inchikey
      print "fetch_esmiles_base_datafile inchikey2 =",inchikey2
      print "fetch_esmiles_base_datafile theory=",theory_base
      print "fetch_esmiles_base_datafile xc    =",xc_base
      print "fetch_esmiles_base_datafile basis =",basis_base
      print "fetch_esmiles_base_datafile charge=",charge
      print "fetch_esmiles_base_datafile mult  =",mult
      print "fetch_esmiles_base_datafile solvation_type=",solvation_type
      print "fetch_esmiles_base_datafile calculation_type=",calculation_type

      checklist = []
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(theory_base)
      checklist.append(xc_base)
      checklist.append(basis_base)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(solvation_type)
      checklist.append(calculation_type)

      wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
      wherestr += " and theory=?"
      wherestr += " and xc=?"
      wherestr += " and basis=?"
      wherestr += " and charge=?"
      wherestr += " and mult=?"
      wherestr += " and solvation_type=?"
      wherestr += " and calculation_type=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   rows = lowest_energy_esmiles(rows)

   ### fetch nwout file from archive ###
   datafile = wrkdir + "/" + tmpnwout
   molecule = rows[0]
   cmd1 = "scp " + molecule[28] + " " + datafile
   print "cmd1=",cmd1
   pexpect_command(cmd1,archivepassword)
   #with open(datafile,"r") as offile:
   #   datafile = offile.read()

 except:
   datafile = ''

 return datafile







#############################################
#                                           #
#             fetch_esmiles                 #
#                                           #
#############################################

def fetch_esmiles(hup,dbfile,table,esmiles,submitrequest=True):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_base = ''
   xc_base     = ''
   basis_base  = ''
   if 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())
   ss = esmiles1.split()

   smiles  = clean_smiles(ss[0])
   if "id=" in smiles.lower():
      searchingid = True
      try:
         smiles = smiles.replace(")","")
         smiles = smiles.replace("]","")
         smiles = smiles.replace("(","")
         smiles = smiles.replace("[","")
         id = evalnum(smiles.split("=")[1].strip())
      except:
         id = 1001
      wherestr =  " where Id=?"
      checklist = []
      checklist.append(id)
   else:
      searchingid = False
      csmiles  = cannonicalsmiles(smiles)
      inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
      inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

      xyzfile = wrkdir + "/" + tmpxyz1
      smiles2xyz(smiles,xyzfile)
      inchi2    = xyz2InChI(xyzfile)    #inchi2 does not include charge
      inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge

      if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
      if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
      if 'basis{' in esmiles:  basis  = esmiles.split('basis{')[1].split('}')[0]
      if 'theory_base{' in esmiles: theory_base = esmiles.split('theory_base{')[1].split('}')[0]
      if 'xc_base{' in esmiles:     xc_base     = esmiles.split('xc_base{')[1].split('}')[0]
      if 'basis_base{' in esmiles:  basis_base  = esmiles.split('basis_base{')[1].split('}')[0]
      charge = smiles2charge(smiles)
      if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      mult   = smiles2mult(smiles,charge)
      if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]

      if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
      if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
      if 'ry' in  basis_base.lower():      basis_base = '%.1f Ry' % (evalnum(basis_base.strip().split()[0]))
      if 'hartree' in  basis_base.lower(): basis_base = '%.1f Ry' % (2*evalnum(basis_base.strip().split()[0]))

      print 
      print "fetch_esmiles table  =",table
      print "fetch_esmiles inchi  =",inchi
      print "fetch_esmiles inchi2 =",inchi2
      print "fetch_esmiles inchikey  =",inchikey
      print "fetch_esmiles inchikey2 =",inchikey2
      print "fetch_esmiles theory=",theory
      print "fetch_esmiles xc    =",xc
      print "fetch_esmiles basis =",basis
      if (theory_base!=''): print "fetch_esmiles theory_base=",theory_base
      if (xc_base!=''):     print "fetch_esmiles xc_base    =",xc_base
      if (basis_base!=''):  print "fetch_esmiles basis_base =",basis_base
      print "fetch_esmiles charge=",charge
      print "fetch_esmiles mult  =",mult
      print "fetch_esmiles solvation_type=",solvation_type
      print "fetch_esmiles calculation_type=",calculation_type

      checklist = []
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(theory)
      checklist.append(xc)
      checklist.append(basis)
      if (theory_base!=''): checklist.append(theory_base)
      if (xc_base!=''):     checklist.append(xc_base)
      if (basis_base!=''):  checklist.append(basis_base)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(solvation_type)
      checklist.append(calculation_type)

      wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
      wherestr += " and theory=?"
      wherestr += " and xc=?"
      wherestr += " and basis=?"
      if (theory_base!=''): wherestr += " and theory_base=?"
      if (xc_base!=''):     wherestr += " and xc_base=?"
      if (basis_base!=''):  wherestr += " and basis_base=?"
      wherestr += " and charge=?"
      wherestr += " and mult=?"
      wherestr += " and solvation_type=?"
      wherestr += " and calculation_type=?"



   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### esmiles1 not found call chemdb_add_request ###
   if ((len(rows)<1) and (submitrequest) and (not searchingid)):
      cmd = chemdb_add_request + '\"' + esmiles1 + '\"'
      print "esmiles not found, running cmd:",cmd
      result = subprocess.check_output(cmd,shell=True)
      print 
      print  result

   return rows

 except:
   return []






#############################################
#                                           #
#             add_nmrexp                    #
#                                           #
#############################################

def add_nmrexp(hup,dbfile,table,xyznmr_data):
   xyzfile = wrkdir + "/" + tmpxyz1

   ### fetch xyznmr_blob and solvent ###
   xyznmr_blob = xyznmr_data.split('solvent:')[0].strip()
   if 'solvent:' in xyznmr_data:
      solvent = xyznmr_data.split('solvent:')[1].split(':solvent')[0].strip()
   else:
      solvent = 'None'

   ### create xyzfile ###
   xyzdata = []
   for line in xyznmr_blob.split('\n'):
      ss = line.split()
      sline = "%s  %s %s %s" % (ss[0],ss[1],ss[2],ss[3])
      xyzdata.append(sline)

   with open(xyzfile,'w') as f:
      f.write("%d\n\n" % len(xyzdata))
      for line in xyzdata:
         f.write(line + "\n")

   mformula = xyz_molecular_formula(xyzfile)
   smiles   = xyz2smiles(xyzfile)
   csmiles  = xyz2smiles(xyzfile)
   InChI    = smiles2InChI(smiles)
   InChIKey = smiles2InChIKey(smiles)
   iupac    = pubchem_smiles2iupac(smiles)
   cid      = pubchem_smiles2cid(smiles)
   cas      = pubchem_smiles2cas(smiles)
   kegg     = pubchem_smiles2kegg(smiles)
   synonyms = pubchem_smiles2synonyms(smiles)

   eoln = '\n'
   msg = eoln
   msg += "+-----------------------+" + eoln
   msg += "| Adding NMR Experiment |" + eoln
   msg += "+-----------------------+" + eoln+eoln
   msg += "iupac             ="+iupac + eoln
   msg += "mformula          ="+mformula + eoln
   msg += "InChI             ="+InChI + eoln
   msg += "InChIKey          ="+InChIKey + eoln
   msg += "cid               ="+cid + eoln
   msg += "cas               ="+cas + eoln
   msg += "kegg              ="+kegg + eoln
   msg += "synonyms          ="+synonyms + eoln
   msg += "smiles            ="+smiles + eoln
   msg += "cannonical smiles ="+csmiles + eoln+eoln
   msg += "solvent           ="+solvent+eoln+eoln
   msg += "xyznmr_blob       =" + eoln
   msg += xyznmr_blob + eoln + eoln
   print msg


   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlinsert = "insert into " + table
   sqlinsert += " (iupac,mformula,InChI,InChIKey,smiles,csmiles,"
   sqlinsert += "synonyms,cid,cas,kegg,solvent,"
   sqlinsert += "xyznmr_blob) "
   sqlinsert += " values (?,?,?,?,?,?,?,?,?,?,?,?);"

   if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

   insertlist = []
   insertlist.append(iupac)
   insertlist.append(mformula)
   insertlist.append(InChI)
   insertlist.append(InChIKey)
   insertlist.append(smiles)
   insertlist.append(csmiles)
   insertlist.append(synonyms)
   insertlist.append(cid)
   insertlist.append(cas)
   insertlist.append(kegg)
   insertlist.append(solvent)
   if (issqlite3):
      insertlist.append(sqlite3.Binary(xyznmr_blob))
   else:
      insertlist.append(xyznmr_blob)

   print "hup=",hup
   print "dbfile=",dbfile
   print "table=",table

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlinsert,insertlist)
   dbcon.close()

   tmsg = "Hi. I just added the nmr data for the " + iupac + " molecule to the " + table + " table in the " + dbfile  + " database."
   msg += tmsg + eoln
   text2speech(tmsg)

   return msg


#############################################
#                                           #
#             nmr_blob_to_isotropic         #
#                                           #
#############################################

def nmr_blob_to_isotropic(nmr_blob):
   isotropic = []
   for line in nmr_blob.split('\n'):
      if 'Atom:' in line:
         number = evalnum(line.split()[1])
         atom   = line.split()[2]
      if 'isotropic =' in line:
         iso = evalnum(line.split()[2])
         isotropic.append([number,atom,iso])
   return isotropic

#############################################
#                                           #
#             fetch_nmr_scaling             #
#                                           #
#############################################
def fetch_nmr_scaling(hup,dbfile,table,atom,theory,xc,basis,theory_property,xc_property,basis_property,solvation_type,solvation_dielectric):

   checklist = []
   checklist.append(atom)
   checklist.append(theory)
   checklist.append(xc)
   checklist.append(basis)
   checklist.append(theory_property)
   checklist.append(xc_property)
   checklist.append(basis_property)
   checklist.append(solvation_type)
   #checklist.append(solvation_dielectric)

   wherestr =  " where atom=?"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   wherestr += " and basis=?"
   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   wherestr += " and basis_property=?"
   wherestr += " and solvation_type=?;"
   #wherestr += " and solvation_dielectric=?"
   

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()


   return rows



#############################################
#                                           #
#             print_nmr_row                 #
#                                           #
#############################################
def print_nmr_row(hup,dbfile,table,row):

   eoln = "\n"
   msg = "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"
   msg += "+---------------------------------------+\n"
   msg += "| NMR Shielding and Chemical Shift Data |\n"
   msg += "+---------------------------------------+\n"
   msg += "Id              = %d\n" % (row[0])
   msg += "iupac           = %s\n" % (row[1])
   msg += "mformula        = %s\n" % (row[2])
   msg += "InChI           = %s\n" % (row[3])
   msg += "smiles          = %s\n" % (row[4])
   msg += "esmiles         = %s\n" % (row[6])
   msg += "theory          = %s\n" % (row[9])
   msg += "xc              = %s\n" % (row[10])
   msg += "basis           = %s\n" % (row[11])
   msg += "theory_property = %s\n" % (row[38])
   msg += "xc_property     = %s\n" % (row[39])
   msg += "basis_property  = %s\n" % (row[40])
   msg += "charge          = %d\n" % (row[12])
   msg += "mult            = %d\n" % (row[13])
   msg += "solvation_type  = %s\n" % (row[17])
   #msg += "solvation_dielectric  = %f\n" % (row[37])
   msg += "chemical_structure_asciiart  = </pre> <pre style=\"font-size:0.5em;color:magenta\"> \n"
   msg += stripWARNINGS(row[34])
   msg += "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"

   msg += eoln
   msg +=  "NMR chemical shieldings from %s: \n" % row[7] 
   msg +=  "----------------------------------------\n"
   isotropic = nmr_blob_to_isotropic(row[36])
   atoms = []
   for iso in isotropic:
      atoms.append(iso[1])
      msg += "   %5d %3s  isotropic ppm= %12.6f\n" % (iso[0],iso[1],iso[2])

   ### search for LFERS ###
   msg +=  eoln+ eoln + "Linear Relations between NMR Shieldings and Chemical Shifts:\n"
   msg +=  "------------------------------------------------------------\n"
   atoms = list(set(atoms))
   lfers = {}
   for a in atoms:
      lfers[a] = fetch_nmr_scaling(hup,dbfile,table,a,row[9],row[10],row[11],row[38],row[39],row[40],row[17],row[37])
      for lfer in lfers[a]:
         msg += " %2s%d - slope = %f  intersept = %f  - RMSD=%f R2=%f\n" % (a,lfer[2],lfer[11],lfer[12],lfer[13],lfer[14])
         msg += "    - theory{%s} xc{%s} basis{%s}\n" % (lfer[3],lfer[4],lfer[5])
         msg += "    - theory_property{%s} xc_property{%s} basis_property{%s}\n" % (lfer[6],lfer[7],lfer[8])
         msg += "    - solvation_type{%s} solvation_dielectric{%f}\n" % (lfer[9],lfer[10])
         msg += "    - reference{%s} \n\n" % (lfer[15])

         msg +=  " %2s%d NMR chemical shifts:\n" % (a,lfer[2])
         emin = 9.999e99
         emax = -9.999e99
         for iso in isotropic:
            if (iso[1]==a):
               shft = -(lfer[12] - iso[2])/lfer[11]
               msg += "   %5d %3s ppm= %12.6f\n" % (iso[0],a,shft)
               if (shft>emax): emax = shft
               if (shft<emin): emin = shft
         msg += eoln

         ### plot the chemical shift spectrum  ###
         emin -= 2.0
         emax += 2.0
         sigma  = (emax-emin)*0.0125
         ngrid  = 501
         pi     = 4.0*atan(1.0)
         dw     = (emax-emin)/float(ngrid-1)
         scale  = 1.0/(sigma*sqrt(2.0*pi))
         omega2 = 1.0/(2.0*sigma*sigma)
         ww = []
         y  = []
         for i in range(ngrid):
            w = emin + i*dw
            ww.append(w)
            pp = 0.0
            for iso in isotropic:
               if (iso[1]==a):
                  shft = -(lfer[12] - iso[2])/lfer[11]
                  x2   = (w-shft)**2
                  tt   = scale*exp(-omega2*x2)
                  pp += tt
            y.append(pp)

         yy = [y]
         symbols = ('*')
         title = '%s%d NMR Chemical Shift Spectrum (sigma=%.2f ppm)' % (a,lfer[2],sigma)
         xlabel = 'Chemical Shift (ppm)'
         ylabel = 'Magnitude'
         xmin = emin
         xmax = emax
         ymin = min(y)
         ymax = max(y)
         msg += "\n"
         msg += ascii_plotter(ww,yy,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)





   
   return msg


#############################################
#                                           #
#             fetch_nmr                     #
#                                           #
#############################################

def fetch_nmr(hup,dbfile,table,esmiles,submitrequest=True):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_property = ''
   xc_property     = ''
   basis_property  = ''
   if 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())

   ss = esmiles1.split()
   smiles  = clean_smiles(ss[0])
   csmiles = cannonicalsmiles(ss[0])
   inchi    = smiles2InChI(ss[0])
   inchikey = smiles2InChIKey(ss[0])
   xyzfile = wrkdir + "/" + tmpxyz1
   smiles2xyz(ss[0],xyzfile)
   inchi2    = xyz2InChI(xyzfile) #inchi2 does not include charge
   inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge


   #print "ss[0]=",ss[0]
   #print "inchi=",inchi
   #for s in ss:
   #   if 'theory' in s: theory = s.split('{')[1].split('}')[0]
   #   if 'xc' in s:     xc     = s.split('{')[1].split('}')[0]
   #   if 'basis' in s:  basis  = s.split('{')[1].split('}')[0]
   #   if '^' in s:      charge = s.split('{')[1].split('}')[0]
   #   if 'mult' in s:   mult   = s.split('{')[1].split('}')[0]
   #   if 'solvation_type' in s: solvation_type = s.split('{')[1].split('}')[0]

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = esmiles.split('basis{')[1].split('}')[0]
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles:     xc_property     = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles:  basis_property  = esmiles.split('basis_property{')[1].split('}')[0]
   charge = smiles2charge(smiles)
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
   mult   = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
   if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
   if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
   if 'ry' in  basis_property.lower():      basis_property = '%.1f Ry' % (evalnum(basis_property.strip().split()[0]))
   if 'hartree' in  basis_property.lower(): basis_property = '%.1f Ry' % (2*evalnum(basis_property.strip().split()[0]))


   if (theory_property==''): theory_property = theory
   if (xc_property==''):     xc_property = xc
   if (basis_property==''):  basis_property = basis
   print "fetch_nmr inchi =",inchi
   print "fetch_nmr inchi2=",inchi2
   print "fetch_nmr inchikey =",inchikey
   print "fetch_nmr inchikey2=",inchikey2
   print "fetch_nmr theory=",theory
   print "fetch_nmr xc    =",xc
   print "fetch_nmr basis =",basis
   print "fetch_nmr theory_property=",theory_property
   print "fetch_nmr xc_property    =",xc_property
   print "fetch_nmr basis_property =",basis_property
   print "fetch_nmr charge=",charge
   print "fetch_nmr mult  =",mult
   print "fetch_nmr solvation_type=",solvation_type

   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(theory)
   checklist.append(xc)
   checklist.append(basis)
   checklist.append(theory_property)
   checklist.append(xc_property)
   checklist.append(basis_property)

   checklist.append(charge)
   checklist.append(mult)
   checklist.append(solvation_type)
   

   wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   wherestr += " and basis=?"
   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   wherestr += " and basis_property=?"
   wherestr += " and charge=?"
   wherestr += " and mult=?"
   wherestr += " and solvation_type=?"
   wherestr += " and nmr_blob IS NOT NULL"
  

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   print "nmr_table=",table
   print "sqlcheck =",sqlcheck


   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### esmiles not found call chemdb_add_request ###
   if ((len(rows)<1) and (submitrequest)):
      cmd = chemdb_add_request + '\"' + esmiles1 + '\"'
      print "esmiles not found, running cmd:",cmd
      result = subprocess.check_output(cmd,shell=True)
      print
      print  result

   return rows






#############################################
#                                           #
#             molecule2esmiles              #
#                                           #
#############################################
def molecule2esmiles(molecule):
   try:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13],molecule[35])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{%d}" % tt
   except:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{?}" % tt
   
   return esmiles

#############################################
#                                           #
#        esmileswithid_to_esmiles           #
#                                           #
#############################################

def esmileswithid_to_esmiles(hup,dbfile,table,esmiles0):
   esmiles1 = esmiles0
   try:
      if "id=" in esmiles0.lower():
         rows = fetch_esmiles(hup,dbfile,table,esmiles0,False)
         if (len(rows)>0):
            ss          = esmiles0.strip().split()
            tagsoptions = " ".join(ss[1:])
            molecule    = rows[0]
            smiles      = molecule[4]
            charge      = molecule[12]
            mult        = molecule[13]
            xyz         = molecule[23].strip()
            xyzdata     = "xyzdata{" + xyz.replace('\n',' | ') + "}"
            if ("^{" not in tagsoptions):    smiles += " ^{%d}"    % charge
            if ("mult{" not in tagsoptions): smiles += " mult{%d}" % mult
            esmiles1 =  smiles + " " + xyzdata + " " + tagsoptions
         else:
            esmiles1 = "C"
   except:
      esmiles1 = "C"

   return esmiles1

#############################################
#                                           #
#             submit_esmiles                #
#                                           #
#############################################
def submit_esmiles(esmiles,includerotation,datafile,emailfrom=None,machine=None):
   result = "\nSubmitting the following esmiles: " + esmiles + "\n"
   cmd0 = ''
   if (includerotation): cmd0 += ' -r ' 
   if (emailfrom!=None) and (emailfrom!=''):
      cmd0 += ' -e ' + emailfrom + ' '
   if (machine!=None):   cmd0 += ' -m ' + machine + ' '
   if (datafile!=''):    cmd0 += ' -a ' + datafile + ' '

   #add orginal smiles string to vtag
   vtag = '"osmiles:'+ esmiles.strip().split()[0].strip() + ':osmiles "'
   cmd0 += ' -v ' + vtag + ' '

   cmd1 = tnt_submit + cmd0 + '"' + esmiles.strip() + '"'
   print "submit esmiles cmd1 = " + cmd1

   try:
      result += subprocess.check_output(cmd1,shell=True)
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print  result
   return result


#############################################
#                                           #
#             submit_esmiles_xyz            #
#                                           #
#############################################
def submit_esmiles_xyz(esmiles,includerotation,xyz,vtag=None,machine=None):
   xyzfile = wrkdir + "/" + tmpxyz99
   result = "\nSubmitting the following esmiles,xyz: " + esmiles + "\n"
   result += "xyz=\n"
   result += xyz + "\n"
   cmd0 = ''

   if (includerotation): cmd0 += ' -r ' 
   if ((machine!=None) and (machine!='')): cmd0 += ' -m ' + machine

   if 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='50.0';solvation_type='None'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='50.0';solvation_type='None'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='50.0';solvation_type='None'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='50.0';solvation_type='None'
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown'; basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown'; basis='6-311++G(2d,2p)';solvation_type='COSMO'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'

   smiles = clean_smiles(esmiles.strip().split()[0])

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   charge = smiles2charge(smiles)
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
   mult   = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = esmiles.split('basis{')[1].split('}')[0]
   if 'ry' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*0.5
      basis = '%f' % xb
   if 'hartree' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*1.0
      basis = '%f' % xb
   charge = '%d' % charge
   mult   = '%d' % mult

   cmd0 += ' -t ' + theory + " -b '" + basis + "' -x " + xc + " -y " + solvation_type + " -s " + mult + " -q " + charge
   if ((vtag!=None) and (vtag!='')):  cmd0 += " -v " + vtag

   ofile = open(xyzfile,'w')
   ofile.write(xyz)
   ofile.close()
   cmd1 = tnt_submit + cmd0 + " " + xyzfile
   print "submit esmiles cmd1 = " + cmd1

   try:
      result += subprocess.check_output(cmd1,shell=True)
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print  result
   return result



##########################################################
#                                                        #
#        generate_reactions_from_reactionenumerate       #
#                                                        #
##########################################################
def generate_reactions_from_reactionenumerate(reactiontable):

   ### change to small case  ###
   rstring = ireplace("TABLEREACTIONS", "tablereactions", reactiontable)
   rstring = ireplace("TABLEMETHODS", "tablemethods", rstring)
   rstring = ireplace("REACTION", "reaction", rstring)
   rstring = ireplace("METHOD", "method", rstring)

   ### get the reactions ###
   reactions      = []
   msg2           = rstring.split("tablereactions:")
   tablereactions = msg2[1].split(":tablereactions")[0]
   rstring        = rstring.replace("tablereactions:"+tablereactions+":tablereactions","")
   for a in tablereactions.strip().split("reaction:")[1:]:
      reaction = a.strip().split(":reaction")[0]
      reaction2 = addspaces_reaction(reaction.strip())
      reaction3 = parsetosmiles(reaction2)
      reactions.append(reaction3)

   ### get the methods ###
   methods      = []
   msg2         = rstring.split("tablemethods:")
   tablemethods = msg2[1].split(":tablemethods")[0]
   rstring      = rstring.replace("tablemethods:"+tablemethods+":tablemethods","")
   for a in tablemethods.strip().split("method:")[1:]:
      method = a.strip().split(":method")[0]
      methods.append(method)

   rr = ""
   for reaction in reactions:
      sslist = reaction.split("-->")
      left  = sslist[0].strip()
      left = left.replace("\t"," ")
      left = left.replace("\n"," ")
      #left = left.decode('ascii', 'replace')
      left = left.replace('\xc2', ' ')
      left = left.replace('\xa0', ' ')
      esmiles_reactants  = left.split(' + ')
      number_reactants = len(esmiles_reactants)
      if (len(sslist)>1):
         right = sslist[1].strip()
         right= right.replace("\t"," ")
         right= right.replace("\n"," ")
         right= right.replace('\xc2', ' ')
         right= right.replace('\xa0', ' ')
         esmiles_products   = right.split(' + ')
         number_products  = len(esmiles_products)
      else:
         esmiles_products = esmiles_reactants
         number_products  = number_reactants
         esmiles_reactants = []
         number_reactants = 0
      for method in methods:
         rr += "reaction: "
         for k in range(number_reactants-1):
            rr += esmiles_reactants[k] + " " + method + " + "
         if (number_reactants>0):
            rr += esmiles_reactants[number_reactants-1] + " " + method + " --> "
         for k in range(number_products-1):
            rr += esmiles_products[k] + " " + method + " + "
         if (number_products>0):
            rr += esmiles_products[number_products-1] + " " + method  + " :reaction\n"

   return rr




##########################################################
#                                                        #
#             maketable_from_reactionenumerate           #
#                                                        #
##########################################################
def maketable_from_reactionenumerate(reactiontable,reaction_data):

   ### change to small case  ###
   rstring = ireplace("TABLEREACTIONS", "tablereactions", reactiontable)
   rstring = ireplace("TABLEMETHODS", "tablemethods", rstring)
   rstring = ireplace("REACTION", "reaction", rstring)
   rstring = ireplace("METHOD", "method", rstring)

   ### get the reactions ###
   reactions      = []
   msg2           = rstring.split("tablereactions:")
   tablereactions = msg2[1].split(":tablereactions")[0]
   rstring        = rstring.replace("tablereactions:"+tablereactions+":tablereactions","")
   for a in tablereactions.strip().split("reaction:")[1:]:
      reaction = a.strip().split(":reaction")[0]
      reaction2 = addspaces_reaction(reaction.strip())
      reaction3 = parsetosmiles(reaction2)
      reactions.append(reaction3)

   ### get the methods ###
   methods      = []
   msg2         = rstring.split("tablemethods:")
   tablemethods = msg2[1].split(":tablemethods")[0]
   rstring      = rstring.replace("tablemethods:"+tablemethods+":tablemethods","")
   for a in tablemethods.strip().split("method:")[1:]:
      method = a.strip().split(":method")[0]
      methods.append(method)

   ### get the energytypes ###
   toolongcountmax = 8
   toolongcount = 0
   toolong      = False
   etypes   = []
   utypes   = []
   rstring = ireplace("ENERGYTYPE", "energytype", rstring)
   while ((len(rstring.split("energytype:"))>1) and (not toolong)):
      msg2    = rstring.split("energytype:")
      etype   = msg2[1].split(":energytype")[0]
      rstring = rstring.replace("energytype:"+etype+":energytype","")
      if "erxn(gas)"       in etype.lower(): etypes.append([0,"Erxn(gas)"])
      if "hrxn(gas)"       in etype.lower(): etypes.append([1,"Hrxn(gas)"])
      if "grxn(gas)"       in etype.lower(): etypes.append([2,"Grxn(gas)"])
      if "delta_solvation" in etype.lower(): etypes.append([3,"Delta_Solvation"])
      if "grxn(aq)"        in etype.lower(): etypes.append([4,"Grxn(aq)"])
      if "kcal/mol" in etype.lower(): utypes.append([627.509469,"kcal/mol"])
      if "kj/mol"   in etype.lower(): utypes.append([2625.49962,"kJ/mol"])
      if "ev"       in etype.lower(): utypes.append([27.2114,"eV"])
      if "cm-1"     in etype.lower(): utypes.append([219474.6,"cm-1"])
      if "ry"       in etype.lower(): utypes.append([2.0,"Rydbergs"])
      if "hartree"  in etype.lower(): utypes.append([1.0,"Hartrees"])
      if "au"       in etype.lower(): utypes.append([1.0,"au"])
      toolong = (toolongcount > toolongcountmax)
      toolongcount += 1
   if (toolong):
      rr = "maketable_from_reactionenumerate: too long parinsg energytype: :energytype\n"
      return (rr,0)
   if (len(etypes)==0): etypes.append([4,"Grxn(aq)"])
   if (len(utypes)==0): utypes.append([1,"Hartrees"])

   nr = len(reactions)
   nm = len(methods)

   rr  = "+--------------------------------+\n"
   rr += "| Generating Reaction Table Data |\n"
   rr += "+--------------------------------+\n\n"
   for etype in etypes:
    for utype in utypes:
      rr += "CSV FILE of for %s in %s:\n" % (etype[1],utype[1])
      rr += "--------------------------------------------------------------------------------------------------\n"
      rr += "reactions,instance,"
      for method  in methods:
         rr += "," + method.strip()
      rr += "\n"
      for k in range(nr):
         max_paths = 0
         for j in range(nm):
            i = j + k*nm
            ipaths = reaction_data[i][1]
            max_paths = max(len(ipaths),max_paths)
         for ii in range(max_paths):
            rr += reactions[k]
            rr += ",%d" % ii
            for j in range(nm):
               i = j + k*nm
               ipaths = reaction_data[i][1]
               if (ii<len(ipaths)):
                  inst = ipaths[ii]
                  rr += ",%15.6f" % (inst[etype[0]]*utype[0])
               else:
                  rr += ","
            rr += "\n"
      rr += "--------------------------------------------------------------------------------------------------\n\n"

   return (rr,nr*nm)




############################# main program ###################################
usage = \
"""
chemdb fetch reactions program

  Usage: chemdb_fetch_reactions -h hup_string -d database -t table -n nmr_table -q requests_table reactions plainoutput htmloutput

  -h hup_string="machine user password" or enter sqlite3 for sqlite3 db
  -d database = "name of database"
  -t table = "name of calculation table"
  -n nmr_table = "name of nmr_table"
  -q requests_table = "name of requests_table"
  -f view frequencies
  -e submit missing esmiles
  -h prints this message

"""


eoln = "\n"
#Database defaults
hup    = hup0
dbfile = "TNT_Project"
table  = "calculations"
requests_table = "requests"
nmr_table = "nmr_calculations"
nmr_scaling_table = "nmr_scaling"
nmr_experiments_table = "nmr_experiments"
heat_formation_table = "heats_of_formation"

print "chemdb_fetch_reactions5 mysql version"
tt      = time.localtime()

viewfreq              = False
submitmissingesmiles1 = False
opts, args = getopt.getopt(sys.argv[1:], "h:d:t:n:q:efh")
for o, a in opts:
  if '-h' in o:
     hup = a
  if '-d' in o:
     dbfile = a
  if '-t' in o:
     table = a
  if '-q' in o:
     requests_table = a
  if '-n' in o:
     nmr_table = a
  if '-f' in o:
     viewfreq = True
  if '-e' in o:
     submitmissingesmiles1 = True
  if o in ("-h","--help"):
    print usage
    exit()

if (len(args)<3): 
   print usage
   exit()
print args[0]
print args[1]
pppfile = open(args[1],'w')
ooofile = open(args[2],'w')
ooofile.write("<html>\n")
ooofile.write(ArrowsHeader)
ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")
ooofile.write("chemdb_fetch_reactions mysql version"+eoln)
pppfile.write("chemdb_fetch_reactions mysql version"+eoln)
imagelist  = []
imagecount = 0

### load the reactions input file into rstring ###
if (os.path.isfile(args[0])):
   rfile = open(args[0],'r')
   rstring = rfile.read()
   rfile.close()
else:
   rstring = args[0]

#####################################
##### parse hidden options first ####
#####################################

### get the database and table ###
rstring = ireplace("HUP_STRING", "hup_string", rstring)
rstring = ireplace("DATABASE", "database", rstring)
rstring = ireplace("TABLE", "table", rstring)
rstring = ireplace("REQUESTS_TABLE", "requests_table", rstring)
for line in rstring.split("\n"):
   if ("hup_string:" in line):
      rstring = rstring.replace(line,"")
      hup  = line.split()[1]
   if ("database:" in line):
      rstring = rstring.replace(line,"")
      dbfile  = line.split()[1]
   if ("requests_table:" in line):
      rstring = rstring.replace(line,"")
      requests_table   = line.split()[1]
   if ("table:" in line):
      rstring = rstring.replace(line,"")
      table   = line.split()[1]

if (hup=='sqlite3'):
   issqlite3 = True
   ooofile.write("sqlite3 db file = "+dbfile+eoln)
   pppfile.write("sqlite3 db file = "+dbfile+eoln)
else:
   issqlite3 = False
   ooofile.write("mysql db        ="+dbfile+eoln)
   pppfile.write("mysql db        ="+dbfile+eoln)
ooofile.write("table name      ="+table+eoln)
ooofile.write("requests_table name="+requests_table+eoln)
ooofile.write("nmr_scaling_table name="+nmr_scaling_table+eoln)
pppfile.write("table name      ="+table+eoln)
pppfile.write("requests_table name="+requests_table+eoln)
pppfile.write("nmr_scaling_table name="+nmr_scaling_table+eoln)

### emailfrom  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
emailfrom = ''
rstring = ireplace("EMAILFROM", "emailfrom", rstring)
while ((len(rstring.split("emailfrom:"))>1) and (not toolong)):
   msg2 = rstring.split("emailfrom:")
   msg3 = msg2[1].split(":emailfrom")[0]
   rstring  = rstring.replace("emailfrom:"+msg3+":emailfrom","")
   emailfrom = msg3
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing emailfrom: :emailfrom, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing emailfrom: :emailfrom, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### emailcc  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
emailcc = ''
rstring = ireplace("EMAILCC", "emailcc", rstring)
while ((len(rstring.split("emailcc:"))>1) and (not toolong)):
   msg2 = rstring.split("emailcc:")
   msg3 = msg2[1].split(":emailcc")[0]
   rstring  = rstring.replace("emailcc:"+msg3+":emailcc","")
   emailcc = msg3
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing emailcc: :emailcc, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing emailcc: :emailcc, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


#################################
##### parse regular options  ####
#################################

### print rstring w/o email to ooofile ####
blockdata = eoln+eoln+"Block Data Parsed::"+eoln
blockdata += rstring.strip()+eoln
blockdata += "::Block Data Parsed"+eoln+eoln
blockdata2 = eoln+eoln+"Arrows::"+eoln
blockdata2 += rstring.strip()+eoln
blockdata2 += "::Arrows data Parsed"+eoln+eoln

emailall = emailfrom.strip() + " " + emailcc.strip()
print "All emails= " + emailall

### print blockdata to ooofile ####
if (('arrows@emsl.pnl.gov' in emailall) or ('arrows@emsl.pnnl.gov' in emailall) or 
    ('arrow5@emsl.pnl.gov' in emailall) or ('arrow5@emsl.pnnl.gov' in emailall)):
   ooofile.write(blockdata)
   pppfile.write(blockdata)
else:
   ooofile.write(blockdata2)
   pppfile.write(blockdata2)

ooofile.write("</pre>\n<pre style=\"font-size:0.6em;color:black\">\n")

### findreplace: old text | new text :findreplace  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("FINDREPLACE", "findreplace", rstring)
while ((len(rstring.split("findreplace:"))>1) and (not toolong)):
   msg2 = rstring.split("findreplace:")
   msg3 = msg2[1].split(":findreplace")[0]
   rstring  = rstring.replace("findreplace:"+msg3+":findreplace","")
   ss = msg3.split("|")
   oldtext = ss[0]
   newtext = ss[1]
   rstring  = rstring.replace(oldtext,newtext)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing findreplace: :findreplace exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing findreplace: :findreplace exiting.\n")
   print  "All requests to Arrows were successful."


### look for useascii keyword ###
useascii = False
rstring = ireplace("USEASCII", "useascii", rstring)
if "useascii" in rstring: 
   useascii = True
   rstring = rstring.replace("useascii","")

### look for usesvg keyword ###
usesvg = False
rstring = ireplace("USESVG", "usesvg", rstring)
if "usesvg" in rstring: 
   usesvg = True
   rstring = rstring.replace("usesvg","")

### set how many entries to use ###
use_lowest_energy_esmiles = True
if ('useallentries' in rstring.lower()):
   use_lowest_energy_esmiles = False

### look for nomodelcorrect keyword ###
model_correct = True
rstring = ireplace("NOMODELCORRECT", "nomodelcorrect", rstring)
if "nomodelcorrect" in rstring: 
   model_correct = False
   rstring = rstring.replace("nomodelcorrect","")
   ooofile.write("chemdb_fetch_reactions: nomodelcorrect set - low frequency correction turned off\n")
   pppfile.write("chemdb_fetch_reactions: nomodelcorrect set - low frequency correction turned off\n")

### look for submitmissingesmiles keyword ###
submitmissingesmiles2 = False
rstring = ireplace("SUBMITMISSINGESMILES", "submitmissingesmiles", rstring)
if "submitmissingesmiles" in rstring: 
   submitmissingesmiles2 = True
   rstring = rstring.replace("submitmissingesmiles","")
submitmissingesmiles = submitmissingesmiles1 and submitmissingesmiles2
missingesmiles = False

### rotatebonds keyword ###
includerotation = False
rstring = ireplace("ROTATEBONDS", "rotatebonds", rstring)
if "rotatebonds" in rstring:
   includerotation = True
   rstring = rstring.replace("rotatebonds","")

### look for queuecheck keyword ###
queuecheck = False
rstring = ireplace("QUEUECHECK", "queuecheck", rstring)
if "queuecheck" in rstring:
   queuecheck = True
   rstring = rstring.replace("queuecheck","")


### look for listnwjobs keyword ###
listnwjobs = False
rstring = ireplace("LISTNWJOBS", "listnwjobs", rstring)
if "listnwjobs" in rstring:
   listnwjobs = True
   rstring = rstring.replace("listnwjobs","")

### name{}  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NAME", "name", rstring)
while ((len(rstring.split("name{"))>1) and (not toolong)):
   msg2 = rstring.split("name{")
   msg3 = msg2[1].split("}")[0]
   ss = msg3.split()
   rmsg3 = ' name='
   for ll in range(len(ss)-1):
     rmsg3 += ss[ll] + "%20"
   rmsg3 += ss[len(ss)-1]
   rmsg3 += " "
   rstring  = rstring.replace("name{"+msg3+"}",rmsg3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing name{}, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing name{}, exiting.\n")
   print  "All requests to Arrows were successful."


### xyzdata  ###
(rstring,success) = parse_xyzdata(rstring) 
if (not success):
   ooofile.write("chemdb_fetch_reactions: too long parsing xyzdata: :xyzdata, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing xyzdata: :xyzdata, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### submit nmrexp data  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NMR_EXPERIMENT", "nmr_experiment", rstring)
while ((len(rstring.split("nmr_experiment:"))>1) and (not toolong)):
   msg2 = rstring.split("nmr_experiment:")
   xyz_nmr_data = msg2[1].split(":nmr_experiment")[0]
   rstring  = rstring.replace("nmr_experiment:" + xyz_nmr_data + ":nmr_experiment","")
   msg3 = add_nmrexp(hup,dbfile,nmr_experiments_table,xyz_nmr_data)
   ooofile.write(eoln + msg3 + eoln)
   pppfile.write(eoln + msg3 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submitxyz_nmrexp: :submitxyz_nmrexp\n")
   pppfile.write("chemdb_fetch_reactions: too long parinsg submitxyz_nmrexp: :submitxyz_nmrexp\n")
   print  "All requests to Arrows were successful."
   exit()


### submit heats of formation  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submit_heat_formation = []
rstring = ireplace("SUBMITHF", "submithf", rstring)
while ((len(rstring.split("submithf:"))>1) and (not toolong)):
   msg2 = rstring.split("submithf:")
   msg3 = msg2[1].split(":submithf")[0]
   rstring  = rstring.replace("submithf:"+msg3+":submithf","")
   msg4 = parsetosmiles(msg3)
   submit_heat_formation.append(msg4)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submithf: :submithf\n")
   pppfile.write("chemdb_fetch_reactions: too long parinsg submithf: :submithf\n")
   print  "All requests to Arrows were successful."
   exit()


### submit esmiles  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submitesmiles = []
rstring = ireplace("SUBMITESMILES", "submitesmiles", rstring)
while ((len(rstring.split("submitesmiles:"))>1) and (not toolong)):
   msg2 = rstring.split("submitesmiles:")
   msg3 = msg2[1].split(":submitesmiles")[0]
   rstring  = rstring.replace("submitesmiles:"+msg3+":submitesmiles","")
   msg4 = addspaces_reaction(msg3.strip())
   msg4 = parsetosmiles(msg4)
   submitesmiles.append(msg4)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submitesmiles: :submitesmiles\n")
   pppfile.write("chemdb_fetch_reactions: too long parinsg submitesmiles: :submitesmiles\n")
   print  "All requests to Arrows were successful."
   exit()



### submit machines  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submitmachines = []
rstring = ireplace("SUBMITMACHINES", "submitmachines", rstring)
while ((len(rstring.split("submitmachines:"))>1) and (not toolong)):
   msg2 = rstring.split("submitmachines:")
   msg3 = msg2[1].split(":submitmachines")[0]
   rstring  = rstring.replace("submitmachines:"+msg3+":submitmachines","")
   for m in msg3.split():
      submitmachines.append(m)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing submitmachines: :submitmachines, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing submitmachines: :submitmachines, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()
   

### print nwout files ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTNWOUT", "printnwout", rstring)
while ((len(rstring.split("printnwout:"))>1) and (not toolong)):
   msg2 = rstring.split("printnwout:")
   msg3 = msg2[1].split(":printnwout")[0]
   rstring  = rstring.replace("printnwout:"+msg3+":printnwout","")
   tt = msg3.split()
   for t in tt:
      id = evalnum(t)
      msg4 = fetch_nwout(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
      pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printnwout: :printnwout, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printnwout: :printnwout, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### nwoutput ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("NWOUTPUT", "nwoutput", rstring)
while ((len(rstring.split("nwoutput:"))>1) and (not toolong)):
   msg2 = rstring.split("nwoutput:")
   msg3 = msg2[1].split(":nwoutput")[0]
   rstring  = rstring.replace("nwoutput:"+msg3+":nwoutput","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No nwoutput data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printnwout: :printnwout option to print nwoutput for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      msg4 = fetch_nwout(hup,dbfile,table,id)
   ooofile.write(eoln + msg4 + eoln)
   pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing nwoutput: :nwoutput, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing nwoutput: :nwoutput, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### print jobinfo ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTJOBINFO", "printjobinfo", rstring)
while ((len(rstring.split("printjobinfo:"))>1) and (not toolong)):
   msg2 = rstring.split("printjobinfo:")
   msg3 = msg2[1].split(":printjobinfo")[0]
   rstring  = rstring.replace("printjobinfo:"+msg3+":printjobinfo","")
   tt = msg3.split()
   for t in tt:
      id = evalnum(t)
      msg4 = fetch_jobinfo(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
      pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printjobinfo: :printjobinfo, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printjobinfo: :printjobinfo, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### print xyz files ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTXYZ", "printxyz", rstring)
while ((len(rstring.split("printxyz:"))>1) and (not toolong)):
   msg2 = rstring.split("printxyz:")
   msg3 = msg2[1].split(":printxyz")[0]
   rstring  = rstring.replace("printxyz:"+msg3+":printxyz","")
   tt = msg3.split()
   for t in tt: 
      id = evalnum(t)
      msg4 = fetch_xyz(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
      pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printxyz: :printxyz, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printxyz: :printxyz, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### print eigenvalues ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTEIG", "printeig", rstring)
while ((len(rstring.split("printeig:"))>1) and (not toolong)):
   msg2 = rstring.split("printeig:")
   msg3 = msg2[1].split(":printeig")[0]
   rstring  = rstring.replace("printeig:"+msg3+":printeig","")
   tt = msg3.split()
   for t in tt: 
      id = evalnum(t)
      (msg4,hmsg4,iimagelist0) = fetch_eig(hup,dbfile,table,id)
      imagelist += iimagelist0
      ooofile.write(eoln + hmsg4 + eoln)
      pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printeig: :printeig, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printeig: :printeig, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("EIGENVALUES", "eigenvalues", rstring)
while ((len(rstring.split("eigenvalues:"))>1) and (not toolong)):
   msg2 = rstring.split("eigenvalues:")
   msg3 = msg2[1].split(":eigenvalues")[0]
   rstring  = rstring.replace("eigenvalues:"+msg3+":eigenvalues","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      pmsg4 = "No eigenvalue data for esmiles = " + msg3
      hmsg4 = "No eigenvalue data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printfreq_id: :printfreq_id or alleigs: :alleigs options to print eigenvalues for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      (pmsg0,hmsg0,iimagelist0) = fetch_eig(hup,dbfile,table,id)
      imagelist += iimagelist0
      pmsg4 = msg4 + pmsg0
      hmsg4 = msg4 + hmsg0
   ooofile.write(eoln + hmsg4 + eoln)
   pppfile.write(eoln + pmsg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing eigenvalues: :eigenvalues, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing eigenvalues: :eigenvalues, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


toolongcountmax = 200
toolongcount = 0
toolong      = False
rstring = ireplace("ALLEIGS", "alleigs", rstring)
while ((len(rstring.split("alleigs:"))>1) and (not toolong)):
   msg2 = rstring.split("alleigs:")
   msg3 = msg2[1].split(":alleigs")[0]
   rstring  = rstring.replace("alleigs:"+msg3+":alleigs","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1): 
      pmsg4 = "No eigenvalue data for esmiles = " + msg3
      hmsg4 = "No eigenvalue data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      pmsg1 = ''
      hmsg1 = ''
      for row in rows:
         id = row[0]
         (pmsg0,hmsg0,iimagelist0) = fetch_eig(hup,dbfile,table,id)
         imagelist += iimagelist0
         pmsg1 += pmsg0
         hmsg1 += hmsg0
      pmsg4 = msg4 + pmsg1
      hmsg4 = msg4 + hmsg1
   ooofile.write(eoln + hmsg4 + eoln)
   pppfile.write(eoln + pmsg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing alleigs: :alleigs, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing alleigs: :alleigs, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### print frequencies ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTFREQ", "printfreq", rstring)
while ((len(rstring.split("printfreq:"))>1) and (not toolong)):
   msg2 = rstring.split("printfreq:")
   msg3 = msg2[1].split(":printfreq")[0]
   rstring  = rstring.replace("printfreq:"+msg3+":printfreq","")
   tt = msg3.split()
   for id in tt:
      cmd1 = chemdb_freq + id + " 2"
      print "printfreq cmd1 = " + cmd1
      try:
         msg4 = subprocess.check_output(cmd1,shell=True)
      except:
         msg4 = "frequency analysis failed for id = "+ id
      ooofile.write(eoln+msg4+eoln)
      pppfile.write(eoln+msg4+eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printfreq: :printfreq, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printfreq: :printfreq, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### frequencies ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("FREQUENCIES", "frequencies", rstring)
while ((len(rstring.split("frequencies:"))>1) and (not toolong)):
   msg2 = rstring.split("frequencies:")
   msg3 = msg2[1].split(":frequencies")[0]
   rstring  = rstring.replace("frequencies:"+msg3+":frequencies","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No frequency data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printfreq: :printfreq or allfreqs: :allfreqs options to print frequencies for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      cmd1 = chemdb_freq + " %d 2" % id
      print "frequencies cmd1 = " + cmd1
      try:
         msg4 += subprocess.check_output(cmd1,shell=True)
      except:
         msg4 += "frequency analysis failed for id = "+ id
   ooofile.write(eoln + msg4 + eoln)
   pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### allfreqs ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("ALLFREQS", "allfreqs", rstring)
while ((len(rstring.split("allfreqs:"))>1) and (not toolong)):
   msg2 = rstring.split("allfreqs:")
   msg3 = msg2[1].split(":allfreqs")[0]
   rstring  = rstring.replace("allfreqs:"+msg3+":allfreqs","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No frequency data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      for row in rows:
         id = row[0]
         cmd1 = chemdb_freq + " %d 2" % id
         print "allfreqs cmd1 = " + cmd1
         try:
            msg4 += subprocess.check_output(cmd1,shell=True)
         except:
            msg4 += "frequency analysis failed for id = "+ id
   ooofile.write(eoln + msg4 + eoln)
   pppfile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### print csv ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTCSV", "printcsv", rstring)
while ((len(rstring.split("printcsv:"))>1) and (not toolong)):
   msg2 = rstring.split("printcsv:")
   msg3 = msg2[1].split(":printcsv")[0]
   rstring  = rstring.replace("printcsv:"+msg3+":printcsv","")
   msg3 = ireplace("COLUMN_TAGS","column_tags", msg3)
   if "column_tags{" in msg3:
      msg4 = msg3.split("column_tags{")[1].split("}")[0]
      msg3 = msg3.replace("column_tags{"+msg4+"}","")
      msg4 = msg4.rstrip(",")
      cc = msg4.split(",")
      columns_list = []
      for c in cc: columns_list.append(c.strip())
   else:
      columns_list = ['id','esmiles']
   msg3 = msg3.strip()
   msg3 = msg3.strip(",")
   ee = msg3.split(",")
   esmiles_list = []
   for e in ee: esmiles_list.append(e.strip())
   msg5 = fetch_csv_esmiles_full(hup,dbfile,table,columns_list,esmiles_list)
   ooofile.write(eoln + msg5 + eoln)
   pppfile.write(eoln + msg5 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printcsv: :printcsv, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing printcsv: :printcsv, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### pushnwjob ###
toolongcountmax = 100
toolongcount = 0
toolong      = False
pushnwjob = []
rstring = ireplace("PUSHNWJOB", "pushnwjob", rstring)
while ((len(rstring.split("pushnwjob:"))>1) and (not toolong)):
   msg2 = rstring.split("pushnwjob:")
   msg3 = msg2[1].split(":pushnwjob")[0]
   rstring  = rstring.replace("pushnwjob:"+msg3+":pushnwjob","")
   pushnwjob.append(msg3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
   print "toolong=",toolong,toolongcount
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing pushnwjob: :pushnwjob, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing pushnwjob: :pushnwjob, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### find fetchnwjob ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("FETCHNWJOB", "fetchnwjob", rstring)
fetchnwjob = []
while ((len(rstring.split("fetchnwjob:"))>1) and (not toolong)):
   msg2 = rstring.split("fetchnwjob:")
   msg3 = msg2[1].split(":fetchnwjob")[0]
   rstring  = rstring.replace("fetchnwjob:"+msg3+":fetchnwjob","")
   tt = msg3.split()
   for t in tt: fetchnwjob.append(evalnum(t))
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing fetchnwjob: :fetchnwjob, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing fetchnwjob: :fetchnwjob, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### find badids ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("BADIDS", "badids", rstring)
badids = []
while ((len(rstring.split("badids:"))>1) and (not toolong)):
   msg2 = rstring.split("badids:")
   msg3 = msg2[1].split(":badids")[0]
   rstring  = rstring.replace("badids:"+msg3+":badids","")
   tt = msg3.split()
   for t in tt: badids.append(evalnum(t))
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing badids: :badids, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing badids: :badids, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


###  molecule  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("MOLECULE", "molecule", rstring)
while ((len(rstring.split("molecule:"))>1) and (not toolong)):
   msg2 = rstring.split("molecule:")
   esmiles = msg2[1].split(":molecule")[0]
   rstring = rstring.replace("molecule:"+esmiles+":molecule","")
   esmiles = addspaces_reaction(esmiles.strip())
   esmiles = parsetosmiles(esmiles)
   rows = fetch_esmiles(hup,dbfile,table,esmiles,False)
   if (len(rows)<1):
      msg4 = "No molecule data for esmiles = " + esmiles + eoln
      missingesmiles = True
      if (submitmissingesmiles):
         rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles,False)
         rows  = fetch_esmiles(hup,dbfile,table,esmiles) #adding to request table
         if (len(rows1)==0):
            msg4 += " - molecule not found : " + esmiles + " scheduled to be submitted." + eoln
            submitesmiles.append(esmiles)
         else:
            msg4 += " - molecule not found : " + esmiles + " has already been scheduled to be submitted." + eoln
      else:
         msg4 += " - molecule not found : " + esmiles + eoln
      pmsg4 = msg4
      hmsg4 = msg4
   else:
      msg4 =  "+--------------------------------------------------+" + eoln
      msg4 += "|                Molecule Properties               |" + eoln
      msg4 += "+--------------------------------------------------+" + eoln
      msg4 += "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printmolecule_id: :printmolecule_id option to print other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      if (not useascii):
         pngfilename = wrkdir + "/%d-large.png" % (id)
         pngname     = "image-%d-large-%d" % (id,imagecount)
         imagelist.append((pngfilename,pngname))
         imagecount += 1
         cmd9 = chemdb_image0 + "-b %d" % id
         try:
            result9 = subprocess.check_output(cmd9,shell=True)
            msg4 += "</pre>\n"
            msg4 += '<br><center><img src="cid:%s"></center><br>\n' % pngname
            msg4 += "<pre style=\"font-size:0.6em;color:black\">\n"
         except:
            msg4 = "\n\nchemdb_image0 failed for id=%d\n" % id

      (pmsg0,hmsg0,iimagelist0) = fetch_eig(hup,dbfile,table,id)
      imagelist += iimagelist0

      (pmsg1,hmsg1,iimagelist1) = fetch_freq(hup,dbfile,table,id)
      imagelist += iimagelist1

      pmsg4 = msg4 + pmsg0 + pmsg1 
      hmsg4 = msg4 + hmsg0 + hmsg1 

   ooofile.write(eoln + hmsg4 + eoln)
   pppfile.write(eoln + pmsg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing molecule: :molecule, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing molecule: :molecule, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()




### print NMR  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NMR", "nmr", rstring)
while ((len(rstring.split("nmr:"))>1) and (not toolong)):
   msg2 = rstring.split("nmr:")
   esmiles = msg2[1].split(":nmr")[0]
   rstring = rstring.replace("nmr:"+esmiles+":nmr","")
   esmiles = addspaces_reaction(esmiles.strip())
   esmiles = parsetosmiles(esmiles)
   #rows = fetch_nmr(hup,dbfile,nmr_table,esmiles,False)
   rows = fetch_nmr(hup,dbfile,table,esmiles,False)
   if (len(rows)==0):
      missingesmiles = True
      if (submitmissingesmiles):
         esmiles2 = esmiles + " property{nmr}"
         rows  = fetch_nmr(hup,dbfile,requests_table,esmiles2) #adding to request table
         if (len(rows)==0):
            ooofile.write(" - " + esmiles2 + " not found and scheduled to be submitted."+ eoln)
            pppfile.write(" - " + esmiles2 + " not found and scheduled to be submitted."+ eoln)
            submitesmiles.append(esmiles2)
         else:
            ooofile.write(" - " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
            pppfile.write(" - " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
      else:
         ooofile.write(" - " + esmiles + " not found."+ eoln)
         pppfile.write(" - " + esmiles + " not found."+ eoln)
   else:
      for row in rows:
         msg = print_nmr_row(hup,dbfile,nmr_scaling_table,row)
         ooofile.write(eoln+msg+eoln)
         pppfile.write(eoln+msg+eoln)

   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing nmr: :nmr, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing nmr: :nmr, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

#################################
### parse reactionenumeration ###
#################################
toolongcount = 0
toolong      = False
reactionenumerates = []
rstring = ireplace("REACTIONENUMERATE", "reactionenumerate", rstring)
while ((len(rstring.split("reactionenumerate:"))>1) and (not toolong)):
   msg2 = rstring.split("reactionenumerate:")
   reactionenumerate = msg2[1].split(":reactionenumerate")[0]
   rstring  = rstring.replace("reactionenumerate:"+reactionenumerate+":reactionenumerate","")
   reactionenumerates.append(reactionenumerate)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reactionenumerate: :reactionenumerate, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing reactionenumerate: :reactionenumerate, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### add reactionenumerates to rstring for parsing by parse reactions  ###
for reactionenumerate in reactionenumerates:
   print "reactionenumerate=",reactionenumerate
   rstring += "\n"
   rstring += generate_reactions_from_reactionenumerate(reactionenumerate)
   rstring += "\n"



#################################################################
### convert reactions[]: :reactions  to reactions: :reactions ###
#################################################################
rstring = ireplace("REACTION", "reaction", rstring)
toolongcount = 0
toolong      = False
while ((len(rstring.split("reaction["))>1) and (not toolong)):
   msg2 = rstring.split("reaction[")
   msg3 = msg2[1].split(":reaction")[0]
   optiontag = msg3.split("]:")[0].strip()
   rr = msg3.split("]:")[1]
   rr = rr.replace("\t"," ")
   rr = rr.replace("\n"," ")
   rr = rr.replace('\xc2', ' ')
   rr = rr.replace('\xa0', ' ')
   rr = rr.replace(" + "," " + optiontag + " + ")
   rr = rr.replace("-->"," " + optiontag + " --> ")
   rr = rr + " " + optiontag
   convertreaction = "reaction: " + rr + " :reaction"
   rstring  = rstring.replace("reaction["+msg3+":reaction",convertreaction)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reaction[]: :reaction, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing reaction[]: :reaction, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


#######################
### parse reactions ###
#######################
### set how many entries to use ###
use_lowest_energy_esmiles = True
if ('useallentries' in rstring.lower()):
   use_lowest_energy_esmiles = False

asciiart_data       = []
toolongcount = 0
toolong      = False
reactions = []
rstring = ireplace("REACTION", "reaction", rstring)
while ((len(rstring.split("reaction:"))>1) and (not toolong)):
   msg2 = rstring.split("reaction:")
   reaction = msg2[1].split(":reaction")[0]
   rstring  = rstring.replace("reaction:"+reaction+":reaction","")
   reaction2 = addspaces_reaction(reaction.strip())
   reaction3 = parsetosmiles(reaction2)
   reactions.append(reaction3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reaction: :reaction, exiting.\n")
   pppfile.write("chemdb_fetch_reactions: too long parsing reaction: :reaction, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

if (len(reactions)<1):
   print "no reactions found, exiting"
else:
   print "reactions=",reactions

reaction_data = []
reactioncount = 0
erxnfile = open(wrkdir+"/"+tmperxn,'w')
addedtoerxnfile = False

for reaction in reactions:
   reactioncount += 1
   ooofile.write(eoln+eoln+eoln + "Reaction %d: " % (reactioncount)  + reaction.strip()+ eoln)
   pppfile.write(eoln+eoln+eoln + "Reaction %d: " % (reactioncount)  + reaction.strip()+ eoln)

   sslist = reaction.split("-->")
   left  = sslist[0].strip()
   left = left.replace("\t"," ")
   left = left.replace("\n"," ")
   #left = left.decode('ascii', 'replace')
   left = left.replace('\xc2', ' ')
   left = left.replace('\xa0', ' ')
   esmiles_reactants  = left.split(' + ')
   number_reactants = len(esmiles_reactants)

   if (len(sslist)>1):
      right = sslist[1].strip()
      right= right.replace("\t"," ")
      right= right.replace("\n"," ")
      right= right.replace('\xc2', ' ')
      right= right.replace('\xa0', ' ')
      esmiles_products   = right.split(' + ')
      number_products  = len(esmiles_products)
   else:
      esmiles_products = esmiles_reactants
      number_products  = number_reactants
      esmiles_reactants = []
      number_reactants = 0

   print
   print "esmiles_reactants=",esmiles_reactants
   print "esmiles_products =",esmiles_products
   print "numbers=",number_reactants,number_products

   ### get the reactants from the database ###
   imagemsg = ""
   asciiart_data       = []
   energy_reactants    = []
   enthalpy_reactants  = []
   entropy_reactants   = []
   solvation_type_reactants = []
   solvation_reactants      = []
   sitkoff_reactants        = []
   honig_reactants          = []

   npaths = 1
   path   = []
   mcount_reactants = []
   data_reactants = []
   for esmiles in esmiles_reactants:
      try:
         x = float(esmiles.split(None,1)[0])
         mcount_reactants.append(x)
         esmiles2 = esmiles.split(None,1)[1]
      except:
         mcount_reactants.append(1.0)
         esmiles2 = esmiles
      rows  = fetch_esmiles(hup,dbfile,table,esmiles2,False)
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      data_reactants.append(rows)
      npaths *= len(rows)
      path.append(len(rows))
      if (len(rows)>0):
         iupac    = rows[0][1]
         asciiart = stripWARNINGS(rows[0][34])
         asciiart_data.append("Compound = " + iupac + eoln + asciiart + eoln)
      if (len(rows)==0):
         missingesmiles = True
         if (submitmissingesmiles): 
            rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles2,False)
            rows  = fetch_esmiles(hup,dbfile,table,esmiles2) #adding to request table
            if (len(rows1)==0):
               ooofile.write(" - reactant not found: " + esmiles2 + " scheduled to be submitted."+ eoln)
               pppfile.write(" - reactant not found: " + esmiles2 + " scheduled to be submitted."+ eoln)
               submitesmiles.append(esmiles2)
            else:
               ooofile.write(" - reactant not found: " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
               pppfile.write(" - reactant not found: " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
         else:
            pppfile.write(" - reactant not found: " + esmiles2 + eoln)

   mcount_products = []
   data_products  = []
   for esmiles in esmiles_products:
      try:
         x = float(esmiles.split(None,1)[0])
         mcount_products.append(x)
         esmiles2 = esmiles.split(None,1)[1]
      except:
         mcount_products.append(1.0)
         esmiles2 = esmiles
      rows = fetch_esmiles(hup,dbfile,table,esmiles2,False)
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      data_products.append(rows)
      npaths *= len(rows)
      path.append(len(rows))
      if (len(rows)>0):
         iupac    = rows[0][1]
         asciiart = stripWARNINGS(rows[0][34])
         asciiart_data.append("Compound = " + iupac + eoln + asciiart + eoln)
      if (len(rows)==0):
         missingesmiles = True
         if (submitmissingesmiles):
            rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles2,False)
            print "ROWS1 = ",rows1
            rows = fetch_esmiles(hup,dbfile,table,esmiles2) #adding to request table
            if (len(rows1)==0):
               ooofile.write(" - product not found : " + esmiles2 + " scheduled to be submitted." + eoln)
               pppfile.write(" - product not found : " + esmiles2 + " scheduled to be submitted." + eoln)
               submitesmiles.append(esmiles2)
            else:
               ooofile.write(" - product not found : " + esmiles2 + " has already been scheduled to be submitted." + eoln)
               pppfile.write(" - product not found : " + esmiles2 + " has already been scheduled to be submitted." + eoln)
         else:
            ooofile.write(" - product not found : " + esmiles2 + eoln)
            pppfile.write(" - product not found : " + esmiles2 + eoln)
      

   pathcount = [0]*len(path)

   instance_paths_data = []
   ggresults = []
   for p in range(npaths):
      uniqueresult = True
      pathstr = " - instance %d: " % (p+1)
      msg0 = pathstr + "  "
      msg1 = pathstr
      msg1f = pathstr
      msg2 = pathstr
      msg3 = pathstr
      msg4 = pathstr
      msg4b = pathstr
      msg5  = pathstr
      imagemsg = ""
      energy_reactants = []
      enthalpy_reactants = []
      entropy_reactants = []
      solvation_type_reactants = []
      solvation_reactants = []
      sitkoff_reactants = []
      for ir in range(number_reactants):
         x = mcount_reactants[ir]
         molecule = data_reactants[ir][pathcount[ir]]
         if (model_correct):
            (tmp_enthalpy,tmp_entropy) = model_correct_frequencies(molecule)
         else:
            tmp_enthalpy = molecule[15]
            tmp_entropy  = molecule[16]
         energy_reactants.append(x*molecule[14])
         #enthalpy_reactants.append(x*molecule[15])
         #entropy_reactants.append(x*molecule[16])
         enthalpy_reactants.append(x*tmp_enthalpy)
         entropy_reactants.append(x*tmp_entropy)
         solvation_type_reactants.append(molecule[17])
         solvation_reactants.append(x*molecule[18])
         sitkoff_reactants.append(x*molecule[19])

         msg0 += "%.2f %s" % (x,molecule2esmiles(molecule))
         if (ir<(number_reactants-1)): msg0 += "\n" + pathstr + "+ "
         msg1 += "%.2f %s" % (x,molecule[1])
         if (ir<(number_reactants-1)): msg1 += " + "
         msg1f += "%.2f %s" % (x,molecule[2])
         if (ir<(number_reactants-1)): msg1f += " + "
         msg2 += "%.2f (Id=%d)" % (x,molecule[0])
         if (ir<(number_reactants-1)): msg2 += " + "
         if molecule[0] in badids: uniqueresult = False
         imagemsg += " %.2f %d " % (x,molecule[0])

      msg0 += "\n" + pathstr + "  --> "
      msg1 += " --> "
      msg1f += " --> "
      msg2 += " --> "
      imagemsg += " = "
      energy_products = []
      enthalpy_products = []
      entropy_products = []
      solvation_type_products = []
      solvation_products = []
      sitkoff_products = []
      for ip in range(number_products):
         x = mcount_products[ip]
         molecule = data_products[ip][pathcount[ip+number_reactants]]
         if (model_correct):
            (tmp_enthalpy,tmp_entropy) = model_correct_frequencies(molecule)
         else:
            tmp_enthalpy = molecule[15]
            tmp_entropy  = molecule[16]
         energy_products.append(x*molecule[14])
         #enthalpy_products.append(x*molecule[15])
         #entropy_products.append(x*molecule[16])
         enthalpy_products.append(x*tmp_enthalpy)
         entropy_products.append(x*tmp_entropy)
         solvation_type_products.append(molecule[17])
         solvation_products.append(x*molecule[18])
         sitkoff_products.append(x*molecule[19])

         msg0 += "%.2f %s" % (x,molecule2esmiles(molecule))
         if (ip<(number_products-1)): msg0 += "\n" + pathstr + "    + "
         msg1 += "%.2f %s" % (x,molecule[1])
         if (ip<(number_products-1)): msg1 += " + "
         msg1f += "%.2f %s" % (x,molecule[2])
         if (ip<(number_products-1)): msg1f += " + "
         msg2 += "%.2f (Id=%d)" % (x,molecule[0])
         if (ip<(number_products-1)): msg2 += " + "
         if molecule[0] in badids: uniqueresult = False
         imagemsg += " %.2f %d " % (x,molecule[0])

      delta_e = sum(energy_products) - sum(energy_reactants)
      delta_h = sum(enthalpy_products) - sum(enthalpy_reactants)
      delta_s = sum(entropy_products) - sum(entropy_reactants)
      delta_cosmo = sum(solvation_products) - sum(solvation_reactants)
      delta_sitkoff = sum(sitkoff_products) - sum(sitkoff_reactants)
      delta_solv = 0.0
      if (solvation_type_products[0]=='COSMO'):     delta_solv = -delta_cosmo + delta_sitkoff
      if (solvation_type_products[0]=='COSMO-SMD'): delta_solv = delta_cosmo
      #autokcal=27.2114*23.06
      #autokj  =27.2114*23.06*4.184
      autokcal= 627.509469
      autokj  = 2625.49962
      tempfac = 298.15/1000.0

      #msg3 += "Erxn(gas)=%8.3f kcal/mol " % (delta_e*autokcal)
      #msg3 += "Hrxn(gas)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal)
      #msg3 += "Grxn(gas)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal-tempfac*delta_s)
      #msg3 += "Delta Solvation=%8.3f kcal/mol " % (delta_solv)
      #msg3 += "Grxn(aq)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal-tempfac*delta_s + delta_solv)

      msg3 += "       Erxn(gas)"
      msg3 += "       Hrxn(gas)"
      msg3 += "       Grxn(gas)"
      msg3 += " Delta_Solvation"
      msg3 += "        Grxn(aq)"

      msg4 += " %15.3f" % (delta_e*autokcal)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s)
      msg4 += " %15.3f" % (delta_solv)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s + delta_solv)
      msg4 += "  -- in kcal/mol"

      msg4b += " %15.3f" % (delta_e*autokj)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj-tempfac*delta_s*4.184)
      msg4b += " %15.3f" % (delta_solv*4.184)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj-tempfac*delta_s*4.184 + delta_solv*4.184)
      msg4b += "  -- in kj/mol"

      msg5 += " %15.6f" % (delta_e)
      msg5 += " %15.6f" % ((delta_e+delta_h))
      msg5 += " %15.6f" % ((delta_e+delta_h)-tempfac*delta_s/autokcal)
      msg5 += " %15.6f" % (delta_solv/autokcal)
      msg5 += " %15.6f" % ((delta_e+delta_h)-tempfac*delta_s/autokcal + delta_solv/autokcal)
      msg5 += "  -- in Hartrees"

      msg6  = " %d" % (reactioncount)
      msg6 += " %15.3f" % (delta_e*autokcal*4.184)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal*4.184)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal*4.184-tempfac*delta_s*4.184)
      msg6 += " %15.3f" % (delta_solv*4.184)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal*4.184-tempfac*delta_s*4.184 + delta_solv*4.184)

      instance = []
      instance.append(delta_e)
      instance.append(delta_e+delta_h)
      instance.append(delta_e+delta_h -tempfac*delta_s/autokcal)
      instance.append(delta_solv/autokcal)
      instance.append(delta_e+delta_h-tempfac*delta_s/autokcal + delta_solv/autokcal)
      instance_paths_data.append(instance)

      ggcur =  (delta_e+delta_h)*autokcal-tempfac*delta_s + delta_solv
      for gg in ggresults:
         if (abs(gg-ggcur)<1.0e-3): uniqueresult = False
      ggresults.append(ggcur)

      if (uniqueresult):
         ooofile.write(msg2+eoln)
         ooofile.write(msg1+eoln)
         ooofile.write(msg1f+eoln)
         ooofile.write(msg0+eoln)
         ooofile.write(msg3+eoln)
         ooofile.write(msg4+eoln)
         ooofile.write(msg4b+eoln)
         ooofile.write(msg5+eoln)

         pppfile.write(msg2+eoln)
         pppfile.write(msg1+eoln)
         pppfile.write(msg1f+eoln)
         pppfile.write(msg0+eoln)
         pppfile.write(msg3+eoln)
         pppfile.write(msg4+eoln)
         pppfile.write(msg4b+eoln)
         pppfile.write(msg5+eoln)

         erxnfile.write(msg6+eoln)
         addedtoerxnfile = True

      ### shift the path ###
      done = False; i = 0
      while (not done):
         if (pathcount[i]<path[i]):
            pathcount[i] += 1
            if (pathcount[i]<path[i]):
               done = True
            else:
               pathcount[i] = 0
               i += 1
         if (i>=len(path)): done = True

   ### append the reaction data reaction_data ###
   reaction_data.append([reaction,instance_paths_data])

   ### print asciiart ###
   if (len(asciiart_data)>0):
      pppfile.write("-------------------------------------------------------------------------\n")
      for asciiart in asciiart_data:
         pppfile.write(asciiart)
         pppfile.write("-------------------------------------------------------------------------\n")

   if (useascii):
      if (len(asciiart_data)>0):
         ooofile.write("</pre>\n")
         ooofile.write("<pre style=\"font-size:0.5em;color:magenta\">\n")
         #ooofile.write("----------------------------------------------------------------------------\n")
         ooofile.write("-------------------------------------------------------------------------\n")
         for asciiart in asciiart_data:
            ooofile.write(asciiart)
            ooofile.write("-------------------------------------------------------------------------\n")
         ooofile.write("</pre>\n")
         ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")

   ### print png art ###
   else:
      if (imagemsg!=""):
         pngfilename = wrkdir + "/image-%d-%d.png" % (ddrand,imagecount)
         pngname     = "image-%d-%d" % (ddrand,imagecount)
         imagelist.append((pngfilename,pngname))
         imagecount += 1
         cmd9 = chemdb_reaction_image + imagemsg + " " + pngfilename
         try:
            result9 = subprocess.check_output(cmd9,shell=True)
         except:
            result9 = "\n\nchemdb_reaction_image failed and job was not submitted\n\n"
         ooofile.write("</pre>\n")
         ooofile.write('<img src="cid:%s"><br>\n' % pngname)
         ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")

erxnfile.close()



#### make dumb plots ####
if (addedtoerxnfile) and (len(reactions)>1):
   erxngnuplot  = wrkdir + "/erxn-%d.gnuplot" % ddrand
   erxndumb  = wrkdir + "/erxn-%d.dumb" % ddrand
   eedatafile = wrkdir+"/"+ tmperxn
   erxn = 'set output \"%s\"; set term dumb; set title \"Reaction Energies (kj/mol)\"; set xlabel \"reaction number\";  plot \"%s\" using 1:2 with lp pointtype 5 title \"Erxn(gas)\", \"%s\" using 1:3 with lp pointtype 8 title \"Hrxn(gas)\",\"%s\" using 1:4 with lp pointtype 7 title \"Grxn(gas)\",\"%s\" using 1:6 with lp pointtype 19 title \"Grxn(aq)\" ' % (erxndumb,eedatafile,eedatafile,eedatafile,eedatafile)

   with open(erxngnuplot,'w')  as f: f.write(erxn+eoln)
   os.system(gnuplot + erxngnuplot)
   with open(erxndumb,'r')  as f: msg = f.read(); pppfile.write(msg)
   if (useascii):
      ooofile.write("</pre>\n")
      ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")
      with open(erxndumb,'r')  as f: msg = f.read(); ooofile.write(msg)
      ooofile.write("</pre>\n")
      ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")
   try:
      os.unlink(erxngnuplot)
      os.unlink(erxndumb)
   except:
      print "Failed to delete temporary gnuplot files"

   ### PNG gnuplotting ####
   if (not useascii):
      erxngnuplot = wrkdir + "/erxn-%d.gnuplot" % ddrand
      erxnpng     = wrkdir + "/erxn-%d.png" % ddrand
      eedatafile  = wrkdir+"/"+ tmperxn
      erxn = 'set output \"%s\"; set term png; set grid; set title \"Comparison of Reactions\"; set xlabel \"reaction number\"; set ylabel \"reaction energies (kj/mol)\";  plot \"%s\" using 1:2 with lp pointtype 5 lw 2 title \"Erxn(gas)\", \"%s\" using 1:3 with lp pointtype 8 lw 2 title \"Hrxn(gas)\",\"%s\" using 1:4 with lp pointtype 7 lw 2 title \"Grxn(gas)\",\"%s\" using 1:6 with lp pointtype 19 lw 2 title \"Grxn(aq)\" ' % (erxnpng,eedatafile,eedatafile,eedatafile,eedatafile)

      with open(erxngnuplot,'w')  as f: f.write(erxn+eoln)
      os.system(gnuplot + erxngnuplot)
      try:
         os.unlink(erxngnuplot)
      except:
         print "Failed to delete temporary gnuplot files"

      ooofile.write("</pre>\n")
      pngname     = "image-%d-%d" % (ddrand,imagecount)
      imagelist.append((erxnpng,pngname))
      imagecount += 1
      ooofile.write('<br><center><img src="cid:%s" align="middle"></center><br>\n' % pngname)
      ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")


### print reaction tables ###
shift = 0
for reactionenumerate in reactionenumerates:
   (rr,ss) = maketable_from_reactionenumerate(reactionenumerate,reaction_data[shift:])
   shift += ss
   ooofile.write(rr)
   pppfile.write(rr)



#### print asciiart ###
#if (len(asciiart_data)>0):
#   ooofile.write("</pre>\n")
#   ooofile.write("<pre style=\"font-size:0.5em;color:magenta\">\n")
#   ooofile.write("----------------------------------------------------------------------------\n")
#   for asciiart in asciiart_data:
#      ooofile.write(asciiart)
#      ooofile.write("-------------------------------------------------------------------------\n")
#   ooofile.write("</pre>\n")
#   ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")

#### submit missing esmiles ####
if (submitmissingesmiles):
   ooofile.write("</pre><pre style=\"font-size:0.6em;color:red\">\n")
   nmach = len(submitmachines)
   i = 0
   for esmiles in submitesmiles:
    try:
      ### fetch the datafile ###
      datafile = fetch_esmiles_base_datafile(hup,dbfile,table,esmiles)
      esmiles1 = esmileswithid_to_esmiles(hup,dbfile,table,esmiles)
      esmiles1 = esmileswithname_to_esmiles(esmiles1.strip())
      print "esmiles=",esmiles,"  esmiles1=",esmiles1
      print "datafile=",datafile

      if (datafile=='') and (("ccsd(t)" in esmiles) or ("mp2" in esmiles)):
         mmsg = "Base calculation not found: not submitting esmiles="+esmiles+"\n"
         print mmsg
         ooofile.write(mmsg)
         pppfile.write(mmsg)
      else:
         vtag = ''
         if (nmach>0):
            msg4 = submit_esmiles(esmiles1,includerotation,datafile,emailfrom,submitmachines[i])
            i += 1
            i = i % nmach
         else:
            msg4 = submit_esmiles(esmiles1,includerotation,datafile,emailfrom)
         ooofile.write(eoln + msg4 + eoln)
         pppfile.write(eoln + msg4 + eoln)
    except:
      mmsg = "Error: not submitting esmiles="+esmiles+"\n"
      print mmsg
      ooofile.write(mmsg)
      pppfile.write(mmsg)
   listnwjobs = listnwjobs or (len(submitesmiles)>0)
   listnwjobs = False
   ooofile.write("</pre><pre style=\"font-size:0.6em;color:black\">\n")


#### submit_heat_formation ####
for esmiles in submit_heat_formation:
   cmd1 = chemdb_add_Hf + '"' + esmiles.strip() + '"'
   print "chemdb_add_Hf = " + cmd1
   try:
      result = subprocess.check_output(cmd1,shell=True)
   except:
      result = "\n\nchemdb_add_Hf failed and job was not submitted\n\n"
   ooofile.write(eoln+result+eoln)
   pppfile.write(eoln+result+eoln)
   print result


#### queuecheck ####
if (queuecheck):
   cmd1 = tnt_submit + " -i"
   print "queuecheck cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   pppfile.write(result)
   print result

#### listnwjobs ####
if (listnwjobs):
   cmd1 = queue_nwchem_em + " -a -s -m None"
   print "listnwjobs cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   pppfile.write(result)
   print result

#### fetchnwjob ####
for f in fetchnwjob:
   cmd1 = queue_nwchem_em + " -f %d -m %s " % (f,emailfrom)
   print "fetchwjob cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   pppfile.write(result)
   print result

#### pushnwjob ####
for aa in pushnwjob:
   with open(wrkdir + "/"+tmpsmi1,'w') as ff: ff.write(aa)
   cmd1 = queue_nwchem_em + " -w  " + wrkdir + "/"+ tmpsmi1
   print "pushwjob cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   pppfile.write(result)
   print result

##### report missingesmiles #####
if (missingesmiles):
   msg = "Several requests to Arrows were not successful."
else:
   msg = "All requests to Arrows were successful."
ooofile.write(eoln+msg+eoln)
pppfile.write(eoln+msg+eoln)
print eoln+msg+eoln


##### report image files #####
if (not useascii):
   msg = "imagelist: "
   for image in imagelist:
      msg += "%s %s " % (image[0],image[1])
   msg += ":imagelist"
   print eoln+msg+eoln


### add simple arrows logo 
#afile = open(arrowslogo,'r')
#alogo = afile.read()
#afile.close

if usesvg:
   ooofile.write(alogosvg)
else:
   if (useascii):
      ooofile.write(alogo)
   else:
      ooofile.write(alogowww)
   pppfile.write(alogo)

ooofile.write("</pre>\n")

ooofile.write("</html>\n")
ooofile.close()
pppfile.close()

#for molecule in rows:
#   print "Id=%6d iupac=%s csmiles=%s charge=%d mult=%d method=%s theory=%s basis=%s \tE=%14.6f  Enthalpy=%14.6f Entropy=%8.3f solvation=%8.3f sitkoff=%8.3f" % (molecule[0],molecule[1],molecule[4],molecule[12],molecule[13],molecule[9],molecule[10],molecule[11],molecule[14],molecule[15],molecule[16],molecule[18],molecule[19])


### remove temporary wrkdir files ###
try:
   os.unlink(wrkdir + "/"+tmpsmi1)
except:
   print "chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpsmi1

try:
   os.unlink(wrkdir + "/"+tmpsmi2)
except:
   print "chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpsmi2

try:
   os.unlink(wrkdir + "/"+tmpxyz1)
except:
   print "chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpxyz1

try:
   os.unlink(wrkdir + "/"+tmperxn)
except:
   print "chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmperxn

try:
   os.unlink(wrkdir + "/"+tmpnwout)
except:
   print "chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpnwout

