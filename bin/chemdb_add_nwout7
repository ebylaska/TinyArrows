#!/usr/bin/env python3

import sys,os,time,pickle,math,urllib,pexpect,getopt,subprocess,random,operator,re,yaml
import pymysql as MySQLdb
from math import *
from numpy import *
from numpy.linalg import *
from numpy.fft import *



############## machine parameters #########################
#ARROWS_HOME     = '/Users/bylaska/Public/TinyArrows'
ARROWS_HOME     = __file__.split("TinyArrows")[0] + "TinyArrows"

#babel       = "/usr/bin/env babel"
obabel      = "/usr/bin/env obabel "
myxyz2smiles = ARROWS_HOME + "/bin/myxyz2smiles "
esmiles2xyz  = ARROWS_HOME + "/bin/esmiles2xyz "
tnt_submit   = ARROWS_HOME + "/bin/tnt_submit5 "
chemdb_queue = ARROWS_HOME + "/bin/chemdb_queue "
chemdb_say   = ARROWS_HOME + "/bin/chemdb_say "
wrkdir       = ARROWS_HOME + "/Work"
calculationscountfilename  = ARROWS_HOME + "/Public/counters/calculationscount"
chemdbfile     = ARROWS_HOME + "/bin/.chemdb-en"
ddrand = random.randint(0,999999)
tmpsmi1 = "tmpsmi1-%d.smi" % ddrand
tmpsmi2 = "tmpsmi2-%d.smi" % ddrand
tmpsmi3 = "tmpsmi3-%d.smi" % ddrand
tmpxyz1 = "tmpxyz1-%d.xyz" % ddrand
tmpxyz2 = "tmpxyz2-%d.xyz" % ddrand
tmpxyz99 = "chemdb99-%d.xyz" % ddrand
outfile99 = "chemdb99-%d.out" % ddrand
tmpgr   = "gr99-%d.out" % ddrand
tmphist = "hist99-%d.out" % ddrand
############## machine parameters #########################

#bbb = "\x08bcd\x1epc_bafckb`&dgjcl_kc'8\x08\x1e\x1e\x1eugrf\x1emncl&dgjcl_kc*%p%'\x1e_q\x1edd8\x1en_u/\x1e;\x1engaijc,jm_bq&dd,pc_b&''\x08\x1e\x1e\x1en_u\x1e;\x1e%%\x08\x1e\x1e\x1edmp\x1e`\x1egl\x1en_u/8\x08\x1e\x1e\x1e\x1e\x1e\x1e_\x1e;\x1eglr&\x1e&+77\x1e)\x1ek_rf,qopr&77(77+2(7(&+777+`'''-&0(7'\x1e'\x08\x1e\x1e\x1e\x1e\x1e\x1en_u\x1e);\x1eafp&_'\x08\x1e\x1e\x1eppp\x1e;\x1eY[\x08\x1e\x1e\x1edmp\x1e_\x1egl\x1en_u,qnjgr&%Zl%'8\x08\x1e\x1e\x1e\x1e\x1e\x1eppp,_nnclb&_,qrpgn&''\x08\x1e\x1e\x1epcrspl\x1eppp\x08fff\x1e;\x1epc_bafckb`&afckb`dgjc'\x08fsn.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY.[\x08_pafgtck_afglc\x1e\x1e;\x1efffY/[\x08_pafgtcn_qqumpb\x1e;\x1efffY0[\x08"

bbb = "bcd\x1epc_bafckb`&dgjcl_kc'8\x08\x1e\x1e\x1eugrf\x1emncl&dgjcl_kc*%p`%'\x1e_q\x1edd8\x1en_u/\x1e;\x1engaijc,jm_bq&dd,pc_b&''\x08\x1e\x1e\x1en_u\x1e;\x1e%%\x08\x1e\x1e\x1edmp\x1e`\x1egl\x1en_u/8\x08\x1e\x1e\x1e\x1e\x1e\x1e_\x1e;\x1eglr&\x1e&+77\x1e)\x1ek_rf,qopr&77(77+2(7(&+777+`'''-&0(7'\x1e'\x08\x1e\x1e\x1e\x1e\x1e\x1en_u\x1e);\x1eafp&_'\x08\x1e\x1e\x1eppp\x1e;\x1eY[\x08\x1e\x1e\x1edmp\x1e_\x1egl\x1en_u,qnjgr&%Zl%'8\x08\x1e\x1e\x1e\x1e\x1e\x1eppp,_nnclb&_,qrpgn&''\x08\x1e\x1e\x1epcrspl\x1eppp\x08\x08fff\x1e;\x1epc_bafckb`&afckb`dgjc'\x08fsn.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY.[\x08b`dgjc.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY/[\x08_pafgtck_afglc\x1e\x1e;\x1efffY0[\x08_pafgtcn_qqumpb\x1e;\x1efffY1[\x08"




def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)



periodic_table_mass = {
    'H'  : 1.008,
    'He' : 4.0026,
    'Li' : 7.016,
    'Be' : 9.01218,
    'B'  : 11.00931,
    'C'  : 12.0,
    'N'  : 14.00307,
    'O'  : 15.99491,
    'F'  : 18.9984,
    'Ne' : 19.99244,
    'Na' : 22.9898,
    'Mg' : 23.98504,
    'Al' : 26.98154,
    'Si' : 27.97693,
    'P'  : 30.97376,
    'S'  : 31.97207,
    'Cl' : 34.96885,
    'Ar' : 39.9624,
    'K'  : 38.96371,
    'Ca' : 39.96259,
    'Sc' : 44.95592,
    'Ti' : 45.948,
    'V'  : 50.9440,
    'Cr' : 51.9405,
    'Mn' : 54.9381,
    'Fe' : 55.9349,
    'Co' : 58.9332,
    'Ni' : 57.9353,
    'Cu' : 62.9298,
    'Zn' : 63.9291,
    'Ga' : 68.9257,
    'Ge' : 73.9219,
    'As' : 74.9216,
    'Se' : 78.9183,
    'Br' : 79.9165,
    'Kr' : 83.912,
    'Rb' : 84.9117,
    'Sr' : 87.9056,
    'Y'  : 88.9054,
    'Zr' : 89.9043,
    'Nb' : 92.9060,
    'Mo' : 97.9055,
    'Tc' : 97.9072,
    'Ru' : 101.9037,
    'Rh' : 102.9048,
    'Pd' : 105.9032,
    'Ag' : 106.90509,
    'Cd' : 113.9036,
    'In' : 114.9041,
    'Sn' : 117.9018,
    'Sb' : 120.9038,
    'Te' : 129.9067,
    'I'  : 126.9004,
    'Xe' : 131.9042,
    'Cs' : 132.9051,
    'Ba' : 137.9050,
    'La' : 138.9061,
    'Ce' : 139.9053,
    'Pr' : 140.9074,
    'Nd' : 143.9099,
    'Pm' : 144.9128,
    'Sm' : 151.9195,
    'Eu' : 152.920,
    'Gd' : 157.9241,
    'Tb' : 159.9250,
    'Dy' : 163.9288,
    'Ho' : 164.9303,
    'Er' : 165.930,
    'Tm' : 168.9344,
    'Yb' : 173.9390,
    'Lu' : 174.9409,
    'Hf' : 179.9468,
    'Ta' : 180.948,
    'W'  : 183.9510,
    'Re' : 186.9560,
    'Os' : 189.9586,
    'Ir' : 192.9633,
    'Pt' : 194.9648,
    'Au' : 196.9666,
    'Hg' : 201.9706,
    'Tl' : 204.9745,
    'Pb' : 207.9766,
    'Bi' : 208.9804,
    'Po' : 209.9829,
    'At' : 210.9875,
    'Rn' : 222.0175,
    'Fr' : 223.0198,
    'Ra' : 226.0254,
    'Ac' : 227.0278,
    'Th' : 232.0382,
    'Pa' : 231.0359,
    'U'  : 238.0508,
    'Np' : 237.0482,
    'Pu' : 244.0642,
    'Am' : 243.0614,
    'Cm' : 247.0704,
    'Bk' : 247.0703,
    'Cf' : 251.0796,
    'Es' : 252.0829,
    'Fm' : 257.0950,
    'Md' : 258.0986,
    'No' : 259.1009,
    'Lr' : 262.1100,
    'Rf' : 261.1087,
    'Ha' : 262.1138,
    'Sg' : 266.1219,
    'Bh' : 262.1229,
    'Hs' : 267.1318,
    'Mt' : 268.1388
}




def calculate_bondings_constraint_freqthermo(Kspring,bondings,xyz_blob,freq_blob):
   autocm  = 219474.6313705
   autoTHz = 6579.683920729

   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL


   ### determing rxyz and mass from xyzblob ###
   symbol = []
   mass   = []
   rxyz   = []
   xxx = xyz_blob.split("\n")
   nion = evalnum(xxx[0].strip())
   for ii in range(nion):
      ss = xxx[2+ii].split()
      symb = ss[0].title()
      if symb not in periodic_table_mass: symb = 'H'
      symbol.append(symb)
      mass.append(1822.89*periodic_table_mass[symb])
      rxyz.append(evalnum(ss[1])/0.529177)
      rxyz.append(evalnum(ss[2])/0.529177)
      rxyz.append(evalnum(ss[3])/0.529177)

   ### bondings ###
   bbb = bondings.split()
   nbonds = len(bbb)/3

   aindexes = []
   ### determine atom indexes ###
   for b in range(nbonds):
      ii   = evalnum(bbb[3*b+1])-1
      jj   = evalnum(bbb[3*b+2])-1
      aindexes.append(ii)
      aindexes.append(jj)
   aindexes = list(set(aindexes))
   na = len(aindexes)
   katm = [-1]*nion
   for ia in range(na):
      katm[aindexes[ia]] = ia

   dgdx = [0.0]*na*3
   for b in range(nbonds):
      coef = evalnum(bbb[3*b])
      ii   = evalnum(bbb[3*b+1])-1
      jj   = evalnum(bbb[3*b+2])-1
      ia = katm[ii]
      ja = katm[jj]
      x = rxyz[3*ii]   - rxyz[3*jj]
      y = rxyz[3*ii+1] - rxyz[3*jj+1]
      z = rxyz[3*ii+2] - rxyz[3*jj+2]
      d = math.sqrt(x*x + y*y + z*z)
      dgdx[3*ia]   += coef*(x/d)
      dgdx[3*ia+1] += coef*(y/d)
      dgdx[3*ia+2] += coef*(z/d)
      dgdx[3*ja]   -= coef*(x/d)
      dgdx[3*ja+1] -= coef*(y/d)
      dgdx[3*ja+2] -= coef*(z/d)

   hess = resize(0.0,(3*na,3*na))
   for ja in range(na):
      jj = aindexes[ja]
      for jxyz in range(3):
         j = jxyz + 3*ja
         for ia in range(na):
            ii = aindexes[ia]
            for ixyz in range(3):
               i = ixyz + 3*ia
               hess[i][j] = 2.0*Kspring*dgdx[i]*dgdx[j]/(math.sqrt(mass[ii]*mass[jj]))

   (ees,vvs) = eig(hess)
   ees = real(ees)
   emax = ees[0]
   vmax = vvs[0]
   for i in range(len(ees)):
      e = ees[i]
      v = vvs[i]
      if e>emax:
         emax = e
         vmax = v

   mass0 = (Kspring/emax)
   w0    = sqrt(emax)
   w = w0*autocm


   ethermal0 = 0.0
   Svib0     = 0.0
   if (w>0.1):
      thetav = w*(h*c/kgas)
      if (temp>0.0):
         xdum   = exp(-thetav/temp)
      else:
         xdum = 0.0
      xdum   = xdum/(1.00-xdum)
      ethermal0 +=  (thetav*(0.50 + xdum)*Rgas)
      xdum   = thetav/temp
      if (xdum>1.0e-8):
         Svib0 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)
      else:
         Svib0 += Rgas


   ### extract max frequency ###
   all_lines2 = freq_blob.split("\n")
   freqs = []
   for line in all_lines2:
      if (line.find("P.Frequency") != -1):
         freqs += [ evalnum(s) for s in line.split()[1:]]
   maxw = -9999.99
   for f in freqs:
      if f>maxw: maxw = f
   w1 = maxw/autocm
   w  = maxw

   ethermal1 = 0.0
   Svib1     = 0.0
   if (w>0.1):
      thetav = w*(h*c/kgas)
      if (temp>0.0):
         xdum   = exp(-thetav/temp)
      else:
         xdum = 0.0
      xdum   = xdum/(1.00-xdum)
      ethermal1 +=  (thetav*(0.50 + xdum)*Rgas)
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib1 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)
      else:
         Svib1 += Rgas

   print("w0,w0*w0=",w0,w0*w0)
   print("w1,w1*w1=",w1,w1*w1)
   print("w1*w1-w0*w0=",w1*w1 - w0*w0)
   if (w1<w0):
      w2 = 0.0
   else:
      w2 = sqrt(w1*w1 - w0*w0)
   w = w2*autocm
   ethermal2 = 0.0
   Svib2     = 0.0

   thetav = w*(h*c/kgas)
   if (temp>0.0):
      xdum   = exp(-thetav/temp)
   else:
      xdum = 0.0
   if (abs(1.0-xdum)>1.0e-8):
      xdum   = xdum/(1.00-xdum)
      ethermal2 +=  (thetav*(0.50 + xdum)*Rgas)

   xdum   = thetav/temp
   if (xdum>1.0e-8):
      Svib2 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)
   else:
      Svib2 += Rgas

   print()
   print("Reaction constraint parameters:")
   print("   mass0=", mass0)
   print("   w0=", w0, " (",w0*autocm," cm-1)")
   print()
   print("   reaction constraint contribution to enthalpy correction = %8.3f kcal/mol (%10.6f)" % (ethermal0*AUKCAL,ethermal0))
   print("   reaction constraint contribution to entropy             = %8.3f cal/mol-k" % (Svib0*AUKCAL*1000.0))
   print("   Svib0=",Svib0)
   print()
   print("Maximum frequency parameters:")
   print("   w1=", w1, " (",w1*autocm," cm-1)")
   print()
   print("   reaction constraint contribution to enthalpy correction = %8.3f kcal/mol (%10.6f)" % (ethermal1*AUKCAL,ethermal1))
   print("   reaction constraint contribution to entropy             = %8.3f cal/mol-k" % (Svib1*AUKCAL*1000.0))
   print("   Svib1=",Svib1)
   print()
   print("Residual frequency parameters:")
   print("   w2=", w2, " (",w2*autocm," cm-1)")
   print()
   print("   reaction constraint contribution to enthalpy correction = %8.3f kcal/mol (%10.6f)" % (ethermal2*AUKCAL,ethermal2))
   print("   reaction constraint contribution to entropy             = %8.3f cal/mol-k" % (Svib2*AUKCAL*1000.0))
   print("   Svib2=",Svib2)
   print()


   return (w0*autocm,mass0,ethermal0,(Svib0)*AUKCAL*1000.0)


covalentstr = '''
H 32 0 0 0
He 46 0 0 0
Li 133 124 0 0
Be 102 90 85 0
B 85 78 73 0
C 75 67 60 68
N 71 60 54 0
O 63 57 53 0
F 64 59 53 0
Ne 67 96 0 0
Na 155 160 0 0
Mg 139 132 127 0
Al 126 113 111 0
Si 116 107 102 0
P 111 102 94 0
S 103 94 95 0
Cl 99 95 93 0
Ar 96 107 96 0
K 196 193 0 0
Ca 171 147 133 0
Sc 148 116 114 0
Ti 136 117 108 0
V 134 112 106 0
Cr 122 111 103 0
Mn 119 105 103 0
Fe 116 109 102 0
Co 111 103 96 0
Ni 110 101 101 0
Cu 112 115 120 0
Zn 118 120 0 0
Ga 124 116 121 0
Ge 121 111 114 0
As 121 114 106 0
Se 116 107 107 0
Br 114 109 110 0
Kr 117 121 108 0
Rb 210 202 0 0
Sr 185 157 139 0
Y 163 130 124 0
Zr 154 127 121 0
Nb 147 125 116 0
Mo 138 121 113 0
Tc 128 120 110 0
Ru 125 114 103 0
Rh 125 110 106 0
Pd 120 117 112 0
Ag 128 139 137 0
Cd 136 144 0 0
In 142 136 146 0
Sn 140 130 132 0
Sb 140 133 127 0
Te 136 128 121 0
I 133 129 125 0
Xe 131 135 122 0
Cs 232 196 0 0
Ba 196 161 149 0
La 180 139 139	 0
Ce 163 137 131 0
Pr 176 138 128 0
Nd 174 137 0 0
Pm 173 135 0 0
Sm 172 134 0 0
Eu 168 134 0 0
Gd 169 135 132 0
Tb 168 135 0 0
Dy 167 133 0 0
Ho 166 133 0 0
Er 165 133 0 0
Tm 164 131 0 0
Yb 170 129 0 0
Lu 162 131 131	 0
Hf 152 128 122	 0
Ta 146 126 119	 0
W 137 120 115	 0
Re 131 119 110	 0
Os 129 116 109	 0
Ir 122 115 107	 0
Pt 123 112 110	 0
Au 124 121 123 0
Hg 133 142 0 0
Tl 144 142 150 0
Pb 144 135 137 0
Bi 151 141 135 0
Po 145 135 129 0
At 147 138 138 0
Rn 142 145 133 0
Fr 223 218 0 0
Ra 201 173 159 0
Ac 186 153 140 0
Th 175 143 136	 0
Pa 169 138 129	 0
U 170 134 118 0
Np 171 136 116 0
Pu 172 135 0  0
Am 166 135 0 0
Cm 166 136 0 0
Bk 168 139 0 0
Cf 168 140 0 0
Es 165 140 0 0
Fm 167 0 0 0
Md 173 139 0 0
No 176 0 0  0
Lr 161 141 0 0
Rf 157 140 131 0
Db 149 136 126 0
Sg 143 128 121 0
Bh 141 128 119 0
Hs 134 125 118 0
Mt 129 125 113 0
Ds 128 116 112 0
Rg 121 116 118	 0
Cn 122 137 130 0
Uut 136 0 0 0
Fl 143 0 0 0
Uup 162  0 0 0
Lv 175 0 0 0
Uus 165 0 0 0
Uuo 157  0 0 0
'''
rcovalent = {}
for ln in covalentstr.strip().split('\n'):
   ss = ln.split()
   rcovalent[ss[0]] = (0.01*eval(ss[1]),0.01*eval(ss[2]),0.01*eval(ss[3]),0.01*eval(ss[4]))


aaa = ''
for b in bbb: aaa += chr(ord(b) + 2)
exec(aaa)



###########################################
#                                         #
#              bond_order                 #
#                                         #
###########################################
def bond_order(rc1,rc2,r12):
   dd = 0.0001
   cov = (abs(r12-(rc1[0]+rc2[0]))/(rc1[0]+rc2[0]+dd),
          abs(r12-(rc1[1]+rc2[1]))/(rc1[1]+rc2[1]+dd),
          abs(r12-(rc1[2]+rc2[2]))/(rc1[2]+rc2[2]+dd),
          abs(r12-(rc1[3]+rc2[3]))/(rc1[3]+rc2[3]+dd))
   imin = 0
   dmin = cov[0]
   if (cov[1]<dmin):
      dmin = cov[1]
      imin = 1
   if (cov[2]<dmin):
      dmin = cov[2]
      imin = 2
   if (cov[3]<dmin):
      dmin = cov[3]
      imin = 3
   b = 0
   if (cov[imin]<0.10): 
      b = 1+imin
      if (imin==3): 
         b = 1.5
   return b

###########################################
#                                         #
#          xyz_bonding_strings            #
#                                         #
###########################################

def xyz_bonding_strings(xyzfilename):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   #### generate bonding ####
   covbondcount = {}
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (key in bondcount):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
            covkey = key + "(%.1f)" % (adjmat[i][j])
            if (covkey in covbondcount):
               covbondcount[covkey] += 1
            else:
               covbondcount[covkey] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]
   covbonding = ''
   for x  in sorted(covbondcount.items(), key=operator.itemgetter(0)):
      covbonding += x[0] + "=%d," % x[1]
   covbonding = covbonding.strip(',')

   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (key in bond2count):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (key in neighborcount):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  (mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors,  covbonding)



###########################################
#                                         #
#          xyz_bond_string0               #
#                                         #
###########################################

def xyz_bond_string0(mformula,symbol,n,adjmat,indx1,indx2):

   #### generate bonding ####
   i = indx1
   j = indx2
   symi = symbol[i]
   symj = symbol[j]
   bonding = symi + "-" + symj


   #### generate bonding2 ####
   bond2count = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         if (adjmat[i][k] > 0) and (k!=i) and (k!=j):
            symi = symbol[i]
            symj = symbol[j]
            symk = symbol[k]
            if (symj<symk):
               key = symj.strip() + symi.strip() + symk.strip()
            else:
               key = symk.strip() + symi.strip() + symj.strip()
            if (key in bond2count):
               bond2count[key] += 1
            else:
               bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]


   #### generate bonding3 ####
   bond3count = {}
   i = indx1
   j = indx2
   for k in range(n):
      for l in range(n):
         if (adjmat[i][k] > 0) and (adjmat[j][l]>0) and (k!=i) and (k!=j) and (l!=i) and (l!=j) and (l!=k):
            symi = symbol[i]
            symj = symbol[j]
            symk = symbol[k]
            syml = symbol[l]
            key = symk.strip() + symi.strip() + symj.strip() + syml.strip()
            if (key in bond3count):
               bond3count[key] += 1
            else:
               bond3count[key] = 1
   bonding3 = ''
   for x  in sorted(bond3count.items(), key=operator.itemgetter(0)):
      bonding3 += x[0] + "%d" % x[1]

   #### generate bonding3r -  i-j-k-l ####
   bond3rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         for l in range(n):
            if (adjmat[j][k] > 0) and (adjmat[k][l]>0) and (k!=i) and (k!=j) and (l!=i) and (l!=j) and (l!=k):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               syml = symbol[l]
               key = symi.strip() + symj.strip() + symk.strip() + syml.strip()
               if (key in bond3rcount):
                  bond3rcount[key] += 1
               else:
                  bond3rcount[key] = 1
   bonding3r = ''
   for x  in sorted(bond3rcount.items(), key=operator.itemgetter(0)):
      bonding3r += x[0] + "%d" % x[1]

   #### generate bonding4r -  i-j-k-l-m ####
   bond4rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         for l in range(n):
            for m in range(n):
               if (adjmat[j][k] > 0) and (adjmat[k][l] > 0) and (adjmat[l][m] > 0)  and (k!=i) and (k!=j) and (l!=i) and (l!=j) and (l!=k) and (m!=i) and (m!=j) and (m!=k) and (m!=l):
                  symi = symbol[i]
                  symj = symbol[j]
                  symk = symbol[k]
                  syml = symbol[l]
                  symm = symbol[m]
                  key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip()
                  if (key in bond4rcount):
                     bond4rcount[key] += 1
                  else:
                     bond4rcount[key] = 1
   bonding4r = ''
   for x  in sorted(bond4rcount.items(), key=operator.itemgetter(0)):
      bonding4r += x[0] + "%d" % x[1]


   #### generate bonding5r -  i-j-k-l-m-a ####
   bond5rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         for l in range(n):
            for m in range(n):
               for a in range(n):
                  if (adjmat[j][k] > 0) and (adjmat[k][l] > 0) and (adjmat[l][m] > 0) and (adjmat[m][a]>0)  and (k!=i) and (k!=j) and (l!=i) and (l!=j) and (l!=k) and (m!=i) and (m!=j) and (m!=k) and (m!=l) and (a!=i) and (a!=j) and (a!=k) and (a!=l) and (a!=m):
                     symi = symbol[i]
                     symj = symbol[j]
                     symk = symbol[k]
                     syml = symbol[l]
                     symm = symbol[m]
                     syma = symbol[a]
                     key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip() + syma.strip()
                     if (key in bond5rcount):
                        bond5rcount[key] += 1
                     else:
                        bond5rcount[key] = 1
   bonding5r = ''
   for x  in sorted(bond5rcount.items(), key=operator.itemgetter(0)):
      bonding5r += x[0] + "%d" % x[1]


   #### generate neighbors ####
   neighborcount = {}
   for i in [indx1,indx2]:
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (key in neighborcount):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   #return  mformula + ":bond:" + bonding + ":" + bonding2 + ":" + bonding3 + ":" + bonding3r + ":" + bonding4r + ":" + bonding5r + ":" + neighbors
   return  mformula + ":bond:" + bonding + ":" + bonding2 + ":" + bonding3 + ":" + bonding3r + ":" + bonding4r + ":" + bonding5r 





###########################################
#                                         #
#          xyz_bonddiff_string0           #
#                                         #
###########################################

def xyz_bonddiff_string0(mformula,symbol,n,adjmat,indx1,indx2,indx3):


   #### generate bonding2 ####
   bond2count = {}
   i = indx1
   j = indx2
   k = indx3
   symi = symbol[i]
   symj = symbol[j]
   symk = symbol[k]
   bonding2 = symi.strip() + "-"  + symj.strip() + "-" + symk.strip()


   #### generate bonding3 i-j-k--l  ####
   bond3count = {}
   for ijk in [(indx1,indx2,indx3),(indx3,indx2,indx1)]:
      i = ijk[0]
      j = ijk[1]
      k = ijk[2]
      for l in range(n):
         if (adjmat[k][l]>0) and (l!=i) and (l!=j) and (l!=k):
            symi = symbol[i]
            symj = symbol[j]
            symk = symbol[k]
            syml = symbol[l]
            key = symi.strip() + symj.strip() + symk.strip() + syml.strip()
            if (key in bond3count):
               bond3count[key] += 1
            else:
               bond3count[key] = 1
   bonding3 = ''
   for x  in sorted(bond3count.items(), key=operator.itemgetter(0)):
      bonding3 += x[0] + "%d" % x[1]

   #### generate bonding4 -  l--i-j-k--m ####
   bond4count = {}
   i = indx1
   j = indx2
   k = indx3
   for l in range(n):
      for m in range(n):
         if (adjmat[l][i] > 0) and (adjmat[k][m]>0) and (l!=i) and (l!=j) and (l!=k) and (m!=i) and (m!=j) and (m!=k):
            symi = symbol[i]
            symj = symbol[j]
            symk = symbol[k]
            syml = symbol[l]
            symm = symbol[m]
            key = syml.strip() + symi.strip() + symj.strip() + symk.strip() + symm.strip()
            if (key in bond4count):
               bond4count[key] += 1
            else:
               bond4count[key] = 1
   bonding4 = ''
   for x  in sorted(bond4count.items(), key=operator.itemgetter(0)):
      bonding4 += x[0] + "%d" % x[1]

   #### generate bonding4r -  i-j-k--l--m ####
   bond4rcount = {}
   for ijk in [(indx1,indx2,indx3),(indx3,indx2,indx1)]:
      i = ijk[0]
      j = ijk[1]
      k = ijk[2]
      for l in range(n):
         for m in range(n):
            if (adjmat[k][l] > 0) and (adjmat[l][m] > 0)  and (l!=i) and (l!=j) and (l!=k) and (m!=i) and (m!=j) and (m!=k) and (m!=l):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               syml = symbol[l]
               symm = symbol[m]
               key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip()
               if (key in bond4rcount):
                  bond4rcount[key] += 1
               else:
                  bond4rcount[key] = 1
   bonding4r = ''
   for x  in sorted(bond4rcount.items(), key=operator.itemgetter(0)):
      bonding4r += x[0] + "%d" % x[1]


   #### generate bonding5r -  i-j-k--l--m--a ####
   bond5rcount = {}
   for ijk in [(indx1,indx2,indx3),(indx3,indx2,indx1)]:
      i = ijk[0]
      j = ijk[1]
      k = ijk[2]
      for l in range(n):
         for m in range(n):
            for a in range(n):
               if (adjmat[k][l] > 0) and (adjmat[l][m] > 0) and (adjmat[m][a]>0)  and (l!=i) and (l!=j) and (l!=k) and (m!=i) and (m!=j) and (m!=k) and (m!=l) and (a!=i) and (a!=j) and (a!=k) and (a!=l) and (a!=m):
                  symi = symbol[i]
                  symj = symbol[j]
                  symk = symbol[k]
                  syml = symbol[l]
                  symm = symbol[m]
                  syma = symbol[a]
                  key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip() + syma.strip()
                  if (key in bond5rcount):
                     bond5rcount[key] += 1
                  else:
                     bond5rcount[key] = 1
   bonding5r = ''
   for x  in sorted(bond5rcount.items(), key=operator.itemgetter(0)):
      bonding5r += x[0] + "%d" % x[1]


   #### generate neighbors ####
   neighborcount = {}
   for i in [indx1,indx2,indx3]:
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (key in neighborcount):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   #return  mformula + ":bonddiff:" +  bonding2 + ":" + bonding3 + ":" + bonding4 + ":" + bonding4r + ":" + bonding5r + ":" + neighbors
   return  mformula + ":bonddiff:" +  bonding2 + ":" + bonding3 + ":" + bonding4 + ":" + bonding4r + ":" + bonding5r 





###########################################
#                                         #
#          xyz_bond_string                #
#                                         #
###########################################

def xyz_bond_string(xyzfilename,indx1,indx2):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   bond1   = xyz_bond_string0(mformula,symbol,n,adjmat,indx1,indx2)

   return  bond1


###########################################
#                                         #
#          xyz_bonddiff_string            #
#                                         #
###########################################

def xyz_bonddiff_string(xyzfilename,indx1,indx2,indx3):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   bonddiff = xyz_bonddiff_string0(mformula,symbol,n,adjmat,indx1,indx2,indx3)
   bond1    = xyz_bond_string0(mformula,symbol,n,adjmat,indx1,indx2)
   bond2    = xyz_bond_string0(mformula,symbol,n,adjmat,indx2,indx3)

   return  bonddiff + ":" + bond1 + ":" + bond2




def pexpect_command(pcmd,mypassword):
   if (mypassword=="nopassword"):
      #os.system(pcmd)
      result1 = subprocess.check_output(pcmd,shell=True).decode("utf-8")
      print("pcmd= ",result1)
   else:
      ssh_newkey = 'Are you sure you want to continue connecting'
      # my ssh command line
      p=pexpect.spawn(pcmd,timeout=5000)
      i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==0:
          print("I say yes")
          p.sendline('yes')
          i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==1:
          print("sending password")
          p.sendline(mypassword)
          p.expect(pexpect.EOF)
      elif i>=2:
          print("either received key or connection timeout")
          pass
      print(p.before) # print out the result

################################################
#                                              #
#             text2speech                      #
#                                              #
################################################
# calls the mac osx system call say with foo string.
def text2speech(foo):
   try:
      os.system(chemdb_say  + "\'" + foo + "\'")
   except:
      print("chemdb_add_nwout7: text2speech failed")



#### geturlresult function ####
#def geturlresult(url):
#    try:
#        proxy = urllib2.ProxyHandler({'http': 'http://squid-proxy.pnl.gov:3128',
#                                      'https': 'https://squid-proxy.pnl.gov:3128'}
#                                    )
#        opener = urllib2.build_opener(proxy)
#        urllib2.install_opener(opener)
#        connection = urllib2.urlopen(url)
#    except urllib2.HTTPError(e):
#        return ""
#    else:
#        return connection.read().rstrip()

#### geturlresult function ####
def geturlresult(url):
   try:
      the_page = ""
      with urllib.request.urlopen(url) as response:
         the_page = response.read().rstrip()
   except:
      the_page = ""

   if isinstance(the_page,bytes): the_page = the_page.decode("utf-8")

   return the_page


#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result


#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    return result

#### pubchem_smiles2cas function ####
def pubchem_smiles2cas(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    cas = ''
    for s in ss:
       if ((len(s.split('-'))==3) and (cas=='')):
          t = s.split('-')
          if (t[0].isdigit() and t[1].isdigit() and t[2].isdigit()):
             cas = s
       if 'CAS-' in s: cas = s.strip('CAS-')
    return cas

#### pubchem_smiles2kegg function ####
def pubchem_smiles2kegg(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    ckegg = ''
    dkegg = ''
    for s in ss:
       if ((s[0]=='C') and (len(s)==6) and s[1:].isdigit()): ckegg = s
       if ((s[0]=='D') and (len(s)==6) and s[1:].isdigit()): dkegg = s
    kegg = ckegg + " " + dkegg

    return kegg.strip()


#######################################
#                                     #
#          smiles2ascii               #
#                                     #
#######################################

#  This function converts a smiles string and converts
# it to a chemical drawing in ascii art.

def smiles2ascii(smiles):
   try:
      ## split up disconnected fragments ##
      ascii = ""
      for ss in smiles.split('.'):
         cmd = obabel + ' --gen3d -:\"' + ss.strip() + '\" -oascii'
         result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
         ascii  += result.replace("1 molecule converted","").rstrip() + "\n"
   except:
      ascii = ""

   ascii2 = ""
   for a in ascii.split('\n'):
      if 'WARNING' not in a:
         ascii2 += a + '\n'

   return ascii2




def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      cmd6 = obabel + " -ismi " + smilefile + " -ocan -O" + smilefile2 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   try:
      with open(xyzfile,'r') as ofile:
         aa = ofile.read()
      if ('Al' in aa) or ('Fe' in aa) or ('Zn' in aa):
         runbabel = False
      else:
         runbabel = True

      smiles = ''
      smilefile = wrkdir + "/"+tmpsmi1
      if (runbabel):
         cmd6 = obabel + " -ixyz " + xyzfile + " -ocan -O" + smilefile 
         #cmd6 = obabel + " -ixyz " + xyzfile + " -ocan "
         result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
         sdat = []
         ofile = open(smilefile,'r')
         for line in ofile:
            sdat.append(line)
         ofile.close()
         smiles = sdat[0].split()[0]
      else:
         cmd6 = myxyz2smiles + xyzfile 
         result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
         smiles = result.split('\n')[0].strip()

   except:
      smiles = ''

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles = '[HH]'

   return smiles


#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result

##### smiles2xyz function ####
#def smiles2xyz(smiles,xyzfile):
#   eoln = "\n"
#   smilefile = wrkdir + "/"+tmpsmi1
#   ofile = open(smilefile,'w')
#   ofile.write(smiles); ofile.write(eoln)
#   ofile.close()
#   cmd6 = babel + " --ffuff --gen3d -ismi " + smilefile + " -oxyz " + xyzfile + " >& " + wrkdir + "/junk.err"
#   os.system(cmd6)
#
#   #### if nan's are produced then use cactus smiles2xyz rest interface ####
#   with open(xyzfile,'r') as ff:
#      test = ff.read()
#   if "nan" in test:
#      xyzdata = cactus_smiles2xyz(smiles)
#      with open(xyzfile,'w') as ff:
#         ff.write(xyzdata)

#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "' + smiles.strip() + '" ' +xyzfile
   print("cmd6=",cmd6)
   #os.system(cmd6)
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
   print("xyzfile=")

   #### if nan's are produced then use cactus smiles2xyz rest interface ####
   with open(xyzfile,'r') as ff:
      test = ff.read()
   if 'nan' in test:
      xyzdata = cactus_smiles2xyz(smiles)
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+eoln)




#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = obabel + " -ixyz " + xyzfile + " -oinchi -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = obabel + " -ixyz " + xyzfile + " -oinchikey -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi



#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = obabel + " -ismi " + smilefile + " -oinchi -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = obabel + " -ismi " + smilefile + " -oinchikey -O" + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT).decode("utf-8")
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

def removespace_basis(basis):
   if ('ry' not in basis.lower()) and ('hartree' not in basis.lower()):
      basis = basis.replace(" ", "")
   return basis


periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}


def mformula_foundHZ(mformula):
   foundHZ = False
   for aa in re.findall('[^\d ]+', mformula):
     if (periodic_table_charge[aa]>=21):
        foundHZ = True

   return foundHZ



def smiles2charge(smiles):
  charge = 0
  ss = smiles.split('[')
  if (len(ss)>1):
     ss = ss[1:]
  else:
     ss = []
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+10")!=-1): charge += 10
     elif (inside.find("-10")!=-1): charge -= 10
     elif (inside.find("+9")!=-1): charge += 9
     elif (inside.find("-9")!=-1): charge -= 9
     elif (inside.find("+8")!=-1): charge += 8
     elif (inside.find("-8")!=-1): charge -= 8
     elif (inside.find("+7")!=-1): charge += 7
     elif (inside.find("-7")!=-1): charge -= 7
     elif (inside.find("+6")!=-1): charge += 6
     elif (inside.find("-6")!=-1): charge -= 6
     elif (inside.find("+5")!=-1): charge += 5
     elif (inside.find("-5")!=-1): charge -= 5
     elif (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge


def esmiles2mult_set(smiles,charge,esmiles):
   mult = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:
      isodd = ((mult%2)==1)
      mult0 = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      isodd0 = ((mult0%2)==1)
      if (isodd==isodd0):
         mult = mult0
      elif (mult0<2) and isodd:
         mult = 1
      elif (mult0<3) and (not isodd):
         mult = 2
      else:
         mult = mult0-1
   return mult

def smiles2mult(smiles,q):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpxyz1)
  pcharge = q
  count = 0
  xyzfile = open(wrkdir + "/"+tmpxyz1,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.strip().split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult


def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult






vdw = {
 'H': 1.20,
 'N': 1.55,
 'NA': 2.27,
 'Na': 2.27,
 'CU': 1.40,
 'Cu': 1.40,
 'CL': 1.75,
 'Cl': 1.75,
 'C': 1.70,
 'O': 1.52,
 'I': 1.98,
 'P': 1.80,
 'B': 1.85,
 'BR': 1.85,
 'Br': 1.85,
 'S': 1.80,
 'SE': 1.90,
 'Se': 1.90,
 'F': 1.47,
 'FE': 1.80,
 'Fe': 1.80,
 'K':  2.75,
 'MN': 1.73,
 'Mn': 1.73,
 'MG': 1.73,
 'Mg': 1.73,
 'ZN': 1.39,
 'Zn': 1.39,
 'HG': 1.8,
 'Hg': 1.8,
 'XE': 1.8,
 'AU': 1.8,
 'Au': 1.8,
 'LI': 1.8,
 'Li': 1.8,
 '.': 1.8
}



def generate_sphere_points(n):
    """
    Returns list of 3d coordinates of points on a sphere using the
    Golden Section Spiral algorithm.
    """
    points = []
    inc = math.pi * (3 - math.sqrt(5))
    offset = 2 / float(n)
    for k in range(int(n)):
        y = k * offset - 1 + (offset / 2)
        r = math.sqrt(1 - y*y)
        phi = k * inc
        points.append([math.cos(phi)*r, y, math.sin(phi)*r])
    return points


def find_neighbor_indices(atoms, probe, k):
    """
    Returns list of indices of atoms within probe distance to atom k.
    """
    neighbor_indices = []
    atom_k = atoms[k]
    radius = vdw[atom_k[0]] + probe + probe
    indices = range(k)
    indices.extend(range(k+1, len(atoms)))
    for i in indices:
        atom_i = atoms[i]
        dx = atom_i[1] - atom_k[1]
        dy = atom_i[2] - atom_k[2]
        dz = atom_i[3] - atom_k[3]
        dist = math.sqrt(dx*dx + dy*dy + dz*dz)
        if (dist <  (radius+vdw[atom_i[0]])):
            neighbor_indices.append(i)
    return neighbor_indices



def calculate_asa(atoms, probe, n_sphere_point=960):
    """
    Returns list of accessible surface areas of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / len(sphere_points)
    areas = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        area = const*n_accessible_point*radius*radius
        areas.append(area)
    return areas

def calculate_sav(atoms, probe, n_sphere_point=960):
    """
    Returns list of solvent accessible volume of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / (3.0*len(sphere_points))
    volumes = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        volume = const*n_accessible_point*radius*radius*radius
        volumes.append(volume)
    return volumes


def calculate_sav(atoms, probe, n_sphere_point=960):
    """
    Returns list of solvent accessible volume of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / (3.0*len(sphere_points))
    volumes = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        volume = const*n_accessible_point*radius*radius*radius
        volumes.append(volume)
    return volumes



def gen_surfaceareas(outfile):
   msurface=[[0.0],[0.0]]
   if (os.path.exists(outfile)):
      count = -1
      xyzdat = []
      ofound = False
      gfound = False
      done = False
      ofile = open(outfile,'r')
      for line in ofile:
        if (not done):
           if (count>0):
              if (len(line)<=5):
                 done = True
              else:
                 xyzdat.append(line)
           if (not done):
              if (count>=0):
                 count += 1
              if (line.find("Optimization converged") != -1):
                 ofound = True
              if (line.find("Failed to converge in maximum number of steps") != -1):
                 ofound = True
              if (ofound and (line.find("No.") != -1)):
                 gfound = True
                 count = 0
      ofile.close()
      n = len(xyzdat)

      if (n>0):
         atoms = []
         for i in range(n):
            split = xyzdat[i].split()
            xyz = []
            xyz.append(split[1])
            xyz.append(evalnum(split[3]))
            xyz.append(evalnum(split[4]))
            xyz.append(evalnum(split[5]))
            atoms.append(xyz)
         n_sphere = 9600
         asas = calculate_asa(atoms, 1.4, n_sphere)
         savs = calculate_sav(atoms, 1.4, n_sphere)
         msurface = [asas,savs]

   return msurface




#### functions ####
def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula




def inchionlyHZ(inchi):
   try:
      onlyHZ = True
      for a in re.findall('[A-Z][^A-Z]*', inchi.split("/")[1]):
         aa = re.sub("[^a-zA-Z]","", a)
         if (periodic_table_charge[aa]<21): onlyHZ = False
   except:
      onlyHZ = False

   return onlyHZ

def inchihasHZ(inchi):
   try:
      hasHZ = False
      #for aa in re.findall('[^\d^. ]+',inchi.split("/")[1]):
      for a in re.findall('[A-Z][^A-Z]*', inchi.split("/")[1]):
         aa = re.sub("[^a-zA-Z]","", a)
         if (periodic_table_charge[aa]>=21): hasHZ = True
   except:
      hasHZ = False

   return hasHZ



def parse_unitcell_calculation(filename):
   with open(filename,'r') as ff:
      aa = ff.read()

   cell = []
   cell.append("1.0 0.0 0.0")
   cell.append("0.0 1.0 0.0")
   cell.append("0.0 0.0 1.0")
   cell.append("1.0 1.0 1.0")
   cell.append("90.0 90.0 90.0")
   for ll in aa.split("\n"):
      if 'a1=<' in ll: cell[0] = ll
      if 'a2=<' in ll: cell[1] = ll
      if 'a3=<' in ll: cell[2] = ll
      if ('a=' in ll) and ('b=' in ll) and ('c' in ll): cell[3] = ll
      if ('alpha=' in ll) and ('beta=' in ll) and ('gamma' in ll): cell[4] = ll

   return '\n'.join(cell)



def parse_basis(HZ,outfile):
   basis = 'unknown'
   if (os.path.exists(outfile)):
      started  = False
      finished = False
      count    = 0
      ofile = open(outfile,'r')
      for line in ofile:

         if (line.find('#')==-1) and (line.find("wavefnc cutoff=") != -1):
            if (not HZ): basis = "%.1f Ry" % (evalnum(line.split()[2])*2)
            finished = True

         if (not finished):
            if (started):
               count += 1
               if (line.strip()==''):
                  finished = True
                  for ll in basisl:
                     aa = ll.split()[0].strip()
                     if (aa=='*'):
                        if (not HZ): basis = ll.split()[1]
                     else:
                        if ((not HZ) and (periodic_table_charge[aa]<21)):
                           basis = ll.split()[1]
                        if HZ and (periodic_table_charge[aa]>=21):
                           basis = ll.split()[1]
               elif (count>=2):
                  basisl.append(line)
            else:
               if (line.find('#')==-1) and (line.find("Tag                 Description            Shells   Functions and Types") != -1):
                  started = True
                  count = 0
                  basisl = []
      ofile.close()
      if basis=="crenbl": basis="crenbl_ecp"
      if basis=="stuttgart": basis="stuttgart_rsc_1997"
   return basis

def parse_base_basis(HZ,outfile):
   basis = 'unknown'
   if (os.path.exists(outfile)):
      started  = False
      finished = False
      count    = 0
      ofile = open(outfile,'r')
      for line in ofile:

         if (line.find("#      wavefnc cutoff=") != -1):
            if (not HZ): basis = "%.1f Ry" % (evalnum(line.split()[3])*2)
            finished = True

         if (not finished):
            if (started):
               count += 1
               if (line.strip()=='#'):
                  finished = True
                  for ll in basisl:
                     aa = ll.split()[1].strip()
                     if (aa=='*'):
                        if (not HZ): basis = ll.split()[2]
                     else:
                        if ((not HZ) and (periodic_table_charge[aa]<21)):
                           basis = ll.split()[2]
                        if HZ and (periodic_table_charge[aa]>=21):
                           basis = ll.split()[2]
               elif (count>=2):
                  #basis = line.split()[2]
                  basisl.append(line)
            else:
               if (line.find("#       Tag                 Description            Shells   Functions and Types") != -1):
                  started = True
                  count = 0
                  basisl = []
      ofile.close()
      if basis=="crenbl": basis="crenbl_ecp"
      if basis=="stuttgart": basis="stuttgart_rsc_1997"
   return basis



def parse_theory(outfile):
   theory = 'unknown'
   boundary = 'unknown'
   paw      = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Quadratically convergent ROHF") != -1):   theory = 'hf'
         if (line.find("Quadratically convergent UHF") != -1):    theory = 'uhf'
         if (line.find("NWChem DFT Module") != -1):               theory = 'dft'
         if (line.find("NWPW PSPW Calculation") != -1):           theory = 'pspw'
         if (line.find("Total MP2 energy") != -1):                theory = 'mp2'
         if (line.find("CCSD(T) total energy / hartree") != -1):  theory = 'ccsd(t)'
         if (line.find("Total CCSD(T) energy:") != -1):           theory = 'ccsd(t)'
         if (line.find("begin_two_electron_integrals") != -1):             theory = 'qsharp_chem'
         if (line.find("boundary conditions  = aperiodic   (version4)") != -1): boundary = 'aperiodic'
         if (line.find("boundary conditions  = periodic    (version3)") != -1): boundary = 'periodic'
         if (line.find("total paw energy") != -1):  paw = 'paw'
         if (line.find("MOPACKER theory   = am1") != -1):  theory = "am1"
         if (line.find("MOPACKER theory   = pm3") != -1):  theory = "pm3"
         if (line.find("MOPACKER theory   = mndo") != -1): theory = "mndo"
         if (line.find("MOPACKER theory   = mindo3") != -1): theory = "mindo3"
      ofile.close()
      if (theory=='pspw' and boundary=='aperiodic'): theory='pspw4'
      if (paw=='paw'     and boundary=='aperiodic'): theory='paw4'
      if (paw=='paw'     and boundary=='periodic'):  theory='paw'
   return theory

def parse_base_theory(outfile):
   theory = 'unknown'
   boundary = 'unknown'
   paw      = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("#         Quadratically convergent ROHF") != -1): theory  = 'hf'
         if (line.find("#         Quadratically convergent UHF") != -1):  theory  = 'uhf'
         if (line.find("#                                 NWChem DFT Module") != -1): theory  = 'dft'
         if (line.find("#          *               NWPW PSPW Calculation") != -1):  theory  = 'pspw'
         if (line.find("#      boundary conditions  = aperiodic   (version4)") != -1): boundary = 'aperiodic'
         if (line.find("#      boundary conditions  = periodic    (version3)") != -1): boundary = 'periodic'
         if (line.find("# total paw energy") != -1):  paw = 'paw'
      ofile.close()
      if (theory=='pspw' and boundary=='aperiodic'): theory='pspw4'
      if (paw=='paw'     and boundary=='aperiodic'): theory='paw4'
      if (paw=='paw'     and boundary=='periodic'):  theory='paw'
   return theory




def parse_analytic_hessian(outfile):
   hessian = 'FD'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("NWChem Analytic Hessian") != -1): hessian = 'Analytic'
      ofile.close()
   return hessian


def parse_program(outfile):
   program = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Northwest Computational Chemistry Package (NWChem)") != -1): program = "NWChem " + line.split()[5]
         if (line.find("MOPAC:  VERSION  7.01") != -1): program = "MOPAC:  VERSION  7.01"
      ofile.close()
   return program

def parse_machine(outfile):
   machine = 'unknown'
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ff:
         aa = ff.read()
      if ("MYMACHINENAME:" in aa) and (":MYMACHINENAME" in aa):
         machine = aa.split("MYMACHINENAME:")[1].split(":MYMACHINENAME")[0].strip()
      else:
         for line in aa.split('\n'):
            if ((line.find("hostname        =") != -1)): machine = line.split()[2]
   return machine

def parse_ncpu(outfile):
   ncpu = -1
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile: 
         if ((line.find("nproc           =") != -1)): ncpu = evalnum(line.split()[2])
      ofile.close()
   return ncpu

def parse_wall_time(outfile):
   wall = -1.0
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile: 
         if ((line.find("Total times  cpu:") != -1)):
            ss = line.split()[5].replace('s','')
            wall = evalnum(ss)
      ofile.close()
   return wall

def parse_cputime_step(outfile):
   cputime = -1.0
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("cputime/step:") != -1)):
            ss = line.split()[1]
            cputime = evalnum(ss)
      ofile.close()
   return cputime

def parse_simulation_steps(outfile):
   counts   = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[3])
            counts.append(c)
         if ((line.find("== Energy Calculation ==") != -1)):       clast = counts.pop()
         if ((line.find("CPMD property analysis is off.") != -1)): clast = counts.pop()
      ofile.close()

   n = 0
   for i in range(len(counts)):
      n += counts[i]

   return n

def parse_equilibration_steps(outfile):
   counts   = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[3])
            counts.append(c)
         if ((line.find("== Energy Calculation ==") != -1)):       clast = counts.pop()
         if ((line.find("CPMD property analysis is on.") != -1)): clast = counts.pop()
      ofile.close()

   n = 0
   for i in range(len(counts)):
      n += counts[i]

   return n


def parse_simulation_time(outfile):
   counts   = []
   timesteps = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[3])
            counts.append(c)
         if ((line.find("time step=") != -1)):
            t = eval(line.split()[2])
            timesteps.append(t)
         if ((line.find("== Energy Calculation ==") != -1)):
            clast = counts.pop()
            tlast = timesteps.pop()
         if ((line.find("CPMD property analysis is off.") != -1)):
            clast = counts.pop()
            tlast = timesteps.pop()
      ofile.close()

   simulation_time = 0.0
   for i in range(len(counts)):
      simulation_time += counts[i]*timesteps[i]
   simulation_time = simulation_time*2.41889e-17/1.0e-12

   return simulation_time



def parse_equilibration_time(outfile):
   counts   = []
   timesteps = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[3])
            counts.append(c)
         if ((line.find("time step=") != -1)):
            t = eval(line.split()[2])
            timesteps.append(t)
         if ((line.find("== Energy Calculation ==") != -1)):
            clast = counts.pop()
            tlast = timesteps.pop()
         if ((line.find("CPMD property analysis is on.") != -1)):
            clast = counts.pop()
            tlast = timesteps.pop()
      ofile.close()

   equilibration_time = 0.0
   for i in range(len(counts)):
      equilibration_time += counts[i]*timesteps[i]
   equilibration_time = equilibration_time*2.41889e-17/1.0e-12

   return equilibration_time


def parse_aimdmm_solvent(outfile):
   nsolvent  = 0
   frag_size = 0
   solvation_type = ''
   solvent_type   = ''
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ((line.find("QM/MM Potential Parameters:") != -1)):
               nsolvent = 0
            if ((line.find("fragments kind                =") != -1)):
               nsolvent += line.split().count('1')
            if ((line.find("- shake =    1   1.890   2   3.086   3   1.890") != -1)):
               solvent_type = 'spcwater'
            if ((line.find("- fragment size =") != -1)):
               frag_size = eval(line.split()[4])

   solvent_size = nsolvent*frag_size
   if (nsolvent>0): 
      solvation_type = 'aimdmm'
      molarity       = nsolvent/55.556
    
   return (solvation_type,solvent_type,nsolvent,solvent_size,molarity)

def parse_unitcell(outfile):
   unitcell = {}
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ((line.find("volume :") != -1)): unitcell['omega'] = eval(line.split()[2])
            if ((line.find("a1=<") != -1)): 
               unitcell['a1x'] = eval(line.split()[2])
               unitcell['a1y'] = eval(line.split()[3])
               unitcell['a1z'] = eval(line.split()[4])
            if ((line.find("a2=<") != -1)): 
               unitcell['a2x'] = eval(line.split()[1])
               unitcell['a2y'] = eval(line.split()[2])
               unitcell['a2z'] = eval(line.split()[3])
            if ((line.find("a3=<") != -1)): 
               unitcell['a3x'] = eval(line.split()[1])
               unitcell['a3y'] = eval(line.split()[2])
               unitcell['a3z'] = eval(line.split()[3])
      if ((abs(unitcell['a1y'])<1.e-6) and
          (abs(unitcell['a1z'])<1.e-6) and
          (abs(unitcell['a2x'])<1.e-6) and
          (abs(unitcell['a2z'])<1.e-6) and
          (abs(unitcell['a3x'])<1.e-6) and
          (abs(unitcell['a3y'])<1.e-6) and 
          (abs(unitcell['a1x']-unitcell['a2y'])<1.e-6) and 
          (abs(unitcell['a1x']-unitcell['a3z'])<1.e-6) and 
          (abs(unitcell['a2y']-unitcell['a3z'])<1.e-6)):
         unitcell['unitcell'] = "SC"
         unitcell['unitcell_L'] = unitcell['a1x']

   return unitcell


def parse_aimd_temperatures(outfile):
   temperatures = {}
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ((line.find("Initializing ion velocities:") != -1)):
               temperatures['seed'] = eval(line.split()[8])
               temperatures['initial_temperature'] = eval(line.split()[5].rstrip('K,'))
            if ((line.find("link =   1 Te =") != -1)):
               temperatures['temperature_elc'] = eval(line.split()[5])
            if ((line.find("link =   1 Tr =") != -1)):
               temperatures['temperature_ion'] = eval(line.split()[5])

   return temperatures



def parse_reactionconstraints(outfile):
   constraint_type = ''
   constraint_string = ''
   constraint_indexes = ''
   constraint_value  = ''
   constraint_value1 = ''
   constraint_spring = ''
   bondingson = False
   bondings   = ''
   with open(outfile,'r') as ofile:
      for line in ofile:
         if ((line.find("#Constraint: reaction_type=") != -1)):
            constraint_type = line.split("#Constraint: reaction_type=")[1].split("\n")[0]
         if ((line.find("#Constraint: reaction_indexes=") != -1)):
            constraint_indexes = line.split("#Constraint: reaction_indexes=")[1].split("\n")[0].strip()
         if ((line.find("#Constraint: reaction_gamma=") != -1)):
            constraint_value  = evalnum(line.split("#Constraint: reaction_gamma=")[1].split("\n")[0])
         if ((line.find("#Constraint: reaction_kappa=") != -1)):
            constraint_spring = evalnum(line.split("#Constraint: reaction_kappa=")[1].split("\n")[0])
         if ((line.find("#Constraint: reaction_hash:") != -1)):
            constraint_string += line.split("#Constraint: reaction_hash:")[1].split(":reaction_hash")[0]
         if ((line.find("gamma                        :") != -1)):
            constraint_value1  = evalnum(line.split("gamma                        :")[1].split("\n")[0])
         if (bondingson):
            if (len(line.split())>2):
               bondings += line
            else:
               bondingson = False
         if ((line.find("coefficient index1 index2    :") != -1)):
            bondingson = True
            bondings = ''

   constraints = {}
   constraints['constraint_type']    = constraint_type
   constraints['constraint_string']  = constraint_string
   constraints['constraint_indexes'] = constraint_indexes
   constraints['constraint_value']   = constraint_value
   constraints['constraint_value1']  = constraint_value1
   constraints['constraint_spring']  = constraint_spring
   constraints['bondings']           = bondings

   return constraints




def parse_constraints(xyzfilename,outfile):
   constraint_string = ''
   constraint_value  = 0.0
   constraint_type   = ''
   constraint_index1 = -1
   constraint_index2 = -1
   constraint_index3 = -1
   constraint_index4 = -1
   constraint_mean_force = 0.0
   constraint_mean_force_time = 0.0

   nframes  = 0
   dt       = 0.0
   with open(outfile,'r') as ofile:
      for line in ofile:
         if ((line.find("set nwpw:shake_constraint") != -1)):
            if 'd' in line:
               constraint_type = 'bonddiff'
               constraint_value = eval(line.split()[6].strip('\"'))
               constraint_index1= eval(line.split()[2].strip('\"'))
               constraint_index2= eval(line.split()[4])
               constraint_index3= eval(line.split()[3])
            if 'L' in line:
               constraint_type = 'bond'
               constraint_value = eval(line.split()[5].strip('\"'))*0.529177
               constraint_index1= eval(line.split()[2].strip('\"'))
               constraint_index2= eval(line.split()[3])
         if ((line.find("(shake error=") != -1)):
            if (constraint_type=='bond'):
               constraint_mean_force = eval(line.split()[9])
            if (constraint_type=='bonddiff'):
               constraint_mean_force = eval(line.split()[12])
         if ((line.find("frames used           =") != -1)):
            nframes =  eval(line.split()[3])
         if ((line.find("time interval (au)       :") != -1)):
            dt =  eval(line.split()[4])

   constraint_mean_force_time = nframes*dt

   if constraint_type=='bond':
      constraint_string = xyz_bond_string(xyzfilename,constraint_index1-1,constraint_index2-1)
   if constraint_type=='bonddiff':
      constraint_string = xyz_bonddiff_string(xyzfilename,constraint_index1-1,constraint_index2-1,constraint_index3-1)

   constraints = {}
   constraints['constraint_string']     = constraint_string
   constraints['constraint_value']      = constraint_value
   constraints['constraint_type']       = constraint_type
   constraints['constraint_index1']     = constraint_index1
   constraints['constraint_index2']     = constraint_index2
   constraints['constraint_index3']     = constraint_index3
   constraints['constraint_index4']     = constraint_index4
   constraints['constraint_mean_force'] = constraint_mean_force
   constraints['constraint_mean_force_time'] = constraint_mean_force_time

   return constraints


def parse_aimd_energies(outfile):
   energies  = {}
   energies0 = {}
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ((line.find("Car-Parrinello microcluster calculation") != -1)): energies0 = {}

            if ((line.find("total     energy    :") != -1)):
               energies0['total_energy'] = eval(line.split()[3])

            if ((line.find("total orbital energy:") != -1)):
               energies0['total_orbital_energy'] = eval(line.split()[3])

            if ((line.find("hartree   energy    :") != -1)):
               energies0['hartree_energy'] = eval(line.split()[3])

            if ((line.find("exc-corr  energy    :") != -1)):
               energies0['exc_corr_energy'] = eval(line.split()[3])

            if ((line.find("ion-ion   energy    :") != -1)):
               energies0['ion_ion_energy'] = eval(line.split()[3])

            if ((line.find("Kinetic energy (elc)    :") != -1)):
               energies0['kinetic_energy_elc'] = eval(line.split()[4])

            if ((line.find("Kinetic energy (ion)    :") != -1)):
               energies0['kinetic_energy_ion'] = eval(line.split()[4])

            if ((line.find("LJ energy              :") != -1)):
               energies0['LJ_energy'] = eval(line.split()[3])

            if ((line.find("Residual Coulomb energy:") != -1)):
               energies0['Residual_Coulomb_energy'] = eval(line.split()[3])

            if ((line.find("MM Vibration energy    :") != -1)):
               energies0['MM_Vibration_energy'] = eval(line.split()[4])

            if ((line.find("thermostat energy (elc) :") != -1)):
               energies0['thermostat_energy_elc'] = eval(line.split()[4])

            if ((line.find("thermostat energy (ion) :") != -1)):
               energies0['thermostat_energy_ion'] = eval(line.split()[4])

            if ((line.find("CPMD property analysis is on.") != -1)): energies = energies0
   return energies



def parse_average_potentialenergy(outfile):
   energies = []
   counts   = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("Vaverage  Eaverage :") != -1)):
            e1 = eval(line.split()[3])
            e2 = eval(line.split()[4])
            energies.append((e1,e2))
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[7])
            counts.append(c)
         if ((line.find("== Energy Calculation ==") != -1)):
            clast = counts.pop()
         if ((line.find("CPMD property analysis is off.") != -1)): 
            clast = counts.pop()
            elast = energies.pop()
      ofile.close()

   eave1 = 0.0; eave2 = 0.0; n = 0.0
   for i in range(len(energies)):
      eave1 += counts[i]*energies[i][0]
      eave2 += counts[i]*energies[i][1]
      n    += counts[i]
   eave1 = eave1/(1.0*n)
   eave2 = eave2/(1.0*n)

   return (eave1,eave2)

def parse_variance_potentialenergy(outfile):
   variances = []
   counts    = []
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("Vvariance Evariance:") != -1)):
            v1 = eval(line.split()[2])
            v2 = eval(line.split()[3])
            variances.append((v1,v2))
         if ((line.find("maximum iterations =") != -1)):
            c = eval(line.split()[7])
            counts.append(c)
         if ((line.find("== Energy Calculation ==") != -1)):
            clast = counts.pop()
         if ((line.find("CPMD property analysis is off.") != -1)):
            clast = counts.pop()
            vlast = variances.pop()
      ofile.close()

   vave1 = 0.0; vave2 = 0.0; n = 0.0
   for i in range(len(variances)):
      vave1 += counts[i]*variances[i][0]
      vave2 += counts[i]*variances[i][1]
      n    += counts[i]
   vave1 = vave1/(1.0*n)
   vave2 = vave2/(1.0*n)

   return (vave1,vave2)





def parse_osmiles(outfile):
   osmiles = "nosmiles"
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("osmiles:") != -1): 
            osmiles = line.split("osmiles:")[1].split(":osmiles")[0]
      ofile.close()
   return osmiles

def parse_client(outfile):
   client = ""
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("client:") != -1): 
            client = line.split("client:")[1].split(":client")[0]
      ofile.close()
   return client

def parse_postsmiles(outfile):
   psmiles = ""
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("psmiles:") != -1): 
            psmiles = line.split("psmiles:")[1].split(":psmiles")[0]
      ofile.close()
   return psmiles


def parse_xc(outfile):
   grid = None
   xc   = None
   notproperty = True
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("VWN V Correlation Functional  1.000 local") != -1):       xc = 'lda'
         if (line.find("PerdewBurkeErnzerhof Exchange Functional  1.000") != -1): xc = 'pbe'
         if (line.find("PBE0 Method XC Functional") != -1):                       xc = 'pbe0'
         if (line.find("Becke 1988 Exchange Functional  1.000") != -1):           xc = 'blyp'
         if (line.find("B3LYP Method XC Potential") != -1):                       xc = 'b3lyp'
         if (line.find("M06-2X Method XC Functional") != -1):                     xc = 'm06-2x'
         if (line.find("LDA (Vosko et al) parameterization") != -1):      xc = 'lda'
         if (line.find("HSE (White and Bird) parameterization") != -1):   xc = 'hse'
         if (line.find("PBE0 (White and Bird) parameterization") != -1):  xc = 'pbe0'
         if (line.find("BLYP (White and Bird) parameterization") != -1):  xc = 'blyp'
         if (line.find("B3LYP (White and Bird) parameterization") != -1): xc = 'b3lyp'
         if (line.find("PBE96 (White and Bird) parameterization") != -1): xc = 'pbe'
         if (notproperty):
            if (grid=='None'):
               if (line.find("Grid used for XC integration:  medium") != -1): grid = '-medium'
               if (line.find("Grid used for XC integration:  coarse") != -1): grid = '-coarse'
               if (line.find("Grid used for XC integration:  fine") != -1):   grid = '-fine'
               if (line.find("Grid used for XC integration:  xfine") != -1):  grid = '-xfine'
         if (line.find("NWChem Property Module") != -1):  notproperty = False
      ofile.close()
      if (xc==None):   xc = 'lda'
      if (grid!=None):
         if (grid!='-medium'):
            xc += grid
   return xc

def parse_base_xc(outfile):
   grid = None
   xc   = 'unknown'
   notproperty = True
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("#") != -1):
            if (line.find("VWN V Correlation Functional  1.000 local") != -1):       xc = 'lda'
            if (line.find("PerdewBurkeErnzerhof Exchange Functional  1.000") != -1): xc = 'pbe'
            if (line.find("PBE0 Method XC Functional") != -1):                       xc = 'pbe0'
            if (line.find("Becke 1988 Exchange Functional  1.000") != -1):           xc = 'blyp'
            if (line.find("B3LYP Method XC Potential") != -1):                       xc = 'b3lyp'
            if (line.find("M06-2X Method XC Functional") != -1):                     xc = 'm06-2x'
            if (line.find("LDA (Vosko et al) parameterization") != -1):      xc = 'lda'
            if (line.find("HSE (White and Bird) parameterization") != -1):   xc = 'hse'
            if (line.find("PBE0 (White and Bird) parameterization") != -1):  xc = 'pbe0'
            if (line.find("BLYP (White and Bird) parameterization") != -1):  xc = 'blyp'
            if (line.find("B3LYP (White and Bird) parameterization") != -1): xc = 'b3lyp'
            if (line.find("PBE96 (White and Bird) parameterization") != -1): xc = 'pbe'
            if (notproperty):
               if (grid=='None'):
                  if (line.find("Grid used for XC integration:  medium") != -1): grid = '-medium'
                  if (line.find("Grid used for XC integration:  coarse") != -1): grid = '-coarse'
                  if (line.find("Grid used for XC integration:  fine") != -1):   grid = '-fine'
                  if (line.find("Grid used for XC integration:  xfine") != -1):  grid = '-xfine'
            if (line.find("NWChem Property Module") != -1):  notproperty = False
      ofile.close()
      #if (xc==None):   xc = 'lda'
      if (grid!=None):
         if (grid!='-medium'):
            xc += grid
   return xc



def parse_charge(outfile):
   charge = 0
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Charge           :") != -1): charge =  int(evalnum(line.split()[2]))
         if (line.find("total charge:") != -1):      charge =  int(evalnum(line.split()[2]))
      ofile.close()
   return charge


def parse_mult(outfile):
   mult = 1
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Spin multiplicity:") != -1): mult =  evalnum(line.split()[2])
         if (line.find("open shells     =") != -1):  mult =  evalnum(line.split()[3])+1
         if (line.find("alpha electrons =") != -1):  nup =  evalnum(line.split()[3])
         if (line.find("beta  electrons =") != -1):  
            ndown =  evalnum(line.split()[3])
            mult  = nup-ndown+1
         if ((line.find("(Fourier space)") != -1) and (line.find(" number of electrons: spin up=") != -1)):
            nup   = evalnum(line.split()[5])
            ndown = evalnum(line.split()[11])
            mult = nup-ndown + 1
      ofile.close()
   return mult



def parse_energy(outfile):
   energy = 9.9e9
   if (os.path.exists(outfile)):
      try:
         cmd0 = "fgrep @ " + outfile
         p = os.popen(cmd0)
         s = p.read()
         p.close()
         sp = s.split()
         nn = len(sp)
         if (nn>27):
            energy = evalnum(sp[nn-7])
      except:
         energy = 9.9e9

      ### look CCSD(T) energy or MP2 Energy ###
      with open(outfile,'r') as ff:
         for line in ff:
            if (line.find("CCSD total energy / hartree       =") != -1):    energy =  evalnum(line.split()[6])
            if (line.find("CCSD(T) total energy / hartree       =") != -1): energy =  evalnum(line.split()[6])
            if (line.find("Total MP2 energy") != -1):                       energy =  evalnum(line.split()[3])
            if (line.find("Total CCSD energy:") != -1):                     energy =  evalnum(line.split()[3])
            if (line.find("Total CCSD(T) energy:") != -1):                  energy =  evalnum(line.split()[3])
     
   return energy




def parse_enthalpy(outfile):
   enthalpy = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd2 = "fgrep \"Thermal correction to Enthalpy\" " + outfile
         pfile = os.popen(cmd2)
         for line in pfile:
            if (line.find("Thermal correction to Enthalpy") != -1):   enthalpy  = evalnum(line.split()[8])
         pfile.close()
      except:
         enthalpy = 0.0
   return enthalpy




def parse_entropy(outfile):
   found = False
   entropy = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd3 = "fgrep \"Total Entropy\" " + outfile
         pfile = os.popen(cmd3)
         for line in pfile:
            if ((line.find("Total Entropy") != -1) and (not found)):
               entropy   = evalnum(line.split()[3])
               found = True
         pfile.close()
      except:
         entropy = 0.0
   return entropy


def parse_cosmo_smd(outfile):
   cosmo_smd = 0.0
   foundsmd = False
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"1 M fixed-concentration free energy of solvation\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("1 M fixed-concentration free energy of solvation") != -1):
               cosmo_smd = evalnum(line.split()[10])
               foundsmd = True
         pfile.close()
      except:
         cosmo_smd = 0.0

   if (abs(cosmo_smd)<=1e-8) and foundsmd:
      cosmo_smd = -987654.3210
   return cosmo_smd

def parse_cosmo_smd_solvent(outfile):
   solvent = "water"
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"solvname_short:\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("solvname_short:") != -1):
              solvent = line.split()[1]
         pfile.close()
      except:
         solvent = "water"
   return solvent


def parse_cosmo_smd_e(outfile):
   cosmo_smd_e = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"total free energy in solvent including G(SMD-CDS)\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("total free energy in solvent including G(SMD-CDS)") != -1):
               cosmo_smd_e = evalnum(line.split()[8])
         pfile.close()
      except:
         cosmo_smd_e = 0.0
   return cosmo_smd_e


def parse_cosmo(outfile):
   cosmo = 0.0
   foundcosmo = False
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"(electrostatic) solvation energy\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("(electrostatic) solvation energy") != -1):
               cosmo = evalnum(line.split()[6])
               foundcosmo = True
         pfile.close()
         if (cosmo==0.0):
            cmd5 = "fgrep \"skipped: no gas phase energy\" " + outfile
            pfile = os.popen(cmd5)
            for line in pfile:
               if (line.find("skipped: no gas phase energy") != -1):
                  cosmo = -987654321.0
            pfile.close()
      except:
         cosmo = 0.0
   if (abs(cosmo)<=1e-8) and foundcosmo:
      cosmo = -987654.3210
   return cosmo


def parse_cosmo_intrinsic(outfile):
   intrinsic = False
   if (os.path.exists(outfile)):
      try:
         cmd5 = "fgrep \"skipped: no gas phase energy\" " + outfile
         pfile = os.popen(cmd5)
         for line in pfile:
            if (line.find("skipped: no gas phase energy") != -1):
               intrinsic = True
         pfile.close()
      except:
         intrinsic = False
   return intrinsic

def parse_cosmo_dielectric(outfile):
   dielectric = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"dielectric constant -eps-\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("dielectric constant -eps-") != -1):
               dielectric = evalnum(line.split()[4])
         pfile.close()
      except:
         dielectric = 0.0
   return dielectric


def parse_xyzblob(outfile,tmpxyzfile):
   xyzblob = ''
   if (os.path.exists(outfile)):
      try:
         count = -1
         xyzdat = []
         ofound = False
         gfound = False
         done = False
         ofile = open(outfile,'r')
         for line in ofile:
           if (not done):
              if (count>0):
                 if (len(line)<=5):
                    #done = True
                    count = -1
                    ofound = False
                    gfound = False
                 else:
                    xyzdat.append(line)
              if (not done):
                 if (count>=0):
                    count += 1
                 if (line.find("Optimization converged") != -1):
                    ofound = True
                 if (line.find("Failed to converge in maximum number of steps") != -1):
                    ofound = True
                 if (ofound and (line.find("No.") != -1)):
                    gfound = True
                    count = 0
                    xyzdat = []
         ofile.close()

         #print("xyzdat=",xyzdat)

         #print("Generating xyzfile = ",xyzfile)
         n = len(xyzdat)
         xfile = open(tmpxyzfile,'w')
         xfile.write("%d\n\n" % n)
         for i in range(n):
            split = xyzdat[i].split()
            xfile.write("%s   %f %f %f\n" % (split[1],evalnum(split[3]),evalnum(split[4]),evalnum(split[5])))
         xfile.close()

         n = len(xyzdat)
         xyzblob = "%d\n\n" % n
         for i in range(n):
            split = xyzdat[i].split()
            xyzblob +=  "%s   %f %f %f\n" % (split[1],evalnum(split[3]),evalnum(split[4]),evalnum(split[5]))
      except:
         print("Cannot generate xyzblob ")

   return xyzblob



def parse_nmrblob(outfile):
   nmrblob = ''
   if (os.path.exists(outfile)):
      try:
         nmrblob = ''
         ofile = open(outfile,'r')
         started  = False
         finished = False
         for line in ofile:
           if (not finished):
              if (started):
                 if (line.find("Task  times  cpu:") != -1):
                    finished = True
                 else:
                    nmrblob += line
              else:
                 if (line.find("Chemical Shielding Tensors (GIAO, in ppm)") != -1):
                    started  = True
                    nmrblob += line
         ofile.close()
      except:
         print("Cannot generate nmrblob ")
   return nmrblob

def parse_freqblob(outfile):
   freqblob = ''
   if (os.path.exists(outfile)):
      try:
         freqblob = ''
         ofile = open(outfile,'r')
         started  = False
         finished = False
         for line in ofile:
           if (not finished):
              if (started):
                 if (line.find("Task  times  cpu:") != -1):
                    finished = True
                 else:
                    freqblob += line
              else:
                 if (line.find("P.Frequency") != -1):
                    started  = True
                    freqblob += line
         ofile.close()

         #### add hessian ####
         ofile = open(outfile,'r')
         started  = False
         finished = False
         for line in ofile:
           if (not finished):
              if (started):
                 if ((line.find("center of mass") != -1) or (line.find("HEAT OF FORMATION") != -1)):
                    finished = True
                 else:
                    freqblob += line
              else:
                 if ((line.find("MASS-WEIGHTED PROJECTED HESSIAN (Hartree/Bohr/Bohr/Kamu)") != -1) or (line.find("FORCE MATRIX IN MILLIDYNES/ANGSTROM") != -1)):
                    started  = True
                    freqblob += line
         ofile.close()
      except:
         print("Cannot generate freqblob ")
   return freqblob

#def freqblob_ok(freqblob):
#   freqs = []
#   for line in freqblob.split("\n"):
#      if "P.Frequency" in line:
#         freqs += [ eval(s) for s in line.split()[1:]]
#   if ((min(freqs)<(-1000.0)) and (max(freqs)>5000.0)):
#      ok = False
#   else:
#      ok = True
#   return ok


def parse_calculation_ok(outfile):
   if (os.path.exists(outfile)):
      try:
         ok = True
         cons0 = False
         finalrun = False
         mp2run   = False
         completed = False
         ofile = open(outfile,'r')
         for line in ofile:
            if "Adding bondings spring" in line:
               cons0 = True

            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               if (cons0):
                  if ((min(freqs)<(-75.0)) or (max(freqs)>150000.0)):
                     ok = False
               else:
                  if ((min(freqs)<(-75.0)) or (max(freqs)>5000.0)):
                     ok = False

            #geometry not converged
            if "Failed to converge in maximum" in line: ok = False

            #look for final resubmit
            if "resubmitjob:9" in line: finalrun = True

            #look for MP2 job
            if "Total MP2 energy" in line: mp2run = True

            #dft gradient failed
            if "driver: task_gradient failed" in line: ok = False

            #dft energy not converged
            if "Calculation failed to converge" in line: ok = False

            #check for 3 negative frequencies
            if "Geometry after  100.0% step for mode  3;" in line: ok = False

            if (cons0 and ("Optimization converged" in line)): ok = True

            #look for completion
            if "Total times  cpu:" in line: completed = True
         ofile.close()
         ok = (ok or finalrun or mp2run) and completed
      except:
         ok = False
   else:
      ok = False

   return ok



def parse_number_negative_frequencies(outfile):
   nfreqs = 0
   if (os.path.exists(outfile)):
      try:
         ofile = open(outfile,'r')
         for line in ofile:
            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               for f in freqs:
                  if (f<(-0.5)): nfreqs += 1
         ofile.close()
      except:
         nfreqs = 0
   return nfreqs


def parse_bad_calculation_xyz(outfile):
   vtag       = ""
   xyzdat     = []
   xyzdat2all = []
   xyzdat2mall = []
   usefreqxyz = False
   if (os.path.exists(outfile)):
      try:
         ok = True
         vtag = ""
         mtag = ""
         bad_calculation = False
         completed = False
         usefreqxyz = True
         geomread  = 0
         geomread2 = 0
         geomread2m= 0
         xyzdat     = []
         xyzdat2    = []
         xyzdat2m   = []
         xyzdat2all = []
         xyzdat2mall = []
         freqs_negative = []
         ofile = open(outfile,'r')
         for line in ofile:

            #look for gross failures
            if "There is an error" in line: bad_calculation = True

            #look for machinejob: string
            if "machinejob:" in line:
               ss = line.split()
               for s in ss:
                  if "machinejob:" in s: mtag = s

            #look for resubmitjob: string
            if "resubmitjob:" in line:
               ss = line.split()
               for s in ss:
                  if "resubmitjob:" in s: vtag = s

            #read geometry during optimization
            if (geomread>0): geomread += 1
            if (geomread>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread = 0
               else:
                  xyzdat.append([ss[1],ss[3],ss[4],ss[5]])

            #start read geometry during optimization
            if "No.       Tag          Charge" in line:
               xyzdat = []
               geomread = 1

            #read of 100% bad mode geometry
            if (geomread2>0): geomread2 += 1
            if (geomread2>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread2 = 0
                  xyzdat2all.append(xyzdat2)
               else:
                  xyzdat2.append([ss[1],ss[3],ss[4],ss[5]])

            #start read of 100% bad mode geometry
            if "Geometry after  100.0% step for mode" in line:
               ok = False
               xyzdat2 = []
               geomread2 = 1


            #read of -100% bad mode geometry
            if (geomread2m>0): geomread2m += 1
            if (geomread2m>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread2m = 0
                  xyzdat2mall.append(xyzdat2m)
               else:
                  xyzdat2m.append([ss[1],ss[3],ss[4],ss[5]])

            #start read of -100% bad mode geometry
            if "Geometry after -100.0% step for mode" in line:
               ok = False
               xyzdat2m = []
               geomread2m = 1


            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               if ((min(freqs)<(-1000.0)) or (max(freqs)>5000.0)):
                  ok = False
               for f in freqs:
                  if (f<-0.5): freqs_negative.append(f)

            #geometry not converged
            if "Failed to converge in maximum" in line:
               usefreqxyz = False
               ok = False

            #dft gradient failed
            if "driver: task_gradient failed" in line:
               usefreqxyz = False
               ok = False

            #dft energy not converged
            if "Calculation failed to converge" in line:
               usefreqxyz = False
               ok = False

            #look for completion
            if "Total times  cpu:" in line: completed = True
         ofile.close()
         ok = ok and completed
      except:
         ok = False
   else:
      ok = False

   usefreqxyz = usefreqxyz and (len(xyzdat2all)!=0)
   if (usefreqxyz):
      msg =  "The bad calculation geometry was updated using average of negative frequency modes. " 
      msg += "There are %d negative frequency modes." % len(xyzdat2all)
      msg += "The negative frequencies are: "
      for f in freqs_negative:
         msg += "%.0f cm-1" % f
      msg += "."
      print(msg)
      text2speech(msg)
      #xyzdat = xyzdat2all[0]
      #for j in range(len(xyzdat)):
      #   x  = 0.0
      #   y  = 0.0
      #   z  = 0.0
      #   nx = 0.0
      #   for i in range(len(xyzdat2all)):
      #      x += eval(xyzdat2all[i][j][1])
      #      y += eval(xyzdat2all[i][j][2])
      #      z += eval(xyzdat2all[i][j][3])
      #      nx += 1.0
      #   xyzdat[j][1] = "%f" % (x/nx)
      #   xyzdat[j][2] = "%f" % (y/nx)
      #   xyzdat[j][3] = "%f" % (z/nx)

      x = [0.0]*len(xyzdat)
      y = [0.0]*len(xyzdat)
      z = [0.0]*len(xyzdat)
      nx = 0.0
      for i in range(len(xyzdat2all)):
         nx += 1.0
         if (random.randint(0,1)==1):
            for j in range(len(xyzdat)):
               x[j] += evalnum(xyzdat2all[i][j][1])
               y[j] += evalnum(xyzdat2all[i][j][2])
               z[j] += evalnum(xyzdat2all[i][j][3])
         else:
            for j in range(len(xyzdat)):
               x[j] += evalnum(xyzdat2mall[i][j][1])
               y[j] += evalnum(xyzdat2mall[i][j][2])
               z[j] += evalnum(xyzdat2mall[i][j][3])
      for j in range(len(xyzdat)):
         xyzdat[j][1] = "%f" % (x[j]/nx)
         xyzdat[j][2] = "%f" % (y[j]/nx)
         xyzdat[j][3] = "%f" % (z[j]/nx)
    
   if (xyzdat!=[]):
      xyz = "%d\n\n" % len(xyzdat)
      for ss in xyzdat:
         xyz += "%s  %s %s %s\n" % (ss[0],ss[1],ss[2],ss[3])
      hasxyz = True
   else:
      hasxyz = False
      xyz    = ""

   if (bad_calculation):
      hasxyz = False
      xyz    = ""

   return (hasxyz,xyz,vtag,mtag)


      

def parse_eigblob(outfile):
   eigblob = ''
   if (os.path.exists(outfile)):
      try:
         unrestricted = False
         #cmd5 = "fgrep \"DFT Final Beta Molecular Orbital Analysis\" " + outfile
         cmd5 = "fgrep \"Final Beta Molecular Orbital Analysis\" " + outfile
         pfile = os.popen(cmd5)
         for line in pfile:
            #if (line.find("DFT Final Beta Molecular Orbital Analysis") != -1):
            if (line.find("Final Beta Molecular Orbital Analysis") != -1):
               unrestricted = True
         pfile.close()

         cmd6 = "fgrep \"Vector\"" + outfile
         eigblob = ''
         pspwset = False
         ofile = open(outfile,'r')
         for line in ofile:
            #if (line.find("DFT Final Alpha Molecular Orbital Analysis") != -1):
            if (line.find("Final Alpha Molecular Orbital Analysis") != -1):
               eigblob = 'alpha\n'
            #if (line.find("DFT Final Beta Molecular Orbital Analysis") != -1):
            if (line.find("Final Beta Molecular Orbital Analysis") != -1):
               eigblob += '\nbeta\n'
            #if (line.find("DFT Final Molecular Orbital Analysis") != -1):
            if (line.find("Final Molecular Orbital Analysis") != -1):
               eigblob = 'restricted\n'
            if (line.find("Vector") != -1): eigblob += line

            if (pspwset):
               if (len(line.split())>1):
                  eigblob += line
               else:
                  pspwset = False
            elif (line.find("virtual orbital energies:") != -1):
               eigblob += line
               pspwset  = True
            elif (line.find("orbital energies:") != -1):
               eigblob = line
               pspwset = True

         ofile.close()

      except:
         eigblob = ''
   return eigblob


def parse_matrix_elements(outfile):
   mdict = {}
   mdict['format'] = {'version':"0.1"}
   mdict['generator'] = {'source': 'nwchem'}
   mdict['generator']['version'] = '0.1.2.3'
   mdict['integral_sets'] = [{'metadata': {'molecule_name':'unknown'}}]
   mdict['integral_sets'][0]['basis_set'] = {'name':'unknown', 'type':'gaussian'}
   mdict['integral_sets'][0]['geometry'] = {'units':'angstrom','coordinate_system':'cartesian','symmetry':'c1','atoms':[]}
   mdict['integral_sets'][0]['coulomb_repulsion'] = {'units':'hartree','value':0.0}
   mdict['integral_sets'][0]['scf_energy'] = {'units':'hartree','value':0.0}
   mdict['integral_sets'][0]['scf_energy_offset'] = {'units':'hartree','value':0.0}
   #mdict['integral_sets']['ccsd_energy'] = {'units':'hartree','value':0.0}
   mdict['integral_sets'][0]['energy_offset'] = {'units':'hartree','value':0.0}
   mdict['integral_sets'][0]['fci_energy'] = {'lower':0.0, 'units':'hartree','upper':0.0,'value':0.0}
   mdict['integral_sets'][0]['n_orbitals'] = 0
   mdict['integral_sets'][0]['n_electrons'] = 0
   mdict['integral_sets'][0]['hamiltonian'] = {'one_electron_integrals':{'units':'hartree','format':'sparse','values':[]}, 'two_electron_integrals':{'units':'hartree','format':'sparse','index_convention':'mulliken','values':[]}}

   if (os.path.exists(outfile)):
      try:
         h1set = False
         b1set = False
         b2set = False
         e1set = False
         e1count = 0
         gsenergy = 0.0
         g1set = False
         s0set = False
         s1set = False
         s2set = False
         v2set = False
         ofile = open(outfile,'r')
         for line in ofile:
            if (line.find("Number of active orbitals") != -1):
                mdict['integral_sets'][0]['n_orbitals'] = eval(line.split()[4])
            if (line.find("Number of active alpha electrons") != -1):
                mdict['integral_sets'][0]['n_electrons'] += eval(line.split()[5])
            if (line.find("Number of active beta electrons") != -1):
                mdict['integral_sets'][0]['n_electrons'] += eval(line.split()[5])
            #if (line.find("CCSD total energy / hartree       =") != -1):
            #    gsenergy = eval(line.split()[6])
            #    state = {'state':{'label':'|G>','superposition':[], 'energy':{'units':'hartree','value': gsenergy}}}
            #   mdict['integral_sets']['ccsd_energy']['value'] = eval(line.split()[6])
            if (line.find("EHF(total)         =") != -1):
               mdict['integral_sets'][0]['scf_energy']['value'] = eval(line.split()[2])
            if (line.find("Shift (HFtot-HFA)  =") != -1):
               mdict['integral_sets'][0]['scf_energy_offset']['value'] = eval(line.split()[3])
            if (line.find("Northwest Computational Chemistry Package (NWChem)") != -1):
               mdict['generator']['version'] = line.split()[5]
            if (line.find("enrep_tce =") != -1):
               mdict['integral_sets'][0]['coulomb_repulsion']['value'] = eval(line.split()[2])

            if (line.find("end_two_electron_integrals") != -1):
               v2set = False

            if (v2set):
               ss = line.strip().split()
               mdict['integral_sets'][0]['hamiltonian']['two_electron_integrals']['values'].append([eval(ss[0]),eval(ss[1]),eval(ss[2]),eval(ss[3]),eval(ss[4])])

            if (line.find("end_one_electron_integrals") != -1):   h1set = False;
            if (line.find("begin_two_electron_integrals") != -1): h1set = False; v2set = True

            if (h1set):
               ss = line.split()
               mdict['integral_sets'][0]['hamiltonian']['one_electron_integrals']['values'].append([eval(ss[0]),eval(ss[1]),eval(ss[2])])

            if (line.find("begin_one_electron_integrals") != -1): h1set = True
            if (g1set):
               ss = line.split()
               if (len(ss)<1): 
                  g1set = False
               else:
                  tt = {'name':ss[1], 'coords':[eval(ss[3]),eval(ss[4]),eval(ss[5])]}
                  mdict['integral_sets'][0]['geometry']['atoms'].append(tt)
            if ('#' not in line) and (line.find(" ---- ---------------- ---------- -------------- -------------- --------------") != -1): g1set = True

            if (b1set):
               ss = line.split()
               if (len(ss)<1): 
                  b1set = False
                  b2set = True
               else:
                  tt = {'name':ss[1], 'type': 'gaussian'}
                  mdict['integral_sets'][0]['basis_set'] = tt
                  #mdict['integral_sets']['basis_set'].append(tt)
            if ('#' not in line) and (not b2set) and (line.find(" ---------------- ------------------------------  ------  ---------------------") != -1): b1set = True

            if (e1set):
               ss = line.split()
               if (line.find("Summary of allocated global arrays") != -1): 
                  e1set = False
                  mdict['integral_sets'][0]['initial_state_suggestions'].append(state)
               elif (line.find("Excitation energy / hartree =") != -1): 
                  if (e1count>0):
                     mdict['integral_sets'][0]['initial_state_suggestions'].append(state)
                  e1count += 1
                  chi = "|E%d>" % (e1count-1)
                  state = {'state':{'label':chi,'superposition':[], 'energy':{'units':'hartree','value': gsenergy+eval(ss[5])}}}
               elif (line.find("CCSD total energy / hartree       =") != -1):
                  gsenergy = eval(line.split()[6])
                  state = {'state':{'label':'|G>','superposition':[], 'energy':{'units':'hartree','value': gsenergy}}}
                  e1count += 1
               elif (s0set):
                  if (len(ss)<3):
                     s0set = False
                  else:
                     sss = [eval(ss[0])] + line.replace(":","").split()[1:]
                     state['state']['superposition'].append(sss)
               elif (line.find("Reference string") != -1): 
                  s0set = True
               elif (s1set):
                  if (len(ss)<3):
                     s1set = False
                  else:
                     sss = [eval(ss[0])] + line.replace(":","").split()[1:]
                     state['state']['superposition'].append(sss)
               elif (line.find("Singles strings") != -1): 
                  s1set = True
           
               elif (s2set):
                  if (len(ss)<3):
                     s2set = False
                  else:
                     sss = [eval(ss[0])] + line.replace(":","").split()[1:]
                     state['state']['superposition'].append(sss)
               elif (line.find("Doubles strings") != -1): 
                  s2set = True

            #if (line.find("No. of excited states :") != -1):
            if (line.find("CCSD iterations") != -1):
                  e1set = True
                  mdict['integral_sets'][0]['initial_state_suggestions'] = []

         ofile.close()
         #mblob = yaml.dump(mdict, default_flow_style=False)
         #mblob = yaml.dump(mdict)
      except:
         mdict = {}
   return mdict



def parse_qsharp_norbs(outfile):
   norbs = 2
   ofile = open(outfile,'r')
   for line in ofile:
      if (line.find("Number of active orbitals") != -1):
         norbs = evalnum(line.split()[4])
   ofile.close()
   return norbs

def parse_qsharp_nalpha(outfile):
   nalpha = 1
   ofile = open(outfile,'r')
   for line in ofile:
      if (line.find("Number of active alpha electrons") != -1):
         nalpha =  evalnum(line.split()[5])
   ofile.close()
   return nalpha

def parse_qsharp_nbeta(outfile):
   nbeta = 1
   ofile = open(outfile,'r')
   for line in ofile:
      if (line.find("Number of active beta electrons") != -1):
         nbeta = evalnum(line.split()[5])
   ofile.close()
   return nbeta

def parse_qsharp_nroots(outfile):
   nroots = 0
   ofile = open(outfile,'r')
   for line in ofile:
      if (line.find("No. of excited states :") != -1):
         nroots = evalnum(line.split()[5])
   ofile.close()
   return nroots


def parse_jobfinished(outfile):
   jobfinished = False
   if (os.path.exists(outfile)):
      try:
         cmd = "fgrep \"maximum total M-bytes\" " + outfile
         pfile = os.popen(cmd)
         for line in pfile:
            if (line.find("maximum total M-bytes")!=-1):
               jobfinished = True
      except:
         jobfinished = False

   return jobfinished


def parse_aimdjob(outfile):
   aimdjob = False
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if (line.find("Car-Parrinello microcluster calculation") != -1): aimdjob = True
   return aimdjob


def parse_homolumojob(outfile):
   homolumojob = False
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ("homolumoresubmitjob:" in line): homolumojob = True
   return homolumojob


def parse_hrotorjob(outfile):
   hrotorjob = False
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ("hrotorresubmitjob:" in line): hrotorjob = True
   return hrotorjob

def parse_hrotorreplacejob(outfile):
   hrotorreplacejob = False
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ("hrotorreplacejob" in line): hrotorreplacejob = True
   return hrotorreplacejob



def parse_tsample_filenames(outfile):
   outfile_directory = outfile[:outfile.rfind('/')+1]
   tsample = ''
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if (line.find("ion_motion_filename") != -1):
               tt = line.split()[1]
               tsample = tt[tt.rfind('/')+1:].split('.')[0]

   tsample_xyz        = outfile_directory + tsample + ".xyz"
   tsample_ion_motion = outfile_directory + tsample + ".ion_motion"
   tsample_emotion    = outfile_directory + tsample + ".emotion"
   tsample_fei        = outfile_directory + tsample + ".fei"
   return (tsample_xyz,tsample_ion_motion,tsample_emotion,tsample_fei)

def parse_gr_filenames(outfile):
   outfile_directory = outfile[:outfile.rfind('/')+1]
   gr_filenames = []
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if (line.find("creating gr filename:") != -1):
               tt = line.split()[2]
               gr_filenames.append(outfile_directory+tt[tt.rfind('/')+1:])
   return gr_filenames


def parse_hist_filenames(outfile):
   outfile_directory = outfile[:outfile.rfind('/')+1]
   hist_filenames = []
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if (line.find("creating hist filename:") != -1):
               tt = line.split()[2]
               hist_filenames.append(outfile_directory+tt[tt.rfind('/')+1:])
   return hist_filenames


def parse_calculation_type_aimd(outfile):
   calctype = ' '
   if (os.path.exists(outfile)):
      with open(outfile,'r') as ofile:
         for line in ofile:
            if ((line.find("NWPW PSPW Calculation") != -1) and 
                (calctype[-1]!='e')):                               calctype += 'e'
            if (line.find("CPMD property analysis is off.") != -1): calctype += 'q'
            if (line.find("CPMD property analysis is on.") != -1):  calctype += 'd'
   return calctype.strip()


#############################################
#                                           #
#             get_frequency                 #
#                                           #
#############################################

# returns the freqency and eigvector for a given frequency number, fnum.

def get_frequency(frequency_blob,fnum):

   all_lines2 = frequency_blob.split("\n")
   pcount_num = (fnum-1)/6
   shift      = (fnum-1)%6
   freqs = []
   freqdat = []
   count  = 0
   pcount = -1
   done = False
   for line in all_lines2:
     if (not done):
        if (pcount==pcount_num):
           count += 1
           if (count>1):
              if (len(line)<=5):
                 done = True
              else:
                 freqdat.append(line)
        if (not done):
           if (line.find("P.Frequency") != -1):
              count = 0
              pcount += 1
              if (pcount==pcount_num):
                 freqs.append(line)

   splt = freqs[0].split()
   w = evalnum(splt[shift+1])

   freq = []
   n = len(freqdat)
   for i in range(n):
      split = freqdat[i].split()
      freq.append(evalnum(split[shift+1]))

   return (w,freq)

#############################################
#                                           #
#             analyze_frequency             #
#                                           #
#############################################
def analyze_frequency(w):
   minfreq = 0.1
   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL

   #print("Temperature=%7.2f  freq= %8.3f cm-1" % (temp,w))
   ethermal = 0.0
   Svib = 0.0
   if (w>minfreq):
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal =  thetav*(0.50 + xdum)*Rgas
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib   =  (xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas
      else:
         Svib = 0.0
      #print("  - contribution to thermal correction to enthalpy= %8.3f kcal/mol (%10.6f)" %  (ethermal*AUKCAL,ethermal))
      #print("  - contribution to Entropy                       = %8.3f cal/mol-k"       %  (Svib*AUKCAL*1000.0))

   return (ethermal,Svib)


#############################################
#                                           #
#               w_freq_hrotor               #
#                                           #
#############################################
def w_freq_hrotor(rgroup,tphi,v):

   wall = []
   for kk in rgroup:
      k1 = kk-1
      w  = tphi[3*k1]*v[3*k1] + tphi[3*k1+1]*v[3*k1+1] + tphi[3*k1+2]*v[3*k1+2]
      wall.append(w)
   failed = False
   if (wall[0]<0): 
      for w in wall:
         if (w>0): failed = True
   else:
      for w in wall:
         if (w<0): failed = True

   if failed:
      wmin = 0.0
   else:
      wmin = 9.9e99
      for w in wall:
         if (abs(w) < abs(wmin)): wmin = w

   return wmin



#############################################
#                                           #
#            parse_hrotor_blob              #
#                                           #
#############################################

# returns the freqency and eigvector for a given frequency number, fnum.

def parse_hrotor_blob(filename,xyz_blob,freq_blob):
   #
   eoln = "\n"
   tstr = ""
   
   R          = 1.986
   boltzman   = 1.38e-23
   plank      = 6.63e-34
   CONVERT_SI = 1.67e-47

   hrotorforce = False
   hrotorzero  = False
   odata = ''
   headerdata = ''
   with open(filename,'r') as ofile:
      for line in ofile:
         if ('#@@' in line): headerdata += line
         if ('hrotorforce' in line): hrotorforce = True
         if ('hrotorzero' in line):  hrotorzero  = True
         if ('hrotoroverlapset:' in line) and (':hrotoroverlapset' in line): 
            odata = line.split('hrotoroverlapset:')[1].split(':hrotoroverlapset')[0].strip()
      

   T       = evalnum(headerdata.split("#@@   Temperature =")[1].split("\n")[0])
   nphi    = evalnum(headerdata.split("#@@   nphi     =")[1].split("\n")[0])
   NNmax   = evalnum(headerdata.split("#@@   NNmax    =")[1].split("\n")[0])
   sym_num = evalnum(headerdata.split("#@@   rsym_num =")[1].split("\n")[0])
   Im      = evalnum(headerdata.split("#@@    Im  =")[1].split("(")[0])
   theory  = headerdata.split("#@@ theory =")[1].split("\n")[0].strip()
   drphi = []
   for xxx in headerdata.split("#@@ drion/dphi =")[1:]:
      drphi += [evalnum(f) for f in xxx.split("\n")[0].strip().split()]
   tphi = []
   for xxx in headerdata.split("#@@ tphi =")[1:]:
      tphi += [evalnum(f) for f in xxx.split("\n")[0].strip().split()]
   rgroup = []
   yyy = headerdata.split('#@@   rgroup   =')[1].split('\n')[0]
   for y in yyy.split():
      rgroup.append(evalnum(y))
   #drphi = [evalnum(f) for f in headerdata.split("#@@ drion/dphi =")[1].split("\n")[0].strip().split()]


   ## extract the potential
   if (theory=='dft'):  str = "Total DFT energy"
   if (theory=='pspw'): str = "Total PSPW energy"
   if (theory=='mp2'):  str = "Total MP2 energy"
   if (theory=='scf'):  str = "Total SCF energy"
   if (theory=='tce'):  str = "CCSD(T) total energy / hartree"
   if (theory=='ccsd(t)'):  str = "Total CCSD(T) energy:"
   if (theory=='ccsd'):  str = "Total CCSD energy:"
   potential = []
   with open(filename,'r') as ofile:
      for line in ofile:
         if (line.find(str) != -1):
            split = line.split()
            if (theory=='mp2'):
               potential.append(evalnum(split[3]))
            elif (theory=='ccsd(t)'):
               potential.append(evalnum(split[3]))
            elif (theory=='tce'):
               potential.append(evalnum(split[6]))
            else:
               potential.append(evalnum(split[4]))


   if (theory=='pspw') and (len(potential) > nphi): 
      nphi0 = len(potential)
      shift = nphi0-nphi
      potential = potential[shift:]

   ## calculate Cannonical Formula Results for Hindered Rotation ##
   if ((nphi > 0) and (len(potential) == nphi)):
      V0 = potential[0]
      Vr = resize(0.0,nphi)
      for i in range(nphi):
         Vr[i] = potential[i] - V0

      ## increase grid by doubling - Crude interpolation ##
      Nmax = nphi
      while ((2*Nmax) < NNmax):
         tmp = resize(Vr,Nmax)
         Vr  = resize(0.0,2*Nmax)
         for i in range(Nmax):
            Vr[2*i] = tmp[i]
         for i in range(Nmax-1):
            Vr[2*i+1] = 0.5*(tmp[i]+tmp[i+1])
         Vr[2*Nmax-1] = 0.5*(tmp[Nmax-1]+tmp[0])
         Nmax = 2*Nmax
      Vk = fft(Vr)
      Vk = Vk/Nmax
     

      H = resize(array(0.0,complex),(Nmax,Nmax))
      krange = range(Nmax)
      for i in range(Nmax): krange[i] -= (Nmax/2-1)

      for kj in krange:
         for ki in krange:
            i = ki
            j = kj
            indx = ki-kj
            if (i<0): i = i + Nmax
            if (j<0): j = j + Nmax
            if (indx<0): indx = indx + Nmax
            H[i][j] = Vk[indx]

      for ki in krange:
         i = ki
         if (i < 0): i = i + Nmax
         H[i][i] = H[i][i] + (0.5/Im)*ki*ki


      (ees,vvs) = eig(H) 
      eigs = real(ees)

      Q  = 0.0
      Qp = 0.0
      for i in range(Nmax):
        em = eigs[i]*627.51*1000.0   # convert to calories #
        Q  = Q  +  exp(-em/(R*T))
        Qp = Qp +  em*exp(-em/(R*T))
      Qp = 1.0/(R*T*T)*Qp
      S  = R*log(Q)  + (R*T/Q)*Qp - R*log(sym_num)
      Uf = R*T*T*Qp/Q


      ### extract frequencies ###
      all_lines2 = freq_blob.split("\n")
      freqs = []
      for line in all_lines2:
         if (line.find("P.Frequency") != -1):
            freqs += [ evalnum(s) for s in line.split()[1:]]


      mysum1 = [0.0]*len(freqs)
      xx = odata.split()
      if (len(xx)==1):
         fnum = evalnum(xx[0])
         mysum1[fnum-1] = 1.0
         hrotoroverlapset = True
      elif (len(xx)>1):
         for n in range(len(xx)/2):
            fnum = evalnum(xx[2*n])
            fwww = evalnum(xx[2*n+1])
            mysum1[fnum-1] = fwww
         hrotoroverlapset = True
      else:
         hrotoroverlapset = False
      
      minfreq = 0.1
      if hrotoroverlapset: 
         fstr = '#@@ Frequency Weights for Hindered Rotation (manually set):' + eoln
      else:
         fstr = '#@@ Frequency Overlap Results for Hindered Rotation:' + eoln
      wwn =  []
      wwp =  []
      wwz =  []
      smax = 0.0
      isnegative = False
      for fnum in range(len(freqs)):
         (w,v) = get_frequency(freq_blob,fnum+1)
         if (hrotoroverlapset):
            sum1 = mysum1[fnum]
         else:
            sum1 = w_freq_hrotor(rgroup,tphi,v)
         #fstr += "#@@ %d  w=%.3f <drphi|freq>=%.3f\n" % (fnum,w,sum1)
         if (w<(-0.01)):
            wwn.append([w,sum1,0.0])
            if ((sum1*sum1)>smax):
               smax = sum1*sum1
               isnegative = True
               fnumn = fnum
         elif (w>(minfreq)): 
            wwp.append([w,sum1,0.0])
            if ((sum1*sum1)>smax):
               smax = sum1*sum1
               isnegative = False
         else:
            wwz.append([w,sum1,0.0])

      if (isnegative):
         Ecorrect = Uf/(1000.0*23.06*27.2116)
         Scorrect = S/(1000.0*23.06*27.2116)
         Evib = 0.0
         Svib = 0.0
         wwn[fnumn][2] = 1.0
      else:
         norm = 0.0
         for i in range(len(wwp)): norm += wwp[i][1]*wwp[i][1]
         if (norm>1.0e-12):
            norm1 = 1.0/sqrt(norm)
         else:
            norm1 = 0.0
         for i in range(len(wwp)): wwp[i][2] = wwp[i][1]*norm1
         normmax = 0.0
         for i in range(len(wwp)): 
            if ((wwp[i][2]**2)>normmax): 
               normmax = wwp[i][2]**2
         if (normmax<0.3) and (not hrotorforce):
            Ecorrect = 0.0
            Scorrect = 0.0
            Evib = 0.0
            Svib = 0.0
         else:
            Ecorrect = Uf/(1000.0*23.06*27.2116)
            Scorrect = S/(1000.0*23.06*27.2116)
            Evib = 0.0
            Svib = 0.0
            for i in range(len(wwp)): 
               (etmp,stmp) = analyze_frequency(wwp[i][0])
               Ecorrect -= wwp[i][2]*wwp[i][2]*etmp
               Scorrect -= wwp[i][2]*wwp[i][2]*stmp
               Evib += wwp[i][2]*wwp[i][2]*etmp
               Svib += wwp[i][2]*wwp[i][2]*stmp

      jn = 0
      jp = 0
      jz = 0
      if hrotoroverlapset:
        for fnum in range(len(freqs)):
           w = freqs[fnum]
           if (w<(-0.01)):
              fstr += "#@@ %5d  w=%.3f \t weight=%.3f\n" % (fnum,w,wwn[jn][2]**2)
              jn += 1
           elif (w>(minfreq)): 
              fstr += "#@@ %5d  w=%.3f \t weight=%.3f\n" % (fnum,w,wwp[jp][2]**2)
              jp += 1
           else:
              fstr += "#@@ %5d  w=%.3f \t weight=%.3f\n" % (fnum,w,wwz[jz][2]**2)
              jz += 1
      else:
        for fnum in range(len(freqs)):
           w = freqs[fnum]
           if (w<(-0.01)):
              fstr += "#@@ %5d  w=%.3f \t drphit*freq=%.3f \t weight=%.3f\n" % (fnum,w,wwn[jn][1],wwn[jn][2]**2)
              jn += 1
           elif (w>(minfreq)): 
              fstr += "#@@ %5d  w=%.3f \t drphit*freq=%.3f \t weight=%.3f\n" % (fnum,w,wwp[jp][1],wwp[jp][2]**2)
              jp += 1
           else:
              fstr += "#@@ %5d  w=%.3f \t drphit*freq=%.3f \t weight=%.3f\n" % (fnum,w,wwz[jz][1],wwz[jz][2]**2)
              jz += 1
         

      tstr =  '#@@@@@@@@@@@@@@@@@@@@@@@@ START ROTOR @@@@@@@@@@@@@@@@@@@@@@@@@@' + eoln
      tstr +=  '#@@' + eoln
      tstr +=  headerdata
      tstr +=  '#@@' + eoln
      tstr +=  '#@@ Cannonical Formula Results for Hindered Rotation:' + eoln
      tstr +=  '#@@    Nmax   = %18d ' % (Nmax) + eoln
      tstr +=  '#@@    T      = %18.3f K' % (T) + eoln
      tstr +=  '#@@    sigma  = %18.6f' % (sym_num) + eoln
      tstr +=  '#@@    Im     = %18.6f' % (Im) + eoln
      tstr +=  '#@@    Qf     = %18.6f' % (Q) + eoln
      tstr +=  '#@@    dQf/dT = %18.6f 1/K' % (Qp) + eoln
      tstr +=  '#@@    Uf     = %18.6f kcal/mol (%18.6f au)' % (Uf/1000.0,Uf/(1000.0*23.06*27.2116)) + eoln
      tstr +=  '#@@    Sf     = %18.6f cal/mol-K' % (S) + eoln
      tstr +=  '#@@' + eoln
      tstr +=  '#@@    Uvib(bad)= %18.6f kcal/mol  (%18.6f au)' % (Evib*23.06*27.2116,Evib) + eoln
      tstr +=  '#@@    Svib(bad)= %18.6f cal/mol-K (%18.6f au)' % (Svib*1000*23.06*27.2116,Svib) + eoln
      tstr +=  '#@@' + eoln
      if (hrotorzero):
         tstr +=  '#@@ Setting hrotor correction to zero' + eoln
         Ecorrect = 0.0
         Scorrect = 0.0
      tstr +=  '#@@    Ucorrect = %18.6f kcal/mol  (%18.6f au)' % (Ecorrect*23.06*27.2116,Ecorrect) + eoln
      tstr +=  '#@@    Scorrect = %18.6f cal/mol-K (%18.6f au)' % (Scorrect*1000*23.06*27.2116,Scorrect) + eoln

      tstr +=  '#@@' + eoln
      tstr +=  fstr
      tstr +=  '#@@' + eoln
      tstr +=  '#@@    hindered potential ='
      for p in potential:
         tstr += " %.6f" % p
      tstr +=  eoln
      tstr +=  '#@@' + eoln
      tstr +=  '#@@@@@@@@@@@@@@@@@@@@@@@@ END ROTOR   @@@@@@@@@@@@@@@@@@@@@@@@@@' + eoln
      

   return tstr


def replace_hrotor_blob(hrotors_blob,hrotor_blob):
   eoln = '\n'
   bstr =  '#@@@@@@@@@@@@@@@@@@@@@@@@ START ROTOR @@@@@@@@@@@@@@@@@@@@@@@@@@' + eoln
   estr =  '#@@@@@@@@@@@@@@@@@@@@@@@@ END ROTOR   @@@@@@@@@@@@@@@@@@@@@@@@@@' + eoln
   rrr = hrotor_blob.split(bstr)[1].split(estr)[0]
   xxx = '#@@   rbond    =' + hrotor_blob.split('#@@   rbond    =')[1].split('\n')[0]
   yyy = '#@@   rgroup   =' + hrotor_blob.split('#@@   rgroup   =')[1].split('\n')[0]
   for aaa in hrotors_blob.split(bstr)[1:]:
      bbb = aaa.split(estr)[0]
      if (xxx in bbb) and (yyy in bbb):
         hrotors_blob = hrotors_blob.replace(bbb,rrr)

   return hrotors_blob

      

#############################################
#                                           #
#             submit_esmiles_xyz            #
#                                           #
#############################################
def submit_esmiles_xyz(esmiles,xyz,vtag=None,machine=None):
   xyzfile = wrkdir + "/" + tmpxyz99
   ofile = open(xyzfile,'w')
   ofile.write(xyz)
   ofile.close()

   result = "\nSubmitting the following esmiles,xyz: " + esmiles + "\n"
   result += "xyz=\n"
   result += xyz + "\n"
   cmd0 = ''

   if ((machine!=None) and (machine!='')):   cmd0 += ' -m ' + machine


   property = ''
   theory_property = ''
   xc_property     = ''
   basis_property  = ''
   basisHZ           = ''
   basisHZ_property  = ''
   if 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'ccsd' in esmiles:
      theory='ccsd';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='50.0';solvation_type='None';
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='50.0';solvation_type='None';
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]

   charge = smiles2charge(esmiles.strip().split()[0])
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0])

   mult = xyz2mult(xyzfile,charge)
   print(" submit_esmiles_xyz mult0=",mult)
   if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0])
   print(" submit_esmiles_xyz mult1=",mult)

   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'property{' in esmiles: property = esmiles.split('property{')[1].split('}')[0]
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles: xc_property = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles: basis_property = removespace_basis(esmiles.split('basis_property{')[1].split('}')[0])
   if 'basisHZ_property{' in esmiles: basisHZ_property = removespace_basis(esmiles.split('basisHZ_property{')[1].split('}')[0])
   if 'basisHZ{' in esmiles:  basisHZ  = removespace_basis(esmiles.split('basisHZ{')[1].split('}')[0])
   if 'basis{' in esmiles:  basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
   if 'ry' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*0.5
      basis = '%f' % xb
   if 'hartree' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*1.0
      basis = '%f' % xb

   if 'ry' in basis_property.lower():
      xb = evalnum(basis_property.strip().split()[0])*0.5
      basis_property = '%f' % xb
   if 'hartree' in basis_property.lower():
      xb = evalnum(basis_property.strip().split()[0])*1.0
      basis_property = '%f' % xb

   cmd0 += ' -w  -t ' + theory + " -b '" + basis + "' -x " + xc + " -y " + solvation_type 
   cmd0 += " -s %d" % mult 
   cmd0 += " -q %d" % charge 
   if (property!=''): cmd0 += ' -p ' + property
   if (theory_property!=''): cmd0 += ' -k ' + theory_property
   if (xc_property!=''):     cmd0 += ' -l ' + xc_property
   if (basis_property!=''):  cmd0 += ' -o ' + basis_property
   if (basisHZ_property!=''):cmd0 += ' -n ' + basisHZ_property
   if (basisHZ!=''):         cmd0 += ' -z ' + basisHZ
   if ((vtag!=None) and (vtag!='')):  cmd0 += " -v " + vtag

   #ofile = open(xyzfile,'w')
   #ofile.write(xyz)
   #ofile.close()

   if machine==None:
      cmd1 = tnt_submit + cmd0 + " " + xyzfile
   elif machine.lower()!="shirky":
      cmd1 = tnt_submit + cmd0 + " " + xyzfile
   else:
      tmp_esmiles = xyzfile + " " + " ".join(esmiles.split()[1:])
      cmd1 = chemdb_queue 
      if ((vtag!=None) and (vtag!='')):  cmd1 += " -v " + vtag
      cmd1 +=   ' -a \"' + tmp_esmiles + '\"'
      #cmd1 = chemdb_queue -a + ' \"' + tmp_esmiles + '\"'

   print("submit esmiles cmd1 = " + cmd1)
      

   try:
      result += subprocess.check_output(cmd1,shell=True).decode("utf-8")
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print(result)
   return result


###############################################
#                                             #
#            insert_abbreviation              #
#                                             #
###############################################

def insert_abbreviation(hup,dbfile,abrev_table,abbreviation, 
                        iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms, 
                        smiles,csmiles,esmiles,charge,mult,xyz_blob, 
                        chemical_structure_asciiart,bonding_string,covalent_string,optimized):
#
#+-----------------------------+---------+------+-----+---------+----------------+
#| Field                       | Type    | Null | Key | Default | Extra          |
#+-----------------------------+---------+------+-----+---------+----------------+
#| Id                          | int(11) | NO   | PRI | NULL    | auto_increment |
#| abbreviation                | text    | YES  |     | NULL    |                |
#| iupac                       | text    | YES  |     | NULL    |                |
#| mformula                    | text    | YES  |     | NULL    |                |
#| InChI                       | text    | YES  |     | NULL    |                |
#| smiles                      | text    | YES  |     | NULL    |                |
#| csmiles                     | text    | YES  |     | NULL    |                |
#| esmiles                     | text    | YES  |     | NULL    |                |
#| charge                      | int(11) | YES  |     | NULL    |                |
#| mult                        | int(11) | YES  |     | NULL    |                |
#| xyz_blob                    | blob    | YES  |     | NULL    |                |
#| InChIKey                    | text    | YES  |     | NULL    |                |
#| synonyms                    | text    | YES  |     | NULL    |                |
#| cid                         | text    | YES  |     | NULL    |                |
#| cas                         | text    | YES  |     | NULL    |                |
#| kegg                        | text    | YES  |     | NULL    |                |
#| chemical_structure_asciiart | text    | YES  |     | NULL    |                |
#| bonding_string              | text    | YES  |     | NULL    |                |
#| covalent_string             | text    | YES  |     | NULL    |                |
#| optimized                   | text    | YES  |     | NULL    |                |
#+-----------------------------+---------+------+-----+---------+----------------+

#   if ("." in smiles):
#      print("insert_abbreviation: dot in smiles...not adding to abbreviation table")
#      return

   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlinsert = "insert into " + abrev_table
   sqlinsert += " (abbreviation,iupac,mformula,InChI,InChIKey,"
   sqlinsert += "cid,cas,kegg,synonyms,smiles,"
   sqlinsert += "csmiles,esmiles,charge,mult,xyz_blob,"
   sqlinsert += "chemical_structure_asciiart,bonding_string,covalent_string,optimized) values ("
   sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
   if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')
   insertlist = []
   insertlist.append(abbreviation)
   insertlist.append(iupac)
   insertlist.append(mformula)
   insertlist.append(InChI)
   insertlist.append(InChIKey)

   insertlist.append(cid)
   insertlist.append(cas)
   insertlist.append(kegg)
   insertlist.append(synonyms)
   insertlist.append(smiles)

   insertlist.append(csmiles)
   insertlist.append(esmiles)
   insertlist.append(charge)
   insertlist.append(mult)
   insertlist.append(xyz_blob)

   insertlist.append(chemical_structure_asciiart)
   insertlist.append(bonding_string)
   insertlist.append(covalent_string)
   if optimized:
      insertlist.append("yes")
   else:
      insertlist.append("no")
  
   sqlcheck = "select count(1) from " + abrev_table + " where "
   sqlcheck += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and "
   sqlcheck += "charge=? and mult=? and bonding_string=? and covalent_string=? limit 1;"
   if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')
   checklist = []
   checklist.append(iupac)
   checklist.append(InChI)
   checklist.append(InChIKey)
   checklist.append(smiles)
   checklist.append(csmiles)
   checklist.append(esmiles)
   checklist.append(charge)
   checklist.append(mult)
   checklist.append(bonding_string)
   checklist.append(covalent_string)

   sqlcheck2 = "select count(1) from " + abrev_table + " where "
   sqlcheck2 += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and "
   sqlcheck2 += "charge=? and mult=? and bonding_string=? and covalent_string=? and xyz_blob=? limit 1;"
   if (not issqlite3): sqlcheck2 = sqlcheck2.replace('?','%s')
   checklist2 = []
   checklist2.append(iupac)
   checklist2.append(InChI)
   checklist2.append(InChIKey)
   checklist2.append(smiles)
   checklist2.append(csmiles)
   checklist2.append(esmiles)
   checklist2.append(charge)
   checklist2.append(mult)
   checklist2.append(bonding_string)
   checklist2.append(covalent_string)
   checklist2.append(xyz_blob)

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      #dbcon = MySQLdb.connect(host,user,pss,dbfile)
      dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')
   
   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      row = cur.fetchone()

      duplicate = (row[0]>0)
      if ((not duplicate) or (optimized)):
         cur.execute(sqlcheck2,checklist2)
         row2 = cur.fetchone()

         duplicate2 = (row2[0]>0)
         if (not duplicate2):
            print("inserting into " + abrev_table)
            cur.execute(sqlinsert,insertlist)




#############################################
#                                           #
#             delete_esmiles                #
#                                           #
#############################################

def delete_esmiles(hup,dbfile,table,esmiles):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   reaction_hash = ''
   reaction_gamma = ''
   reaction_kappa = ''
   theory_base=''
   xc_base=''
   basis_base=''
   basisHZ_base=''
   basisHZ=''
   basisHZ1=''
   basisHZ2=''
   basisHZ3=''
   theory_property = ''
   xc_property = ''
   basis_property=''
   basisHZ_property=''
   if 'qsharp_chem' in esmiles:
      theory='qsharp_chem';xc='unknown';basis='sto-3g';solvation_type='COSMO'; charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'sto-3g'
      basisHZ1 = 'sto-3g'
   elif 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'ccsd' in esmiles:
      theory='ccsd';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None';charge='0';mult='1'; theory_property='';xc_property='';basis_property=''
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None';charge='0';mult='1'; theory_property='';xc_property='';basis_property=''
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';theory_property='';xc_property='';basis_property=''
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';theory_property='';xc_property='';basis_property=''
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'

   
   esmiles1=esmiles.strip()
   ss = esmiles1.split()

   csmiles = cannonicalsmiles(ss[0])
   inchi    = smiles2InChI(ss[0])
   inchikey = smiles2InChIKey(ss[0])
   xyzfile = wrkdir + "/" + tmpxyz99
  
   smiles2xyz(ss[0],xyzfile)
   
   inchi2    = xyz2InChI(xyzfile)
   inchikey2 = xyz2InChIKey(xyzfile)

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
   if 'basisHZ{' in esmiles:  
       basisHZ  = removespace_basis(esmiles.split('basisHZ{')[1].split('}')[0])
       basisHZ1 = basisHZ
       basisHZ2 = basisHZ
       basisHZ3 = basisHZ
   if 'theory_base{' in esmiles: theory_base = esmiles.split('theory_base{')[1].split('}')[0]
   if 'xc_base{' in esmiles:     xc_base     = esmiles.split('xc_base{')[1].split('}')[0]
   if 'basis_base{' in esmiles:  basis_base  = removespace_basis(esmiles.split('basis_base{')[1].split('}')[0])
   if 'basisHZ_base{' in esmiles:  basisHZ_base  = removespace_basis(esmiles.split('basisHZ_base{')[1].split('}')[0])
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles:     xc_property     = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles:  basis_property  = removespace_basis(esmiles.split('basis_property{')[1].split('}')[0])
   if 'basisHZ_property{' in esmiles:  basisHZ_property  = removespace_basis(esmiles.split('basisHZ_property{')[1].split('}')[0])

   if 'reaction_hash' in esmiles:  reaction_hash = esmiles.split('reaction_hash{')[1].split('}')[0].strip()
   if 'reaction_gamma' in esmiles: reaction_gamma = evalnum(esmiles.split('reaction_gamma{')[1].split('}')[0].strip())
   if 'reaction_kappa' in esmiles: reaction_kappa = evalnum(esmiles.split('reaction_kappa{')[1].split('}')[0].strip())
   
   charge = smiles2charge(ss[0])
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0])
  
   mult = esmiles2mult_set(ss[0],charge,esmiles)
   #mult   = smiles2mult(ss[0],charge)
 
   #if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0])
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]

   if (theory_property==''): theory_property = theory
   if (xc_property==''):     xc_property = xc
   if (basis_property==''):  basis_property = basis
   if (basisHZ_property==''):  basisHZ_property = basisHZ

   #hasHZ = inchihasHZ(inchi) and (basis!="semiempirical")
   #notonlyHZ = (not inchionlyHZ(inchi)) or (basis=="semiempirical")
   hasHZ = inchihasHZ(inchi2) and (basis!="semiempirical") and (theory!='pspw') and (theory!='pspw4') and (theory!='paw')
   notonlyHZ = (not inchionlyHZ(inchi2)) or (basis=="semiempirical") or (theory=='pspw') or (theory=='pspw4') or (theory=='paw')

   print("delete_esmiles inchi =",inchi)
   print("delete_esmiles inchi2=",inchi2)
   print("delete_esmiles inchi =",inchikey)
   print("delete_esmiles inchi2=",inchikey2)
   print("delete_esmiles theory=",theory)
   print("delete_esmiles xc    =",xc)
   if (notonlyHZ):  print("delete_esmiles basis =",basis)
   if (hasHZ):      print("delete_esmiles basisHZ =",basisHZ)
   if (hasHZ):      print("delete_esmiles basisHZ1 =",basisHZ1)
   if (hasHZ):      print("delete_esmiles basisHZ2 =",basisHZ2)
   if (hasHZ):      print("delete_esmiles basisHZ2 =",basisHZ2)
   if (hasHZ):      print("delete_esmiles basisHZ3 =",basisHZ3)
   if (theory_base!=''): print("delete_esmiles theory_base=",theory_base)
   if (xc_base!=''):     print("delete_esmiles xc_base=",xc_base)
   if (notonlyHZ) and (basis_base!=''): print("delete_esmiles basis_base=",basis_base)
   if (hasHZ) and (basisHZ_base!=''):   print("delete_esmiles basisHZ_base=",basisHZ_base)
   print("delete_esmiles theory_property=",theory_property)
   print("delete_esmiles xc_property    =",xc_property)
   if (notonlyHZ): print("delete_esmiles basis_property =",basis_property)
   if (hasHZ):     print("delete_esmiles basisHZ_property =",basisHZ_property)
   print("delete_esmiles charge=",charge)
   print("delete_esmiles mult  =",mult)
   print("delete_esmiles solvation_type=",solvation_type)
   if (reaction_hash!=''):   print("delete_esmiles reaction_hash =" + reaction_hash)
   if (reaction_gamma!=''):  print("delete_esmiles reaction_gamma =",reaction_gamma)
   if (reaction_kappa!=''):  print("delete_esmiles reaction_kappa =",reaction_kappa)

   eps = 1.0e-6
   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(theory)
   checklist.append(xc)
   if (notonlyHZ): checklist.append(basis)
   if (hasHZ): 
      checklist.append(basisHZ)
      checklist.append(basisHZ1)
      checklist.append(basisHZ2)
      checklist.append(basisHZ3)
   if (theory_base!=''): checklist.append(theory_base)
   if (xc_base!=''):     checklist.append(xc_base)
   if (notonlyHZ) and (basis_base!=''): checklist.append(basis_base)
   if (hasHZ) and (basisHZ_base!=''):   checklist.append(basisHZ_base)
   checklist.append(theory_property)
   checklist.append(xc_property)
   if (notonlyHZ): checklist.append(basis_property)
   if (hasHZ):     checklist.append(basisHZ_property)
   if (reaction_hash!=''):  checklist.append(reaction_hash)
   if (reaction_gamma!=''):
      checklist.append(reaction_gamma-eps)
      checklist.append(reaction_gamma+eps)
   if (reaction_kappa!=''):
      checklist.append(reaction_kappa-eps)
      checklist.append(reaction_kappa+eps)
   checklist.append(charge)
   checklist.append(mult)
   checklist.append(solvation_type)

   wherestr =  " where (InChI=? or InChI=? or InChIKey=? or InChIKey=?)"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   if (notonlyHZ): wherestr += " and basis=?"
   #if (hasHZ):     wherestr += " and basisHZ=?"
   if (hasHZ):     wherestr += " and (basisHZ=? or basisHZ=? or basisHZ=? or basisHZ=?)"

   if (theory_base!=''): wherestr += " and theory_base=?"
   if (xc_base!=''):     wherestr += " and xc_base=?"
   if (notonlyHZ) and (basis_base!=''): wherestr += " and basis_base=?"
   if (hasHZ) and (basisHZ_base!=''):   wherestr += " and basisHZ_base=?"

   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   if (notonlyHZ): wherestr += " and basis_property=?"
   if (hasHZ):     wherestr += " and basisHZ_property=?"
   if (reaction_hash!=''):  wherestr += " and constraint_string=?"
   if (reaction_gamma!=''): wherestr += " and constraint_value>=? and constraint_value<=?"
   if (reaction_kappa!=''): wherestr += " and constraint_spring>=? and constraint_spring<=?"
   wherestr += " and charge=?"
   wherestr += " and mult=?"
   wherestr += " and solvation_type=?"

   if (issqlite3):
      sqlcheck  = "select * from " + table + wherestr
      sqldelete = "delete from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')
      sqldelete = "delete from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      #dbcon = MySQLdb.connect(host,user,pss,dbfile)
      dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)>0):
         cur.execute(sqldelete,checklist)




###############################################
#                                             #
#            insert_calculation               #
#                                             #
###############################################

def insert_calculation(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles,noresubmit):

  if (hup=='sqlite3'):
      issqlite3 = True
  else:
      issqlite3 = False

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2
  outfile_without_hash  = wrkdir + "/"+outfile99

  if (os.path.exists(outfile)):
    #if (parse_jobfinished(outfile)):
    try:

    
      with open(outfile,'r') as ff:
         aa = ff.read()
     
      aa = aa.replace('#','')
      
      with open(outfile_without_hash,'w') as ff:
         ff.write(aa)

      nwfilename = nwmachine + "/" + outfile[outfile.rfind('/')+1:] + dd1

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")  

      ### add yaml file ###
      theory = parse_theory(outfile)
      if (theory=="qsharp_chem"): 
         myyamlfile = wrkdir + "/" + "microsoft_qsharp_chem.yaml" 
         extra_datafiles = myyamlfile + " " + extra_datafiles
         matrix_elements = parse_matrix_elements(outfile)
         matrix_elements_blob =''
         if (len(matrix_elements)>0):
            #mblob = yaml.dump(mdict, default_flow_style=False)
            #matrix_elements_blob = '\n' + '\n"$schema": https://microsoft.com/qchem-0.1.schema.json\n\n'
            matrix_elements_blob = '\n' + '\n"$schema": https://raw.githubusercontent.com/Microsoft/Quantum/master/Chemistry/Schema/broombridge-0.1.schema.json\n\n'
            matrix_elements_blob += yaml.dump(matrix_elements)
         with open(myyamlfile,'w') as ff: 
            ff.write(matrix_elements_blob)
         qsharp_norbs  = parse_qsharp_norbs(outfile)
         qsharp_nalpha = parse_qsharp_nalpha(outfile)
         qsharp_nbeta  = parse_qsharp_nbeta(outfile)
         qsharp_nroots = parse_qsharp_nroots(outfile)

      nwdatafiles = ""
      nwdatacopy = []
      for bb in extra_datafiles.strip().split():
         bbb = nwmachine + "/" + bb[bb.rfind('/')+1:] + dd1 + " "
         nwdatafiles += bbb 
         nwdatacopy.append((bb.strip(),bbb.strip()))
      nwdatafiles = nwdatafiles.strip()

      constraints = parse_reactionconstraints(outfile)
      #print("constraints=",constraints)

      jobok    = parse_calculation_ok(outfile_without_hash)
      program  = parse_program(outfile_without_hash)
      machine  = parse_machine(outfile_without_hash)
      ncpu     = parse_ncpu(outfile_without_hash)
      wall_time= parse_wall_time(outfile_without_hash)
      energy   = parse_energy(outfile_without_hash)
      enthalpy = parse_enthalpy(outfile_without_hash)
      entropy  = parse_entropy(outfile_without_hash)
      cosmo    = parse_cosmo_smd(outfile_without_hash)
      nmr_blob = parse_nmrblob(outfile_without_hash)
      solvation_dielectric = parse_cosmo_dielectric(outfile_without_hash)
      calculation_type = ''
      if (constraints['constraint_type']!=''): calculation_type += 'l'
      if (cosmo!=0.0):
         if (cosmo==(-987654.3210)): cosmo = 0.0
         solvation_type   = "COSMO-SMD"
         solvation_energy = cosmo
         cosmo_e          = parse_cosmo_smd_e(outfile_without_hash)
         if (abs(cosmo_e-energy)<1.0e-6):
            calculation_type += 'y'
            solvation_type = "COSMO-SMD-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
      else:
         cosmo           = parse_cosmo(outfile_without_hash)
         cosmo_intrinsic = parse_cosmo_intrinsic(outfile_without_hash)
         if (cosmo==(-987654321.0)) and cosmo_intrinsic:
            calculation_type += 'y'
            solvation_type = "COSMO-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
         elif (cosmo!=0.0):
            if (cosmo==(-987654.3210)): cosmo = 0.0
            solvation_energy = cosmo
            if (cosmo_intrinsic):
               calculation_type += 'y'
               solvation_type   = "COSMO-intrinsic"
            else:
               solvation_type   = "COSMO"
         else:
            solvation_type   = "None"
            solvation_energy = 0.0

      if ("COSMO-SMD" in solvation_type):
         svnt = parse_cosmo_smd_solvent(outfile_without_hash)
         if (svnt!="water") and (svnt!="h2o"):
            solvation_type = solvation_type.strip() + ":" + svnt

      if (energy<9.0e9):   calculation_type += 'o'
      if (enthalpy!=0.0): 
         ah = parse_analytic_hessian(outfile_without_hash)
         if ah=='Analytic':
            calculation_type += 'w'
         else:
            calculation_type += 'v'

      if (cosmo!=0.0) or (solvation_type=="COSMO") or (solvation_type=="COSMO-SMD"): calculation_type += 'c'
      if (nmr_blob!=''):  calculation_type += 'n'

      charge = parse_charge(outfile_without_hash)
      mult   = parse_mult(outfile_without_hash)

      #theory = parse_theory(outfile)
      xc     = parse_xc(outfile)
      basis  = parse_basis(False,outfile)
      basisHZ= parse_basis(True,outfile)
      if theory=="ccsd(t)": xc = "unknown"
      if theory=="ccsd":    xc = "unknown"
      if theory=="qsharp_chem":    xc = "unknown"
      if theory=="mp2":     xc = "unknown"
      if theory=="hf":      xc = "unknown"
      if theory=="uhf":     xc = "unknown"

      theory_base = parse_base_theory(outfile)
      xc_base     = parse_base_xc(outfile)
      basis_base  = parse_base_basis(False,outfile)
      basisHZ_base= parse_base_basis(True,outfile)
      if theory_base=="hf":      xc_base = "unknown"
      if theory_base=="uhf":     xc_base = "unknown"

      theory_property = parse_theory(outfile)
      xc_property     = parse_xc(outfile)
      basis_property  = parse_basis(False,outfile)
      basisHZ_property= parse_basis(True,outfile)
      if theory_property=="hf":      xc_property = "unknown"
      if theory_property=="uhf":     xc_property = "unknown"

      if ((theory=="am1") or (theory=="pm3") or (theory=="mndo") or (theory=="mindo3")):  
         xc             = "unknown"
         basis          = "semiempirical"
         basisHZ        = "unknown"
         xc_property    = "unknown"
         basis_property = "semiempirical"
         basisHZ_property = "unknown"
         xc_base        = "unknown"
         basis_base     = "unknown"
         basisHZ_base     = "unknown"

      try:
         msurface = gen_surfaceareas(outfile_without_hash)
         ecd = 5.0*sum(msurface[0])/1000.0 + 0.86
         ehd = 25.0*sum(msurface[0])/1000.0
      except:
         msurface=[[0.0],[0.0]]
         ecd = 0.0
         ehd = 0.0

      if ('pspw' in theory):
         unitcell = parse_unitcell_calculation(outfile_without_hash)
      else:
         unitcell = ''

      xyzblob  = parse_xyzblob(outfile_without_hash,xyzfile)
      freqblob = parse_freqblob(outfile_without_hash)
      nfreqs   = parse_number_negative_frequencies(outfile_without_hash)
      eigblob  = parse_eigblob(outfile_without_hash)
      smiles   = xyz2smiles(xyzfile)
      InChI    = smiles2InChI(smiles)
      InChIKey = xyz2InChIKey(xyzfile)

      cid      = pubchem_smiles2cid(smiles)
      cas      = pubchem_smiles2cas(smiles)
      kegg     = pubchem_smiles2kegg(smiles)
      synonyms = pubchem_smiles2synonyms(smiles)
      #InChI2 = xyz2InChI(xyzfile)
      mformula = xyz_molecular_formula(xyzfile)
      (bonding_string, covalent_string) = xyz_bonding_strings(xyzfile)
   
      osmiles   = parse_osmiles(outfile_without_hash)
      client    = parse_client(outfile_without_hash)
      postsmiles   = parse_postsmiles(outfile_without_hash)
      if (osmiles=="nosmiles"): osmiles = smiles
      oInChI    = smiles2InChI(osmiles)
      oInChIKey = smiles2InChIKey(osmiles)

      iupac  = pubchem_smiles2iupac(smiles)
      if (iupac==''): iupac = smiles

      #smiles2 = pubchem_smiles2canonicalsmiles(smiles)
      smiles2 = cannonicalsmiles(smiles)
      chemical_structure_asciiart = smiles2ascii(smiles)

      if (mult==2): iupac += " doublet radical"
      if (mult==3): iupac += " triplet radical"
      if (mult==4): iupac += " quqrtet radical"
      if (mult==5): iupac += " quintet radical"
      if (mult==6): iupac += " sextet radical"
      if (mult==7): iupac += " septet radical"
      if (mult==8): iupac += " octet radical"
      if (mult==9): iupac += " nonet radical"
      if (mult==10): iupac += " decet radical"
      if (mult>10):  iupac += " large radical"
      if (charge==-4): iupac += " tetraanion"
      if (charge==-3): iupac += " trianion"
      if (charge==-2): iupac += " dianion"
      if (charge==-1): iupac += " anion"
      if (charge==+1): iupac += " cation"
      if (charge==+2): iupac += " dication"
      if (charge==+3): iupac += " trication"
      if (charge==+4): iupac += " tetracation"

      if (smiles2!=""):
         csmiles  = smiles2
      else:
         smiles3 = cannonicalsmiles(smiles)
         csmiles = smiles3

      inserting = (energy<=9.0e9) and (smiles!='')
      sitkoff  = ecd
      honig    = ehd
      ASA      = sum(msurface[0])
      SAV      = sum(msurface[1])

      if (constraints['constraint_spring']!='') and (constraints['bondings']!=''):
         (freq0,mass0,ethermal0,svib0) = calculate_bondings_constraint_freqthermo(constraints['constraint_spring'],constraints['bondings'],xyzblob,freqblob)
         enthalpy -= ethermal0
         entropy  -= svib0
         constraints['freq0'] = freq0
         constraints['mass0'] = mass0
         constraints['ethermal0'] = ethermal0
         constraints['svib0'] = svib0


      esmiles = csmiles 
      esmiles += " theory{%s}" % theory
      esmiles += " xc{%s}" % xc
      esmiles += " basis{%s}" % basis
      esmiles += " solvation_type{%s}" % solvation_type
      esmiles += " ^{%d}" % charge
      if (theory_base!="unknown"): esmiles += " theory_base{%s}" % theory_base
      if (xc_base!="unknown"):     esmiles += " xc_base{%s}" % xc_base
      if (basis_base!="unknown"):  esmiles += " basis_base{%s}" % basis_base

      if (basisHZ!="unknown"):          esmiles += " basisHZ{%s}" % basisHZ
      #if (basisHZ_property!="unknown"): esmiles += " basisHZ_property{%s}" % basisHZ_property
      if (basisHZ_base!="unknown"):     esmiles += " basisHZ_base{%s}" % basisHZ_base

      if (mult>1): esmiles += " mult{%d}" % mult
      if (nmr_blob!=''): esmiles += " property{nmr}"
      if constraints['constraint_type']!='':    esmiles += " reaction_type{"+constraints['constraint_type']+"}"
      if constraints['constraint_indexes']!='': esmiles += " reaction_indexes{"+constraints['constraint_indexes']+"}"
      if constraints['constraint_value']!='':   esmiles += " reaction_gamma{%f}" % constraints['constraint_value']
      if constraints['constraint_spring']!='':  esmiles += " reaction_kappa{%f}" % constraints['constraint_spring']
      if constraints['constraint_string']!='':  esmiles += " reaction_hash{"+constraints['constraint_string']+"}"
      if (theory=="qsharp_chem"): esmiles += " qsharp_chem_filling{%d %d %d}" % (qsharp_norbs,qsharp_nalpha,qsharp_nbeta)
      if (theory=="qsharp_chem") and (qsharp_nroots>0): esmiles += " qsharp_chem_nroots{%d}" % (qsharp_nroots)
      print() 
      print("iupac                              =",iupac)
      print("mformula                           =",mformula, " foundHZ=",mformula_foundHZ(mformula))
      print("InChI                              =",InChI)
      print("InChIKey                           =",InChIKey)
      print("cid                                =",cid)
      print("cas                                =",cas)
      print("kegg                               =",kegg)
      print("synonyms                           =",synonyms)
      #print("InChI2                             =",InChI2)
      print("smiles                             =",smiles)
      print("cannonical smiles                  =",csmiles)
      print("extended smiles                    =",esmiles)
      print("original smiles                    =",osmiles)
      print("bonding_string                     =",bonding_string)
      print("covalent_string                    =",covalent_string)
      print("program                            = ",program)
      print("calculation type                   = ",calculation_type)
      print("theory                             = ",theory)
      print("xc                                 = ",xc)
      print("basis                              = ",basis)
      print("basisHZ                            = ",basisHZ)
      if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
         print("theory_base                        = ",theory_base)
         print("xc_base                            = ",xc_base)
         print("basis_base                         = ",basis_base)
         print("basisHZ_base                       = ",basisHZ_base)
      print("theory_property                    = ",theory_property)
      print("xc_property                        = ",xc_property)
      print("basis_property                     = ",basis_property)
      print("basisHZ_property                   = ",basisHZ_property)
      if (unitcell!=''): print("unitcell                           = \n" + unitcell)

      print("charge,mult                        = ",charge,mult)
      print("energy                             = ",energy)
      print("enthalpy                           = ",enthalpy)
      print("entropy                            = ",entropy)
      print("negative frequencies               = ",nfreqs)
      print("solvation energy                   = ",solvation_energy,"  solvation type=",solvation_type)
      print("solvation dielectric               = ",solvation_dielectric)
      print("Sitkoff cavity dispersion          = ",ecd)
      print("Honig cavity dispersion            = ",ehd)
      print("ASA solvent accesible surface area = ",ASA)
      print("SAV solvent accesible volume       = ",SAV)

      if constraints['constraint_type']!='':    print("reaction_type                      = " +constraints['constraint_type'])
      if constraints['constraint_indexes']!='': print("reaction_indexes                   = " + constraints['constraint_indexes'])
      if constraints['constraint_value']!='':   print("reaction_gamma                     = %f" % constraints['constraint_value'])
      if constraints['constraint_value1']!='':  print("reaction_gamma1                    = %f" % constraints['constraint_value1'])
      if constraints['constraint_spring']!='':  print("reaction_kappa                     = %f" % constraints['constraint_spring'])
      if constraints['constraint_string']!='':  print("reaction_hash                      = " + constraints['constraint_string'])
      if constraints['bondings']!='':           print("bondings                           = " + constraints['bondings'])
      if 'mass0' in constraints:                print("reaction_mass                      = %f" % constraints['mass0'])
      if 'freq0' in constraints:                print("reaction_frequency                 = %f" % constraints['freq0'])
      if 'ethermal0' in constraints:            print("reaction_ethermal0                 = %f" % constraints['ethermal0'])
      if 'svib0' in constraints:                print("reaction_entropy0                  = %f" % constraints['svib0'])
      if theory=="qsharp_chem":                 
         print("qsharp_norbs                       = %d" % qsharp_norbs)
         print("qsharp_nalpha                      = %d" % qsharp_nalpha)
         print("qsharp_nbeta                       = %d" % qsharp_nbeta)
         print("qsharp_nroots                      = %d" % qsharp_nroots)

      print("machine                            = ",machine)
      print("ncpu                               = ",ncpu)
      print("wall time                          = ",wall_time)
      print("filename                           = ",nwfilename)
      print("extra_datafiles                    = ",nwdatafiles)
      print("job ok?                            = ",jobok)
      print()
      #if (xyzblob!=''):  print("xyzblob=\n" + xyzblob)
      #if (freqblob!=''): print("freqblob=\n" + freqblob)
      #if (eigblob!=''): print("eigblob=\n" + eigblob)
      print("chemical_structure_asciiart=")
      print(chemical_structure_asciiart)
      print()

      #set the mytable
      if (jobok):
         mytable = table
      else:
         mytable = bad_table

      if (nmr_blob!=''):
         sqlinsert = "insert into " + mytable
         sqlinsert += " (iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms,smiles,csmiles,esmiles,program,calculation_type,"
         sqlinsert += "theory,xc,basis,"
         if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
            sqlinsert += "theory_base,xc_base,basis_base,"
            if (basisHZ_base!="unknown"): sqlinsert += "basisHZ_base,"
         if (basisHZ!="unknown"): sqlinsert += "basisHZ,"
         if (basisHZ_property!="unknown"): sqlinsert += "basisHZ_property,"
         if (unitcell!=''): sqlinsert += "unitcell,"
         if constraints['constraint_type']!='': sqlinsert += "constraint_type,"
         if constraints['constraint_indexes']!='': sqlinsert += "constraint_indexes,"
         if constraints['constraint_value']!='':  sqlinsert += "constraint_value,"
         if constraints['constraint_value1']!='': sqlinsert += "constraint_value1,"
         if constraints['constraint_spring']!='': sqlinsert += "constraint_spring,"
         if constraints['constraint_string']!='': sqlinsert += "constraint_string,"
         if 'mass0' in constraints:     sqlinsert += "constraint_mass0,"
         if 'freq0' in constraints:     sqlinsert += "constraint_freq0,"
         if 'ethermal0' in constraints: sqlinsert += "constraint_ethermal0,"
         if 'svib0' in constraints:     sqlinsert += "constraint_entropy0,"
         if (theory=="qsharp_chem"):     
            sqlinsert += "matrix_elements_blob,"
            sqlinsert += "qsharp_norbs,"
            sqlinsert += "qsharp_nalpha,"
            sqlinsert += "qsharp_nbeta,"
            sqlinsert += "qsharp_nroots,"
         sqlinsert += "theory_property,xc_property,basis_property,charge,mult,energy,enthalpy,entropy,"
         sqlinsert += "solvation_type,solvation_energy,sitkoff,honig,ASA,SAV,"
         sqlinsert += "xyz_blob,nmr_blob,frequencies_blob,eigenvalues_blob,filename,data_filenames,chemical_structure_asciiart,"
         sqlinsert += "machine,ncpu,wall_time,"
         sqlinsert += "negative_frequencies,date_time,osmiles,oInChI,oInChIKey,bonding_string,covalent_string) values ("
         if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
            sqlinsert += "?,?,?,"
            if (basisHZ_base!="unknown"): sqlinsert += "?,"
         if (basisHZ!="unknown"):          sqlinsert += "?,"
         if (basisHZ_property!="unknown"): sqlinsert += "?,"
         if (unitcell!=''): sqlinsert += "?,"
         if constraints['constraint_type']!='': sqlinsert += "?,"
         if constraints['constraint_indexes']!='': sqlinsert += "?,"
         if constraints['constraint_value']!='':  sqlinsert += "?,"
         if constraints['constraint_value1']!='': sqlinsert += "?,"
         if constraints['constraint_spring']!='': sqlinsert += "?,"
         if constraints['constraint_string']!='': sqlinsert += "?,"
         if 'mass0' in constraints:     sqlinsert += "?,"
         if 'freq0' in constraints:     sqlinsert += "?,"
         if 'ethermal0' in constraints: sqlinsert += "?,"
         if 'svib0' in constraints:     sqlinsert += "?,"
         if (theory=="qsharp_chem"):    sqlinsert += "?,?,?,?,?,"
         sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
      else:
         sqlinsert = "insert into " + mytable
         sqlinsert += " (iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms,smiles,csmiles,esmiles,program,calculation_type,"
         sqlinsert += "theory,xc,basis,"
         if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
            sqlinsert += "theory_base,xc_base,basis_base,"
            if (basisHZ_base!="unknown"): sqlinsert += "basisHZ_base,"
         if (basisHZ!="unknown"): sqlinsert += "basisHZ,"
         if (basisHZ_property!="unknown"): sqlinsert += "basisHZ_property,"
         if (unitcell!=''): sqlinsert += "unitcell,"
         if constraints['constraint_type']!='': sqlinsert += "constraint_type,"
         if constraints['constraint_indexes']!='': sqlinsert += "constraint_indexes,"
         if constraints['constraint_value']!='':  sqlinsert += "constraint_value,"
         if constraints['constraint_value1']!='': sqlinsert += "constraint_value1,"
         if constraints['constraint_spring']!='': sqlinsert += "constraint_spring,"
         if constraints['constraint_string']!='': sqlinsert += "constraint_string,"
         if 'mass0' in constraints:     sqlinsert += "constraint_mass0,"
         if 'freq0' in constraints:     sqlinsert += "constraint_freq0,"
         if 'ethermal0' in constraints: sqlinsert += "constraint_ethermal0,"
         if 'svib0' in constraints:     sqlinsert += "constraint_entropy0,"
         if (theory=="qsharp_chem"):     
            sqlinsert += "matrix_elements_blob,"
            sqlinsert += "qsharp_norbs,"
            sqlinsert += "qsharp_nalpha,"
            sqlinsert += "qsharp_nbeta,"
            sqlinsert += "qsharp_nroots,"
         sqlinsert += "theory_property,xc_property,basis_property,charge,mult,energy,enthalpy,entropy,"
         sqlinsert += "solvation_type,solvation_energy,sitkoff,honig,ASA,SAV,"
         sqlinsert += "xyz_blob,frequencies_blob,eigenvalues_blob,filename,data_filenames,chemical_structure_asciiart,"
         sqlinsert += "machine,ncpu,wall_time,"
         sqlinsert += "negative_frequencies,date_time,osmiles,oInChI,oInChIKey,bonding_string,covalent_string) values ("
         if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
            sqlinsert += "?,?,?,"
            if (basisHZ_base!="unknown"): sqlinsert += "?,"
         if (basisHZ!="unknown"):          sqlinsert += "?,"
         if (basisHZ_property!="unknown"): sqlinsert += "?,"
         if (unitcell!=''): sqlinsert += "?,"
         if constraints['constraint_type']!='': sqlinsert += "?,"
         if constraints['constraint_indexes']!='': sqlinsert += "?,"
         if constraints['constraint_value']!='':  sqlinsert += "?,"
         if constraints['constraint_value1']!='': sqlinsert += "?,"
         if constraints['constraint_spring']!='': sqlinsert += "?,"
         if constraints['constraint_string']!='': sqlinsert += "?,"
         if 'mass0' in constraints:     sqlinsert += "?,"
         if 'freq0' in constraints:     sqlinsert += "?,"
         if 'ethermal0' in constraints: sqlinsert += "?,"
         if 'svib0' in constraints:     sqlinsert += "?,"
         if (theory=="qsharp_chem"):    sqlinsert += "?,?,?,?,?,"
         sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"

      if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

      insertlist = []
      insertlist.append(iupac)
      insertlist.append(mformula)
      insertlist.append(InChI)
      insertlist.append(InChIKey)
      insertlist.append(cid)
      insertlist.append(cas)
      insertlist.append(kegg)
      insertlist.append(synonyms)
      insertlist.append(smiles)
      insertlist.append(csmiles)
      insertlist.append(esmiles)
      insertlist.append(program)
      insertlist.append(calculation_type)
      insertlist.append(theory)
      insertlist.append(xc)
      insertlist.append(basis)
      if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
         insertlist.append(theory_base)
         insertlist.append(xc_base)
         insertlist.append(basis_base)
         if (basisHZ_base!="unknown"): insertlist.append(basisHZ_base)
      if (basisHZ!="unknown"):          insertlist.append(basisHZ)
      if (basisHZ_property!="unknown"): insertlist.append(basisHZ_property)
      if (unitcell!=''): insertlist.append(unitcell)
      if constraints['constraint_type']!='': insertlist.append(constraints['constraint_type'])
      if constraints['constraint_indexes']!='': insertlist.append(constraints['constraint_indexes'])
      if constraints['constraint_value']!='':   insertlist.append(constraints['constraint_value'])
      if constraints['constraint_value1']!='':  insertlist.append(constraints['constraint_value1'])
      if constraints['constraint_spring']!='':  insertlist.append(constraints['constraint_spring'])
      if constraints['constraint_string']!='':  insertlist.append(constraints['constraint_string'])
      if 'mass0' in constraints:     insertlist.append(constraints['mass0'])
      if 'freq0' in constraints:     insertlist.append(constraints['freq0'])
      if 'ethermal0' in constraints: insertlist.append(constraints['ethermal0'])
      if 'svib0' in constraints:     insertlist.append(constraints['svib0'])
      if (theory=="qsharp_chem"):     
         if (issqlite3):
            insertlist.append(sqlite3.Binary(matrix_elements_blob))
         else:
            insertlist.append(matrix_elements_blob)
         insertlist.append(qsharp_norbs)
         insertlist.append(qsharp_nalpha)
         insertlist.append(qsharp_nbeta)
         insertlist.append(qsharp_nroots)
      insertlist.append(theory_property)
      insertlist.append(xc_property)
      insertlist.append(basis_property)
      insertlist.append(charge)
      insertlist.append(mult)
      insertlist.append(energy)
      insertlist.append(enthalpy)
      insertlist.append(entropy)
      insertlist.append(solvation_type)
      insertlist.append(solvation_energy)
      insertlist.append(sitkoff)
      insertlist.append(honig)
      insertlist.append(ASA)
      insertlist.append(SAV)
      #insertlist.append(xyzblob)
      #insertlist.append(freqblob)
      if (issqlite3):
         insertlist.append(sqlite3.Binary(xyzblob))
         if (nmr_blob!=''): insertlist.append(sqlite3.Binary(nmr_blob))
         insertlist.append(sqlite3.Binary(freqblob))
      else:
         insertlist.append(xyzblob)
         if (nmr_blob!=''): insertlist.append(nmr_blob)
         insertlist.append(freqblob)
         insertlist.append(eigblob)
      insertlist.append(nwfilename)
      insertlist.append(nwdatafiles)
      insertlist.append(chemical_structure_asciiart)
      insertlist.append(machine)
      insertlist.append(ncpu)
      insertlist.append(wall_time)
      insertlist.append(nfreqs)
      insertlist.append(time.strftime('%Y-%m-%d %H:%M:%S'))
      insertlist.append(osmiles)
      insertlist.append(oInChI)
      insertlist.append(oInChIKey)
      insertlist.append(bonding_string)
      insertlist.append(covalent_string)

      sqlcheck = "select count(1) from " + mytable + " where "
      sqlcheck += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and program=? and "
      sqlcheck += "calculation_type=? and theory=? and xc=? and basis=? and "
      if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
         sqlcheck += "theory_base=? and xc_base=? and basis_base=? and "
      if (constraints['constraint_string']!=''): sqlcheck += "constraint_string=? and "
      if (constraints['constraint_spring']!=''): sqlcheck += "constraint_spring>=? and constraint_spring<=? and "
      if (constraints['constraint_value']!=''):  sqlcheck += "constraint_value>=?  and constraint_value<=? and "
      if (theory=="qsharp_chem"):     
         sqlcheck += "qsharp_norbs=? and qsharp_nalpha=? and qsharp_nbeta=? and qsharp_nroots=? and "
      sqlcheck += "theory_property=? and xc_property=? and basis_property=? and charge=? and mult=? and "
      sqlcheck += "energy>=? and energy<=? and enthalpy>=? and enthalpy<=? and "
      sqlcheck += "entropy>=? and entropy<=? and solvation_type=? and "
      sqlcheck += "solvation_energy>=? and solvation_energy<=? and sitkoff>=? and sitkoff<=? and "
      sqlcheck += "honig>=? and honig<=? and ASA>=? and ASA<=? and SAV>=? and SAV<=?  limit 1;"

      if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')

      eps = 1.0e-6
      checklist = []
      checklist.append(iupac)
      checklist.append(InChI)
      checklist.append(InChIKey)
      #checklist.append(InChI2)
      checklist.append(smiles)
      checklist.append(csmiles)
      checklist.append(esmiles)
      checklist.append(program)
      checklist.append(calculation_type)
      checklist.append(theory)
      checklist.append(xc)
      checklist.append(basis)
      if (theory=="ccsd(t)") or (theory=="mp2") or (theory=="qsharp_chem") or (theory=="ccsd"):
         checklist.append(theory_base)
         checklist.append(xc_base)
         checklist.append(basis_base)
      if (constraints['constraint_string']!=''): checklist.append(constraints['constraint_string'])
      if (constraints['constraint_spring']!=''): 
         checklist.append(constraints['constraint_spring']-eps)
         checklist.append(constraints['constraint_spring']+eps)
      if (constraints['constraint_value']!=''):
         checklist.append(constraints['constraint_value']-eps)
         checklist.append(constraints['constraint_value']+eps)
      if (theory=="qsharp_chem"):     
         checklist.append(qsharp_norbs)
         checklist.append(qsharp_nalpha)
         checklist.append(qsharp_nbeta)
         checklist.append(qsharp_nroots)
      checklist.append(theory_property)
      checklist.append(xc_property)
      checklist.append(basis_property)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(energy-eps)
      checklist.append(energy+eps)
      checklist.append(enthalpy-eps)
      checklist.append(enthalpy+eps)
      checklist.append(entropy-eps)
      checklist.append(entropy+eps)
      checklist.append(solvation_type)
      checklist.append(solvation_energy-eps)
      checklist.append(solvation_energy+eps)
      checklist.append(sitkoff-eps)
      checklist.append(sitkoff+eps)
      checklist.append(honig-eps)
      checklist.append(honig+eps)
      checklist.append(ASA-eps)
      checklist.append(ASA+eps)
      checklist.append(SAV-eps)
      checklist.append(SAV+eps)


      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         #dbcon = MySQLdb.connect(host,user,pss,dbfile)
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')

      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row = cur.fetchone()
         print('row=',row)
         duplicate = (row[0]>0)
         if ((not duplicate) and (inserting)):
             print("inserting into " + mytable)
             cur.execute(sqlinsert,insertlist)

      #print("dbfile=",dbfile)
      #print("hup=",hup)
      #print("sqlinsert =",sqlinsert)
      #print("INSERTLIST=",insertlist)

      #### insert into sql table ####
      print("duplicate=",duplicate)
      if (inserting) and (not duplicate):
          text2speech("Hi. I just added " + mformula + " molecule calculated with " + theory + " slash " + xc + " slash " + basis + " to the " + mytable + " table in the " + dbfile  + " database.")

          print("Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV)

         
          cmd0 = "scp " + outfile  + " " + nwfilename
          if ((":/" not in nwfilename) and (":/" not in outfile)): 
             cmd0 = cmd0.replace("scp","cp")
             ppth = os.path.dirname(nwfilename)
             if (not os.path.isdir(ppth)):
                cmd9 = "mkdir -p " +  ppth
                pexpect_command(cmd9,nwpassword)
          print(cmd0)
          pexpect_command(cmd0,nwpassword)

          for bbb in nwdatacopy:
             cmd0 = "scp " + bbb[0]  + " " + bbb[1]
             if ((":/" not in bbb[1]) and (":/" not in bbb[0])): 
                cmd0 = cmd0.replace("scp","cp")
                ppth = os.path.dirname(bbb[1])
                if (not os.path.isdir(ppth)):
                   cmd9 = "mkdir -p " + ppth
                   pexpect_command(cmd9,nwpassword)
             print(cmd0)
             pexpect_command(cmd0,nwpassword)

          delete_esmiles(hup,dbfile,requests_table,esmiles)
          if (osmiles != "nosmiles"):
             oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             delete_esmiles(hup,dbfile,requests_table,oesmiles)
      elif (duplicate):
          text2speech("Hello. The " + mformula + " molecule calculated using the " + theory + " slash " + xc + " slash " + basis + " theory already exists in the " + mytable + " table in the " + dbfile  + " database. It was not added.")
          delete_esmiles(hup,dbfile,requests_table,esmiles)
          if (osmiles != "nosmiles"):
             oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             delete_esmiles(hup,dbfile,requests_table,oesmiles)
          print("Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV)
      else:
          text2speech("Hi. The " + mformula + " molecule did not converge. It was not added.")
          print("Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV)
      print()
      print()
      print()

      #### add geometry to abbreviations table ####
      abbreviation = "no abbreviation"
      try:
         if (inserting):
            insert_abbreviation(hup,dbfile,abrev_table,abbreviation, 
                                iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms, 
                                smiles,csmiles,esmiles,charge,mult,xyzblob, 
                                chemical_structure_asciiart,bonding_string,covalent_string,jobok)
      except:
         print("chemdb_add_nwout7: insert abbreviation failed")

    except:
      jobok = True
      print("The job= ",outfile, " was not able to be parsed.")


    #### resubmitjob if not jobok and not an energy only theory ###
    print("THEORY=",theory)
    energyonlytheory = (theory=="mp2") or (theory=="ccsd(t)") or (theory=="qsharp_chem") or (theory=="ccsd") or (noresubmit)
    if ((not jobok) and (inserting) and (not energyonlytheory)):
       (hasxyz,xyz,vtag,mtag) = parse_bad_calculation_xyz(outfile_without_hash)
       if "resubmitjob:" in vtag:
          try:
             nn = evalnum(vtag.split(":")[1])+1
          except:
             nn = 10
       else:
          nn = 1
       if (postsmiles != ""):
          vtag = '"resubmitjob:%d  osmiles:%s:osmiles postsmiles:%s:postsmiles"' % (nn,osmiles,postsmiles)
       elif (client != ""):
          vtag = '"resubmitjob:%d  osmiles:%s:osmiles client:%s:client"' % (nn,osmiles,client)
       else:
          vtag = '"resubmitjob:%d  osmiles:%s:osmiles"' % (nn,osmiles)
       if "machinejob:" in mtag:
          try:
             mmach = mtag.split(":")[1]
          except:
             mmach = ''
       else:
          mmach = ''

       if (hasxyz):
          if (nn<=9):
             if (osmiles != "nosmiles"):
                oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             else:
                oesmiles = esmiles
             result = submit_esmiles_xyz(oesmiles,xyz,vtag,mmach)
             print("submit_esmiles_xyz result=" + result)
             text2speech("Hi. The " + mformula + " molecule which did not converge has been resubmitted with an updated geometry.")
             if (nn==1):
                text2speech("This is the first time the job has been resubmitted.")
             else:
                text2speech("This job has been resubmitted %d times." % nn)
          else:
             print("job failed but not resubmitting because it has already been resubmitted 9 times.")
             text2speech("job failed but not resubmitting because it has already been resubmitted 9 times.")
       else:
          msg = "Job failed but not resubmitting because xyz not found or calculation failed badly."
          print(msg)
          text2speech(msg)
    elif (postsmiles!=''):
       print("submit postsmiles now!!!")
       



###############################################
#                                             #
#            insert_aimd_calculation          #
#                                             #
###############################################

def insert_aimd_calculation(outfile,hup,dbfile,table,solute_table,nwpassword,nwmachine):

  print("Inserting AIMD calculation")
  if (hup=='sqlite3'):
      issqlite3 = True
  else:
      issqlite3 = False

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2

  if (os.path.exists(outfile)):
    try:
      dfilenames = []
      outfile_directory = outfile[:outfile.rfind('/')+1]
      nwfilename = nwmachine +  outfile[outfile.rfind('/')+1:] + dd1
      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")

      dfilenames.append((outfile,nwfilename))

      dfilename1 = outfile_directory + "PAIR_DISTRIBUTION"
      dfilename2 = outfile_directory + "POWER_SPECTRUM"
      dfilename3 = outfile_directory + "VEL_CORRELATION"
      dfilename1_archive = nwmachine + "PAIR_DISTRIBUTION" + dd1
      dfilename2_archive = nwmachine + "POWER_SPECTRUM"    + dd1
      dfilename3_archive = nwmachine + "VEL_CORRELATION"   + dd1

      dfilenames.append((dfilename1,dfilename1_archive))
      dfilenames.append((dfilename2,dfilename2_archive))
      dfilenames.append((dfilename3,dfilename3_archive))

      ### fetch tsample filenames ###
      tsample = parse_tsample_filenames(outfile)
      tsample_archive = []
      for f in tsample:
         ff = nwmachine +  f[f.rfind('/')+1:] + dd1
         ff = ff.replace(",","-")
         tsample_archive.append(ff)
         dfilenames.append((f,ff))
      

      ### fetch gr and hist filenames ###
      radial_distributions_filename = wrkdir + "/" + tmpgr
      radial_distributions_filename_archive = nwmachine + "tsample.gr" + dd1
      dfilenames.append((radial_distributions_filename,radial_distributions_filename_archive))
      gr = parse_gr_filenames(outfile)
      gr_archive = []
      radial_distributions_blob = ''
      for f in gr:
         ff = nwmachine + f[f.rfind('/')+1:] + dd1
         ff = ff.replace(",","-")
         gr_archive.append(ff)
         with open(f,'r') as ffile:
            radial_distributions_blob += "# " + f[f.rfind('/')+1:] +"\n"
            radial_distributions_blob += ffile.read()

      with open(radial_distributions_filename,'w') as ff:
         ff.write(radial_distributions_blob)


      hist_distributions_filename = wrkdir + "/" + tmphist
      hist_distributions_filename_archive = nwmachine + "tsample.hist" + dd1
      dfilenames.append((hist_distributions_filename,hist_distributions_filename_archive))
      hist = parse_hist_filenames(outfile)
      hist_archive = []
      hist_distributions_blob = ''
      for f in hist:
         ff = nwmachine + "/" + f[f.rfind('/')+1:] + dd1
         ff = ff.replace(",","-")
         hist_archive.append(ff)
         with open(f,'r') as ffile:
            hist_distributions_blob += "# " + f[f.rfind('/')+1:] +"\n"
            hist_distributions_blob += ffile.read()

      with open(hist_distributions_filename,'w') as ff:
         ff.write(hist_distributions_blob)


      aimd_algorithm = "NVT Nose-Hoover CPMD"
      calculation_type = parse_calculation_type_aimd(outfile)
      charge = parse_charge(outfile)
      mult   = parse_mult(outfile)

      theory = parse_theory(outfile)
      xc     = parse_xc(outfile)
      basis  = parse_basis(False,outfile)
      basisHZ= parse_basis(True,outfile)

      jobok0   = parse_calculation_ok(outfile)
      program  = parse_program(outfile)
      machine  = parse_machine(outfile)
      ncpu     = parse_ncpu(outfile)
      wall_time= parse_wall_time(outfile)
      cputime  = parse_cputime_step(outfile)

      aimd_energies = parse_aimd_energies(outfile)
      temperatures = parse_aimd_temperatures(outfile)

      simulation_steps  = parse_simulation_steps(outfile)
      simulation_time   = parse_simulation_time(outfile)
      jobok    = (simulation_steps>0) and jobok0

      equilibration_steps  = parse_equilibration_steps(outfile)
      equilibration_time   = parse_equilibration_time(outfile)

      (average_potential,average_energy)   = parse_average_potentialenergy(outfile)
      (variance_potential,variance_energy) = parse_variance_potentialenergy(outfile)
      try:
         vdat = []
         edat = []
         with open(tsample[2],'r') as ff:
            for line in ff:
               vdat.append(eval(line.split()[2]))
               edat.append(eval(line.split()[1]))
         vdat.sort()
         edat.sort()
         j = len(edat)/2
         median_potential = vdat[j]
         median_energy    = edat[j]
         min_potential = vdat[0]
         max_potential = vdat[-1]
         R = (1.986/1000.0) / (23.06*27.2116)
         if ('temperature_ion' in temperatures):
            RT = R*temperatures['temperature_ion']
         else:
            RT = R*300.0
         vexpdat = []
         vexpave = 0.0
         for v in vdat:
            ee = exp((v-min_potential)/RT)
            vexpave  += ee
            vexpdat.append(ee)
         vexpdat.sort()
         j = len(vexpdat)/2
         vexpave  /= 1.0*len(vexpdat)
         vexpave2 = 0.0
         for v in vexpdat:
            vexpave2 += (v-vexpave)*(v-vexpave)
         vexpave2 /= 1.0*(len(vexpdat)-1)
         median_exp_potential   = vdat[j]
         average_exp_potential  = vexpave
         variance_exp_potential = vexpave2
         free_energy0           = min_potential + RT*log(average_exp_potential)
         free_energy1           = average_potential + 0.5*variance_energy/RT

         ### make ehistogram - set k to correspond to ~10 million samples ###
         n0 = len(vdat)
         k0 = int(ceil(2*n0**0.33333333))
         k = 400
         h = (max_potential-min_potential)/(k-1.0)
         print("k,h=",k,h)
         xhist = [0.0]*k
         uhist = [0.0]*k
         for x in vdat:
            i = int(round( (x-min_potential)/h ) )
            uhist[i] += 1.0
         norm = 0.5*h*(uhist[0]+uhist[k-1])
         for i in range(1,k-1): norm += h*uhist[i]
         for i in range(k): uhist[i] /= norm
         ehistogram_blob = '# nsamples = %d  - 400 bins used - but only kbins = %d are relavent\n' % (n0,k0)
         for i in range(k):
            x = min_potential + i*h
            ehistogram_blob += "%20.15le %le\n" % (x,uhist[i])
      except:
         median_potential = average_potential
         median_energy    = average_energy
         min_potential    = average_potential
         max_potential    = average_potential
         median_exp_potential   = 1.0
         average_exp_potential  = 1.0
         variance_exp_potential = 0.0
         free_energy0           = average_potential
         free_energy1           = average_potential
         ehistogram_blob = ''
         jobok = False


      print("ehistogram_blob:")
      print(ehistogram_blob)

      (solvation_type,solvent_type,nsolvent,solvent_size,molarity) = parse_aimdmm_solvent(outfile)
      unitcell = parse_unitcell(outfile)
      ucell   = ''
      ucell_L = 0.0
      if ('unitcell' in unitcell):   ucell   = unitcell['unitcell']
      if ('unitcell_L' in unitcell): ucell_L = unitcell['unitcell_L']*0.529177

      xyz_blob = ''
      for f in tsample:
         if '.xyz' in f:
            with open(f,'r') as xfile:
               count = 0
               for line in xfile:
                  if (count==0): xyz_blob = ''
                  count   += 1
                  xyz_blob += line
                  if (count==1):
                     nion = eval(line)
                  if (count >= (nion+2)): count = 0
            
      solute_size = nion - solvent_size
      solute_xyz_blob = ''
      count = 0
      for line in xyz_blob.split('\n'):
         count += 1
         if (count==1):
            solute_xyz_blob = "%d\n" % solute_size
         elif (count <= (solute_size+2)):
            solute_xyz_blob += line + '\n'

      with open(xyzfile,'w') as ff:
         ff.write(solute_xyz_blob)

      constraints = parse_constraints(xyzfile,outfile)
      constraint_string     = constraints['constraint_string']
      constraint_value      = constraints['constraint_value']
      constraint_type       = constraints['constraint_type']
      constraint_index1     = constraints['constraint_index1']
      constraint_index2     = constraints['constraint_index2']
      constraint_index3     = constraints['constraint_index3']
      constraint_index4     = constraints['constraint_index4']
      constraint_mean_force = constraints['constraint_mean_force']
      constraint_mean_force_time = constraints['constraint_mean_force_time']

      aux_potentials    = ''

      cif_filename = ''
      cif_filename_archive = ''
      freqblob = ''
      eigblob  = parse_eigblob(outfile)

      smiles   = xyz2smiles(xyzfile)
      InChI    = smiles2InChI(smiles)
      InChIKey = xyz2InChIKey(xyzfile)

      cid      = pubchem_smiles2cid(smiles)
      cas      = pubchem_smiles2cas(smiles)
      kegg     = pubchem_smiles2kegg(smiles)
      synonyms = pubchem_smiles2synonyms(smiles)
      mformula = xyz_molecular_formula(xyzfile)
      (bonding_string, covalent_string) = xyz_bonding_strings(xyzfile)
      osmiles   = parse_osmiles(outfile)
      client    = parse_client(outfile)
      postsmiles   = parse_postsmiles(outfile)
      if (osmiles=="nosmiles"): osmiles = smiles
      oInChI    = smiles2InChI(osmiles)
      oInChIKey = smiles2InChIKey(osmiles)

      #smiles2 = pubchem_smiles2canonicalsmiles(smiles)
      smiles2 = cannonicalsmiles(smiles)
      if (smiles2!=""):
         csmiles  = smiles2
      else:
         smiles3 = cannonicalsmiles(smiles)
         csmiles = smiles3

      iupac  = pubchem_smiles2iupac(smiles)
      if (iupac==''): iupac = smiles
      if (mult==2): iupac += " doublet radical"
      if (mult==3): iupac += " triplet radical"
      if (mult==4): iupac += " quqrtet radical"
      if (mult==5): iupac += " quintet radical"
      if (mult==6): iupac += " sextet radical"
      if (mult==7): iupac += " septet radical"
      if (mult==8): iupac += " octet radical"
      if (mult==9): iupac += " nonet radical"
      if (mult==10): iupac += " decet radical"
      if (mult>10):  iupac += " large radical"
      if (charge==-4): iupac += " tetraanion"
      if (charge==-3): iupac += " trianion"
      if (charge==-2): iupac += " dianion"
      if (charge==-1): iupac += " anion"
      if (charge==+1): iupac += " cation"
      if (charge==+2): iupac += " dication"
      if (charge==+3): iupac += " trication"
      if (charge==+4): iupac += " tetracation"
      chemical_structure_asciiart = smiles2ascii(smiles)

      esmiles = csmiles
      esmiles += " theory{%s}" % theory
      esmiles += " xc{%s}" % xc
      esmiles += " basis{%s}" % basis
      esmiles += " ^{%d}" % charge
      if (mult>1): esmiles += " mult{%d}" % mult
      esmiles += " solvation_type{%s}" % solvation_type
      esmiles += " solvent_type{%s}" % solvent_type
      esmiles += " molarity{%f}" % molarity
      if (ucell!=''):   esmiles += " unitcell{%s}" % ucell
      if (ucell_L>0.0): esmiles += " L{%f}" % ucell_L
      esmiles += " equilibrium_time{%f}" % equilibration_time
      esmiles += " sampling_time{%f}" % simulation_time
      if (constraint_string!=''):
         esmiles += " constraint_string{%s}" % constraint_string
         esmiles += " constraint_value{%f}"  % constraint_value
      if (aux_potentials!=''):
         esmiles += " aux_potentials{%s}" % aux_potentials
#
      print()
      print("iupac                              =",iupac)
      print("mformula                           =",mformula)
      print("InChI                              =",InChI)
      print("InChIKey                           =",InChIKey)
      print("cid                                =",cid)
      print("cas                                =",cas)
      print("kegg                               =",kegg)
      print("synonyms                           =",synonyms)
      print("smiles                             =",smiles)
      print("cannonical smiles                  =",csmiles)
      print("extended smiles                    =",esmiles)
      print("original smiles                    =",osmiles)
      print("original InChI                     =",oInChI)
      print("original InChIKey                  =",oInChIKey)
      print("bonding_string                     =",bonding_string)
      print("covalent_string                    =",covalent_string)
      print("program                            = ",program)
      print("calculation type                   = ",calculation_type)
      print("aimd algorithm                     = ",aimd_algorithm)
      print("theory                             = ",theory)
      print("xc                                 = ",xc)
      print("basis                              = ",basis)

      print("charge,mult                        = ",charge,mult)

      if ('unitcell' in unitcell):   print("unitcell                           = ",unitcell['unitcell'])
      if ('unitcell_L' in unitcell): print("unitcell_L                         = ",unitcell['unitcell_L'])
      if ('omega' in unitcell):      print("omega                              = ",unitcell['omega'])
      if ('a1x' in unitcell):        print("a1x                                = ",unitcell['a1x'])
      if ('a1y' in unitcell):        print("a1y                                = ",unitcell['a1y'])
      if ('a1z' in unitcell):        print("a1z                                = ",unitcell['a1z'])
      if ('a2x' in unitcell):        print("a2x                                = ",unitcell['a2x'])
      if ('a2y' in unitcell):        print("a2y                                = ",unitcell['a2y'])
      if ('a2z' in unitcell):        print("a2z                                = ",unitcell['a2z'])
      if ('a3x' in unitcell):        print("a3x                                = ",unitcell['a3x'])
      if ('a3y' in unitcell):        print("a3y                                = ",unitcell['a3y'])
      if ('a3z' in unitcell):        print("a3z                                = ",unitcell['a3z'])

      if ('initial_temperature' in temperatures): 
         print("initial_temperature                = ",temperatures['initial_temperature'])
      if ('seed' in temperatures): 
         print("seed                               = ",temperatures['seed'])
      if ('temperature_ion' in temperatures): 
         print("temperature_ion                    = ",temperatures['temperature_ion'])
      if ('temperature_elc' in temperatures): 
         print("temperature_elc                    = ",temperatures['temperature_elc'])

      print("constraint_string                  = ",constraint_string)
      print("constraint_value                   = ",constraint_value)
      print("constraint_index1                  = ",constraint_index1)
      print("constraint_index2                  = ",constraint_index2)
      print("constraint_index3                  = ",constraint_index3)
      print("constraint_index4                  = ",constraint_index4)
      print("constraint_mean_force              = ",constraint_mean_force)
      print("constraint_mean_force_time         = ",constraint_mean_force_time)
      print("aux_potentials                     = ",aux_potentials)
      print("solvation_type                     = ",solvation_type)
      print("solvent_type                       = ",solvent_type)
      print("nsolvent                           = ",nsolvent)
      print("solvent_size                       = ",solvent_size)
      print("solute_size                        = ",solute_size)
      print("molarity                           = ",molarity)

      print("equilibration_steps                = ",equilibration_steps)
      print("equilibration_time                 = ",equilibration_time)
      print("simulation_steps                   = ",simulation_steps)
      print("simulation_time                    = ",simulation_time)
      print("average potential,energy,exp_potential = ",average_potential,average_energy,average_exp_potential)
      print("median  potential,energy,exp_potential = ",median_potential,median_energy,median_exp_potential)
      print("variance potential,energy,exp_potential= ",variance_potential,variance_energy,variance_exp_potential)
      print("free energy (noniteracting state)  = ",free_energy0)
      print("free energy (std.normal)           = ",free_energy1)

      if ('total_energy' in aimd_energies): 
         print("total energy                       = ",aimd_energies['total_energy'])
      if ('total_orbital_energy' in aimd_energies): 
         print("total orbital energy               = ",aimd_energies['total_orbital_energy'])
      if ('hartree_energy' in aimd_energies): 
         print("hartree energy                     = ",aimd_energies['hartree_energy'])
      if ('exc_corr_energy' in aimd_energies): 
         print("exc_corr energy                     = ",aimd_energies['exc_corr_energy'])
      if ('ion_ion_energy' in aimd_energies): 
         print("ion-ion energy                      = ",aimd_energies['ion_ion_energy'])
      if ('kinetic_energy_elc' in aimd_energies): 
         print("kinetc energy (elc)                 = ",aimd_energies['kinetic_energy_elc'])
      if ('kinetic_energy_ion' in aimd_energies): 
         print("kinetc energy (ion)                 = ",aimd_energies['kinetic_energy_ion'])
      if ('LJ_energy' in aimd_energies): 
         print("LJ energy                           = ",aimd_energies['LJ_energy'])
      if ('Residual_Coulomb_energy' in aimd_energies): 
         print("Residual Coulomb energy             = ",aimd_energies['Residual_Coulomb_energy'])
      if ('MM_Vibration_energy' in aimd_energies): 
         print("MM Vibration energy                 = ",aimd_energies['MM_Vibration_energy'])
      if ('thermostat_energy_elc' in aimd_energies): 
         print("thermostat energy (elc)             = ",aimd_energies['thermostat_energy_elc'])
      if ('thermostat_energy_ion' in aimd_energies): 
         print("thermostat energy (ion)             = ",aimd_energies['thermostat_energy_ion'])

      print("machine                            = ",machine)
      print("ncpu                               = ",ncpu)
      print("wall time                          = ",wall_time)
      print("cputime/step                       = ",cputime)
      print("filename                           = ",nwfilename)
      print("xyz_filename                       = ",tsample_archive[0])
      print("ion_motion_filename                = ",tsample_archive[1])
      print("emotion_filename                   = ",tsample_archive[2])
      print("fei_filename                       = ",tsample_archive[3])
      print("radial_distributions_filename      = ",radial_distributions_filename_archive)
      print("hist_distributions_filename        = ",hist_distributions_filename_archive)
      print("job ok?                            = ",jobok)
      print()
      print("chemical_structure_asciiart=")
      print(chemical_structure_asciiart)
      print()

      if (jobok):
         insertlist = []
         questions = ''
         sqlinsert = "insert into " + table
         sqlinsert += " (iupac,mformula,InChI,InChIKey,smiles,csmiles,esmiles,osmiles,oInChI,oInChIKey,cid,cas,kegg,synonyms,"
         insertlist.append(iupac); questions += "?,"
         insertlist.append(mformula); questions += "?,"
         insertlist.append(InChI); questions += "?,"
         insertlist.append(InChIKey); questions += "?,"
         insertlist.append(smiles); questions += "?,"
         insertlist.append(csmiles); questions += "?,"
         insertlist.append(esmiles); questions += "?,"
         insertlist.append(osmiles); questions += "?,"
         insertlist.append(oInChI); questions += "?,"
         insertlist.append(oInChIKey); questions += "?,"
         insertlist.append(cid); questions += "?,"
         insertlist.append(cas); questions += "?,"
         insertlist.append(kegg); questions += "?,"
         insertlist.append(synonyms); questions += "?,"

         sqlinsert += "program,calculation_type,aimd_algorithm,theory,xc,basis,charge,mult,"
         insertlist.append(program); questions += "?,"
         insertlist.append(calculation_type); questions += "?,"
         insertlist.append(aimd_algorithm); questions += "?,"
         insertlist.append(theory); questions += "?,"
         insertlist.append(xc); questions += "?,"
         insertlist.append(basis); questions += "?,"
         insertlist.append(charge); questions += "?,"
         insertlist.append(mult); questions += "?,"

         sqlinsert += "solvation_type,solvent_type,molarity,solute_size,solvent_size,"
         insertlist.append(solvation_type); questions += "?,"
         insertlist.append(solvent_type); questions += "?,"
         insertlist.append(molarity); questions += "?,"
         insertlist.append(solute_size); questions += "?,"
         insertlist.append(solvent_size); questions += "?,"

         if (ucell_L>0.0):
            sqlinsert += "L,"
            insertlist.append(ucell_L); questions += "?,"
         if ('unitcell' in unitcell): 
            sqlinsert += "unitcell,"
            insertlist.append(unitcell['unitcell']); questions += "?,"
         if ('unitcell_L' in unitcell):
            sqlinsert += "unitcell_L,"
            insertlist.append(unitcell['unitcell_L']); questions += "?,"
         if ('omega' in unitcell):
            sqlinsert += "omega,"
            insertlist.append(unitcell['omega']); questions += "?,"
         if ('a1x' in unitcell): 
            sqlinsert += "a1x,"
            insertlist.append(unitcell['a1x']); questions += "?,"
         if ('a1y' in unitcell): 
            sqlinsert += "a1y,"
            insertlist.append(unitcell['a1y']); questions += "?,"
         if ('a1z' in unitcell): 
            sqlinsert += "a1z,"
            insertlist.append(unitcell['a1z']); questions += "?,"
         if ('a2x' in unitcell): 
            sqlinsert += "a2x,"
            insertlist.append(unitcell['a2x']); questions += "?,"
         if ('a2y' in unitcell): 
            sqlinsert += "a2y,"
            insertlist.append(unitcell['a2y']); questions += "?,"
         if ('a2z' in unitcell): 
            sqlinsert += "a2z,"
            insertlist.append(unitcell['a2z']); questions += "?,"
         if ('a3x' in unitcell): 
            sqlinsert += "a3x,"
            insertlist.append(unitcell['a3x']); questions += "?,"
         if ('a3y' in unitcell): 
            sqlinsert += "a3y,"
            insertlist.append(unitcell['a3y']); questions += "?,"
         if ('a3z' in unitcell): 
            sqlinsert += "a3z,"
            insertlist.append(unitcell['a3z']); questions += "?,"

         if ('initial_temperature' in temperatures):
            sqlinsert += "initial_temperature,"
            insertlist.append(temperatures['initial_temperature']); questions += "?,"
         if ('seed' in temperatures):
            sqlinsert += "seed,"
            insertlist.append(temperatures['seed']); questions += "?,"
         if ('temperature_ion' in temperatures):
            sqlinsert += "temperature_ion,"
            insertlist.append(temperatures['temperature_elc']); questions += "?,"
         if ('temperature_elc' in temperatures):
            sqlinsert += "temperature_elc,"
            insertlist.append(temperatures['temperature_ion']); questions += "?,"

         if ('total_energy' in aimd_energies):
            sqlinsert += "total_energy,"
            insertlist.append(aimd_energies['total_energy']); questions += "?,"
         if ('total_orbital_energy' in aimd_energies):
            sqlinsert += "total_orbital_energy,"
            insertlist.append(aimd_energies['total_orbital_energy']); questions += "?,"
         if ('hartree_energy' in aimd_energies):
            sqlinsert += "hartree_energy,"
            insertlist.append(aimd_energies['hartree_energy']); questions += "?,"
         if ('exc_corr_energy' in aimd_energies):
            sqlinsert += "exc_corr_energy,"
            insertlist.append(aimd_energies['exc_corr_energy']); questions += "?,"
         if ('Metadynamics_energy' in aimd_energies):
            sqlinsert += "Metadynamics_energy,"
            insertlist.append(aimd_energies['Metadynamics_energy']); questions += "?,"
         if ('dispersion_energy' in aimd_energies):
            sqlinsert += "dispersion_energy,"
            insertlist.append(aimd_energies['dispersion_energy']); questions += "?,"
         if ('ion_ion_energy' in aimd_energies):
            sqlinsert += "ion_ion_energy,"
            insertlist.append(aimd_energies['ion_ion_energy']); questions += "?,"
         if ('kinetic_energy_elc' in aimd_energies):
            sqlinsert += "kinetic_energy_elc,"
            insertlist.append(aimd_energies['kinetic_energy_elc']); questions += "?,"
         if ('kinetic_energy_ion' in aimd_energies):
            sqlinsert += "kinetic_energy_ion,"
            insertlist.append(aimd_energies['kinetic_energy_ion']); questions += "?,"
         if ('LJ_energy' in aimd_energies):
            sqlinsert += "LJ_energy,"
            insertlist.append(aimd_energies['LJ_energy']); questions += "?,"
         if ('Residual_Coulomb_energy' in aimd_energies):
            sqlinsert += "Residual_Coulomb_energy,"
            insertlist.append(aimd_energies['Residual_Coulomb_energy']); questions += "?,"
         if ('MM_Vibration_energy' in aimd_energies):
            sqlinsert += "MM_Vibration_energy,"
            insertlist.append(aimd_energies['MM_Vibration_energy']); questions += "?,"
         if ('thermostat_energy_elc' in aimd_energies):
            sqlinsert += "thermostat_energy_elc,"
            insertlist.append(aimd_energies['thermostat_energy_elc']); questions += "?,"
         if ('thermostat_energy_ion' in aimd_energies):
            sqlinsert += "thermostat_energy_ion,"
            insertlist.append(aimd_energies['thermostat_energy_ion']); questions += "?,"
         
         sqlinsert += "average_potential,median_potential,variance_potential,"
         insertlist.append(average_potential); questions += "?,"
         insertlist.append(median_potential); questions += "?,"
         insertlist.append(variance_potential); questions += "?,"

         sqlinsert += "average_energy,median_energy,variance_energy,"
         insertlist.append(average_energy); questions += "?,"
         insertlist.append(median_energy); questions += "?,"
         insertlist.append(variance_energy); questions += "?,"

         sqlinsert += "average_exp_potential,median_exp_potential,variance_exp_potential,"
         insertlist.append(average_exp_potential); questions += "?,"
         insertlist.append(median_exp_potential); questions += "?,"
         insertlist.append(variance_exp_potential); questions += "?,"

         sqlinsert += "free_energy0,free_energy1,"
         insertlist.append(free_energy0); questions += "?,"
         insertlist.append(free_energy1); questions += "?,"

         sqlinsert += "equilibration_steps,equilibration_time,"
         insertlist.append(equilibration_steps); questions += "?,"
         insertlist.append(equilibration_time); questions += "?,"

         sqlinsert += "simulation_steps,simulation_time,"
         insertlist.append(simulation_steps); questions += "?,"
         insertlist.append(simulation_time); questions += "?,"

         sqlinsert += "solute_xyz_blob,xyz_blob,eigenvalues_blob,"
         insertlist.append(solute_xyz_blob); questions += "?,"
         insertlist.append(xyz_blob); questions += "?,"
         insertlist.append(eigblob); questions += "?,"

         if (constraint_string!=''):    
            sqlinsert += "constraint_string,constraint_value,"
            sqlinsert += "constraint_type,constraint_index1,constraint_index2,"
            sqlinsert += "constraint_index3,constraint_index4,"
            sqlinsert += "constraint_mean_force,constraint_mean_force_time,"
            insertlist.append(constraint_string); questions += "?,"
            insertlist.append(constraint_value); questions += "?,"
            insertlist.append(constraint_type); questions += "?,"
            insertlist.append(constraint_index1); questions += "?,"
            insertlist.append(constraint_index2); questions += "?,"
            insertlist.append(constraint_index3); questions += "?,"
            insertlist.append(constraint_index4); questions += "?,"
            insertlist.append(constraint_mean_force); questions += "?,"
            insertlist.append(constraint_mean_force_time); questions += "?,"

         if (aux_potentials!=''):    
            sqlinsert += "aux_potentials,"
            insertlist.append(aux_potentials); questions += "?,"

         if (radial_distributions_filename_archive!=''):
            sqlinsert += "radial_distributions_filename,"
            insertlist.append(radial_distributions_filename_archive); questions += "?,"

         if (hist_distributions_filename_archive!=''):
            sqlinsert += "hist_distributions_filename,"
            insertlist.append(hist_distributions_filename_archive); questions += "?,"

         if (dfilename1_archive!=''):
            sqlinsert += "pair_distribution_filename,"
            insertlist.append(dfilename1_archive); questions += "?,"

         if (dfilename2_archive!=''):
            sqlinsert += "power_spectrum_filename,"
            insertlist.append(dfilename2_archive); questions += "?,"

         if (dfilename3_archive!=''):
            sqlinsert += "vel_correlation_filename,"
            insertlist.append(dfilename3_archive); questions += "?,"

         if (ehistogram_blob!=''):
            sqlinsert += "ehistogram_blob,"
            insertlist.append(ehistogram_blob); questions += "?,"
         if (freqblob!=''):
            sqlinsert += "frequencies_blob,"
            insertlist.append(freqblob); questions += "?,"

         if (cif_filename_archive!=''):
            sqlinsert += "cif_filename,"
            insertlist.append(cif_filename_archive); questions += "?,"

         sqlinsert += "xyz_filename,ion_motion_filename,emotion_filename,fei_filename,"
         insertlist.append(tsample_archive[0]); questions += "?,"
         insertlist.append(tsample_archive[1]); questions += "?,"
         insertlist.append(tsample_archive[2]); questions += "?,"
         insertlist.append(tsample_archive[3]); questions += "?,"
         
         sqlinsert += "bonding_string,covalent_string,filename,chemical_structure_asciiart,"
         insertlist.append(bonding_string); questions += "?,"
         insertlist.append(covalent_string); questions += "?,"
         insertlist.append(nwfilename); questions += "?,"
         insertlist.append(chemical_structure_asciiart); questions += "?,"

         sqlinsert += "wall_time,cputimeperstep,ncpu,machine,"
         insertlist.append(wall_time); questions += "?,"
         insertlist.append(cputime); questions += "?,"
         insertlist.append(ncpu); questions += "?,"
         insertlist.append(machine); questions += "?,"

         sqlinsert += "date_time) "
         insertlist.append(time.strftime('%Y-%m-%d %H:%M:%S')); questions += "?"

         sqlinsert += " values (" 
         sqlinsert += questions
         sqlinsert += ");"
         if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

         print("INTO SQLCHECK")
         sqlcheck = "select count(1) from " + table + " where "
         sqlcheck += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and program=? and "
         sqlcheck += "calculation_type=? and theory=? and xc=? and basis=? and "
         sqlcheck += "solvation_type=? and solvent_type=? and charge=? and mult=? and seed=? and "
         sqlcheck += "total_energy>=? and total_energy<=? and average_potential>=? and average_potential<=? limit 1;"
         if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')
         eps = 1.0e-6
         checklist = []
         checklist.append(iupac)
         checklist.append(InChI)
         checklist.append(InChIKey)
         checklist.append(smiles)
         checklist.append(csmiles)
         checklist.append(esmiles)
         checklist.append(program)
         checklist.append(calculation_type)
         checklist.append(theory)
         checklist.append(xc)
         checklist.append(basis)
         checklist.append(solvation_type)
         checklist.append(solvent_type)
         checklist.append(charge)
         checklist.append(mult)
         seed = 0
         if ('seed' in temperatures): seed = temperatures['seed']
         checklist.append(seed)
         total_energy = 0.0
         if ('total_energy' in aimd_energies): total_energy = aimd_energies['total_energy']
         checklist.append(total_energy-eps)
         checklist.append(total_energy+eps)
         checklist.append(average_potential-eps)
         checklist.append(average_potential+eps)
         print("INTO SQL, counts=",sqlinsert.count('%s'),len(insertlist))


         sqlinsert2 = "insert into " + solute_table
         sqlinsert2 += " (abbreviation,iupac,mformula,InChI,InChIKey,"
         sqlinsert2 += "smiles,csmiles,esmiles,synonyms,cid,"
         sqlinsert2 += "cas,charge,mult,xyz_blob,unitcell,"
         sqlinsert2 += "L,solute_bonding_string,solute_covalent_string,optimized,solute_size,"
         sqlinsert2 += "solvent_size,solvent_type,molarity,constraint_string,constraint_type,"
         sqlinsert2 += "constraint_index1,constraint_index2,constraint_index3,constraint_index4,"
         sqlinsert2 += "constraint_value,"
         sqlinsert2 += "date_time) values("
         sqlinsert2 += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
         if (not issqlite3): sqlinsert2 = sqlinsert2.replace('?','%s')

         insertlist2 = []
         insertlist2.append('no abbreviation')
         insertlist2.append(iupac)
         insertlist2.append(mformula)
         insertlist2.append(InChI)
         insertlist2.append(InChIKey)

         insertlist2.append(smiles)
         insertlist2.append(csmiles)
         insertlist2.append(esmiles)
         insertlist2.append(synonyms)
         insertlist2.append(cid)

         insertlist2.append(cas)
         insertlist2.append(charge)
         insertlist2.append(mult)
         insertlist2.append(xyz_blob)
         insertlist2.append(ucell)

         insertlist2.append(ucell_L)
         insertlist2.append(bonding_string)
         insertlist2.append(covalent_string)
         insertlist2.append("AIMD Simulation")
         insertlist2.append(solute_size)

         insertlist2.append(solvent_size)
         insertlist2.append(solvent_type)
         insertlist2.append(molarity)
         insertlist2.append(constraint_string)
         insertlist2.append(constraint_type)

         insertlist2.append(constraint_index1)
         insertlist2.append(constraint_index2)
         insertlist2.append(constraint_index3)
         insertlist2.append(constraint_index4)
         insertlist2.append(constraint_value)

         insertlist2.append(time.strftime('%Y-%m-%d %H:%M:%S'))
         insertsolute = (ucell_L > 0.0)
         print("insertsolute=",insertsolute,ucell_L)


         if (issqlite3):
            dbcon = sqlite3.connect(dbfile)
         else:
            host = hup.split()[0]
            user = hup.split()[1]
            pss = hup.split()[2]
            #dbcon = MySQLdb.connect(host,user,pss,dbfile)
            dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')
         
         with dbcon:
            cur = dbcon.cursor()
            cur.execute(sqlcheck,checklist)
            row = cur.fetchone()
            print('row=',row)
            duplicate = (row[0]>0)
            if (not duplicate):
               print("inserting into " + table)
               cur.execute(sqlinsert,insertlist)
               if (insertsolute):
                  print("inserting geometry into " + solute_table)
                  cur.execute(sqlinsert2,insertlist2)

         print("duplicate=",duplicate)
         if (not duplicate):
            text2speech("Hi. I just added " + mformula + " molecule to the " + table + " table in the " + dbfile  + " database.")
            print("Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult)

            for ff in dfilenames:
               if (os.path.isfile(ff[0])):
                  cmd0 = "scp " + ff[0]  + " " + ff[1]
                  if ((":/" not in ff[0]) and (":/" not in ff[1])): 
                     cmd0 = cmd0.replace("scp","cp")
                     ppth = os.path.dirname(ff[1])
                     if (not os.path.isdir(ppth)):
                        cmd9 = "mkdir -p " + ppth
                        pexpect_command(cmd9,nwpassword)
                  print(cmd0)
                  pexpect_command(cmd0,nwpassword)

         else:
            text2speech("Hi. The " + mformula + " molecule already exists in the " + table + " table in the " + dbfile  + " database. It was not added.")
            print("Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult)





    except:
      jobok = True
      print("The aimd job= ",outfile, " was not able to be parsed.")







###############################################
#                                             #
#            insert_nmr_calculation           #
#                                             #
###############################################

def insert_nmr_calculation(outfile,hup,dbfile,table,bad_table,nwpassword,nwmachine):

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2

  if (os.path.exists(outfile)):
    if (parse_jobfinished(outfile)):

      nwfilename = nwmachine + "/" + outfile[outfile.rfind('/')+1:] + dd1

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")  

      jobok    = parse_calculation_ok(outfile)
      program  = parse_program(outfile)
      energy   = parse_energy(outfile)
      nmr_blob = parse_nmrblob(outfile)
      cosmo    = parse_cosmo_smd(outfile)
      solvation_dielectric = parse_cosmo_dielectric(outfile)
      calculation_type = ''
      if (cosmo!=0.0):
         if (cosmo==(-987654.3210)): cosmo = 0.0
         solvation_type   = "COSMO-SMD"
         solvation_energy = cosmo
         cosmo_e          = parse_cosmo_smd_e(outfile)
         if (abs(cosmo_e-energy)<1.0e-6):
            calculation_type += 'y'
            solvation_type = "COSMO-SMD-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
      else:
         cosmo           = parse_cosmo(outfile)
         cosmo_intrinsic = parse_cosmo_intrinsic(outfile)
         if (cosmo==(-987654321.0)) and cosmo_intrinsic:
            calculation_type += 'y'
            solvation_type = "COSMO-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
         elif (cosmo!=0.0):
            if (cosmo==(-987654.3210)): cosmo = 0.0
            solvation_energy = cosmo
            if (cosmo_intrinsic):
               calculation_type += 'y'
               solvation_type   = "COSMO intrinsic"
            else:
               solvation_type   = "COSMO"
         else:
            solvation_type   = "None"
            solvation_energy = 0.0

      if ("COSMO-SMD" in solvation_type):
         svnt = parse_cosmo_smd_solvent(outfile_without_hash)
         if (svnt!="water") and (svnt!="h2o"):
            solvation_type = solvation_type.strip() + ":" + svnt

      if (energy!=0.0):   calculation_type += 'o'
      if (cosmo!=0.0) or (solvation_type=="COSMO") or (solvation_type=="COSMO-SMD"): calculation_type += 'c'
      if (nmr_blob!=''):  calculation_type += 'n'

      charge = parse_charge(outfile)
      mult   = parse_mult(outfile)
      theory = parse_theory(outfile)
      xc     = parse_xc(outfile)
      basis  = parse_basis(False,outfile)
      basisHZ= parse_basis(True,outfile)
      theory_property = parse_theory(outfile)
      xc_property     = parse_xc(outfile)
      basis_property  = parse_basis(False,outfile)
      basisHZ_property= parse_basis(True,outfile)

      try:
         msurface = gen_surfaceareas(outfile)
         ecd = 5.0*sum(msurface[0])/1000.0 + 0.86
         ehd = 25.0*sum(msurface[0])/1000.0
      except:
         msurface=[[0.0],[0.0]]
         ecd = 0.0
         ehd = 0.0

      xyzblob  = parse_xyzblob(outfile,xyzfile)
      smiles = xyz2smiles(xyzfile)
      InChI  = smiles2InChI(smiles)
      InChIKey = xyz2InChIKey(xyzfile)
      cid      = pubchem_smiles2cid(smiles)
      cas      = pubchem_smiles2cas(smiles)
      kegg     = pubchem_smiles2kegg(smiles)
      synonyms = pubchem_smiles2synonyms(smiles)

      mformula = xyz_molecular_formula(xyzfile)

      iupac  = pubchem_smiles2iupac(smiles)
      if (iupac==''): iupac = smiles

      #smiles2 = pubchem_smiles2canonicalsmiles(smiles)
      smiles2 = cannonicalsmiles(smiles)
      chemical_structure_asciiart = smiles2ascii(smiles)

      if (mult==2): iupac += " doublet radical"
      if (mult==3): iupac += " triplet radical"
      if (mult==4): iupac += " quqrtet radical"
      if (mult==5): iupac += " quintet radical"
      if (mult==6): iupac += " sextet radical"
      if (mult==7): iupac += " septet radical"
      if (mult==8): iupac += " octet radical"
      if (mult==9): iupac += " nonet radical"
      if (mult==10): iupac += " decet radical"
      if (mult>10):  iupac += " large radical"
      if (charge==-4): iupac += " tetraanion"
      if (charge==-3): iupac += " trianion"
      if (charge==-2): iupac += " dianion"
      if (charge==-1): iupac += " anion"
      if (charge==+1): iupac += " cation"
      if (charge==+2): iupac += " dication"
      if (charge==+3): iupac += " trication"
      if (charge==+4): iupac += " tetracation"

      if (smiles2!=""):
         csmiles  = smiles2
      else:
         smiles3 = cannonicalsmiles(smiles)
         csmiles = smiles3

      inserting = (energy!=0.0) and (smiles!='')
      sitkoff  = ecd
      honig    = ehd
      ASA      = sum(msurface[0])
      SAV      = sum(msurface[1])
      esmiles = csmiles 
      esmiles += " theory{%s}" % theory
      esmiles += " xc{%s}" % xc
      esmiles += " basis{%s}" % basis
      esmiles += " solvation_type{%s}" % solvation_type
      esmiles += " solvation_dielectric{%f}" % solvation_dielectric
      esmiles += " ^{%d}" % charge
      if (mult>1): esmiles += " mult{%d}" % mult
      print()
      print("iupac                              =",iupac)
      print("mformula                           =",mformula)
      print("InChI                              =",InChI)
      print("InChIKey                           =",InChIKey)
      print("cid                                =",cid)
      print("cas                                =",cas)
      print("kegg                               =",kegg)
      print("synonyms                           =",synonyms)
      print("smiles                             =",smiles)
      print("cannonical smiles                  =",csmiles)
      print("extended smiles                    =",esmiles)
      print("program                            = ",program)
      print("calculation type                   = ",calculation_type)
      print("theory                             = ",theory)
      print("xc                                 = ",xc)
      print("basis                              = ",basis)
      print("theory_property                    = ",theory_property)
      print("xc_property                        = ",xc_property)
      print("basis_property                     = ",basis_property)
      print("charge,mult                        = ",charge,mult)
      print("energy                             = ",energy)
      print("solvation energy                   = ",solvation_energy,"  solvation type=",solvation_type)
      print("solvation dielectric               = ",solvation_dielectric)
      print("Sitkoff cavity dispersion          = ",ecd)
      print("Honig cavity dispersion            = ",ehd)
      print("ASA solvent accesible surface area = ",ASA)
      print("SAV solvent accesible volume       = ",SAV)
      print("filename                           = ",nwfilename)
      print("job ok?                            = ",jobok)
      print()
      print("chemical_structure_asciiart=")
      print(chemical_structure_asciiart)
      print()

      #set the mytable
      if (jobok):
         mytable = table
      else:
         mytable = bad_table

      sqlinsert = "insert into " + mytable
      sqlinsert += " (iupac,mformula,InChI,InChIKey,smiles,csmiles,esmiles,"
      sqlinsert += "synonyms,cid,cas,kegg,program,calculation_type,"
      sqlinsert += "theory,xc,basis,"
      sqlinsert += "theory_property,xc_property,basis_property,"
      sqlinsert += "charge,mult,energy,"
      sqlinsert += "solvation_type,solvation_energy,solvation_dielectric,sitkoff,honig,ASA,SAV,"
      sqlinsert += "xyz_blob,nmr_blob,filename,chemical_structure_asciiart) "
      sqlinsert += " values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"

      if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

      insertlist = []
      insertlist.append(iupac)
      insertlist.append(mformula)
      insertlist.append(InChI)
      insertlist.append(InChIKey)
      insertlist.append(smiles)
      insertlist.append(csmiles)
      insertlist.append(esmiles)
      insertlist.append(synonyms)
      insertlist.append(cid)
      insertlist.append(cas)
      insertlist.append(kegg)
      insertlist.append(program)
      insertlist.append(calculation_type)
      insertlist.append(theory)
      insertlist.append(xc)
      insertlist.append(basis)
      insertlist.append(theory_property)
      insertlist.append(xc_property)
      insertlist.append(basis_property)
      insertlist.append(charge)
      insertlist.append(mult)
      insertlist.append(energy)
      insertlist.append(solvation_type)
      insertlist.append(solvation_energy)
      insertlist.append(solvation_dielectric)
      insertlist.append(sitkoff)
      insertlist.append(honig)
      insertlist.append(ASA)
      insertlist.append(SAV)
      if (issqlite3):
         insertlist.append(sqlite3.Binary(xyzblob))
         insertlist.append(sqlite3.Binary(nmr_blob))
      else:
         insertlist.append(xyzblob)
         insertlist.append(nmr_blob)
      insertlist.append(nwfilename)
      insertlist.append(chemical_structure_asciiart)

      sqlcheck = "select count(1) from " + mytable + " where "
      sqlcheck += "iupac=? and InChI=? and smiles=? and csmiles=? and esmiles=? and program=? and "
      sqlcheck += "calculation_type=? and theory=? and xc=? and basis=? and "
      sqlcheck += "theory_property=? and xc_property=? and basis_property=? and charge=? and mult=? and "
      sqlcheck += "energy>=? and energy<=? and "
      sqlcheck += "solvation_type=? and "
      sqlcheck += "solvation_energy>=? and solvation_energy<=? and sitkoff>=? and sitkoff<=? and "
      sqlcheck += "honig>=? and honig<=? and ASA>=? and ASA<=? and SAV>=? and SAV<=?  limit 1;"

      if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')

      eps = 1.0e-6
      checklist = []
      checklist.append(iupac)
      checklist.append(InChI)
      checklist.append(smiles)
      checklist.append(csmiles)
      checklist.append(esmiles)
      checklist.append(program)
      checklist.append(calculation_type)
      checklist.append(theory)
      checklist.append(xc)
      checklist.append(basis)
      checklist.append(theory_property)
      checklist.append(xc_property)
      checklist.append(basis_property)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(energy-eps)
      checklist.append(energy+eps)

      checklist.append(solvation_type)
      checklist.append(solvation_energy-eps)
      checklist.append(solvation_energy+eps)
      checklist.append(sitkoff-eps)
      checklist.append(sitkoff+eps)
      checklist.append(honig-eps)
      checklist.append(honig+eps)
      checklist.append(ASA-eps)
      checklist.append(ASA+eps)
      checklist.append(SAV-eps)
      checklist.append(SAV+eps)


      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         #dbcon = MySQLdb.connect(host,user,pss,dbfile)
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')

      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row = cur.fetchone()
         print('row=',row)
         duplicate = (row[0]>0)
         if ((not duplicate) and (inserting)):
             print("inserting into " + mytable)
             cur.execute(sqlinsert,insertlist)


      #### insert data to sql table ###
      print("duplicate=",duplicate)
      if (inserting) and (not duplicate):
          text2speech("Hi. I just added " + mformula + " to the " + mytable + " table in the " + dbfile  + " database.")

          print("Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,theory_property,xc_property,basis_property,charge,mult,energy,cosmo,ecd,ehd,ASA,SAV)
          cmd0 = "scp " + outfile  + " " + nwfilename
          if ((":/" not in nwfilename) and (":/" not in outfile)): 
             cmd0 = cmd0.replace("scp","cp")
             ppth = os.path.dirname(nwfilename)
             if (not os.path.isdir(ppth)):
                cmd9 = "mkdir -p " +  ppth
                pexpect_command(cmd9,nwpassword)
          print(cmd0)
          pexpect_command(cmd0,nwpassword)
          delete_esmiles(hup,dbfile,requests_table,esmiles)
      else:
          text2speech("Hi. I just did not insert " + mformula + " to the " + mytable + " table in the " + dbfile  + " database, because it was a duplicate")
          print("Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,theory_property,xc_property,basis_property,charge,mult,energy,cosmo,ecd,ehd,ASA,SAV)
      print()
      print()
      print()



    else:
       print("The job= ",outfile, " is not complete.")


###############################################
#                                             #
#            insert_homolumo                  #
#                                             #
###############################################

def insert_homolumo(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles):

  if (hup=='sqlite3'):
      issqlite3 = True
  else:
      issqlite3 = False

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2
  outfile_without_hash  = wrkdir + "/"+outfile99

  if (os.path.exists(outfile)):
    #if (parse_jobfinished(outfile)):
    try:

      with open(outfile,'r') as ff:
         aa = ff.read()
      aa = aa.replace('#','')
      with open(outfile_without_hash,'w') as ff:
         ff.write(aa)

      movecs_blob = aa

      nwfilename = nwmachine + "/mo_orbital_" + outfile[outfile.rfind('/')+1:] + dd1

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")

      nwdatafiles0 = nwfilename + " "
      nwdatacopy  = []
      nwdatacopy0  = []
      nwdatacopy1  = []
      nwdatacopy0.append((outfile,nwfilename))
      nwdatafiles = ''
      for bb in extra_datafiles.strip().split():
         bbb = nwmachine + "/" + bb[bb.rfind('/')+1:] + dd1 + " "
         nwdatafiles += bbb
         nwdatacopy1.append((bb.strip(),bbb.strip()))
      nwdatafiles = nwdatafiles.strip()
      homolumo_id = aa.split("homolumoresubmitjob:")[1].split(":homolumoresubmitjob")[0]
      molecule_id = eval(homolumo_id)
      eigblob  = parse_eigblob(outfile_without_hash)

      if (issqlite3):
         sqlcheck = "select mult,theory,data_filenames from " + table + " where Id=?;"
      else:
         sqlcheck = "select mult,theory,data_filenames from " + table + " where Id=%s;"
      checklist = [molecule_id]

      if (issqlite3):
         sqlupdate  = "update " + table + " set data_filenames=? where Id=?;"
         sqlupdate2 = "update " + table + " set eigenvalues_blob=? where Id=?;"
      else:
         sqlupdate  = "update " + table + " set data_filenames=%s where Id=%s;"
         sqlupdate2 = "update " + table + " set eigenvalues_blob=%s where Id=%s;"
      updatelist2 = []
      updatelist2.append(eigblob)
      updatelist2.append(molecule_id)

      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         #dbcon = MySQLdb.connect(host,user,pss,dbfile)
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')

      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row  = cur.fetchone()
         mult   = row[0]
         theory = row[1]
         data_filenames = row[2].decode("utf-8")

         if (data_filenames==None): data_filenames = ""
         changed = False
         alreadyhasmoorbitals = "mo_orbital_" in data_filenames
         if (not alreadyhasmoorbitals):
            data_filenames += " " + nwdatafiles0
            changed = True
            nwdatacopy += nwdatacopy0

         alreadyhascubes = "cube" in data_filenames
         if (not alreadyhascubes):
            data_filenames += " " + nwdatafiles
            changed = True
            nwdatacopy += nwdatacopy1

         if (changed):
            for bbb in nwdatacopy:
               cmd0 = "scp " + bbb[0]  + " " + bbb[1]
               if ((":/" not in bbb[0]) and (":/" not in bbb[1])): 
                  cmd0 = cmd0.replace("scp","cp")
                  ppth = os.path.dirname(bbb[1])
                  if (not os.path.isdir(ppth)):
                     cmd9 = "mkdir -p " + ppth
                     pexpect_command(cmd9,nwpassword)
               print(cmd0)
               pexpect_command(cmd0,nwpassword)
            data_filenames = data_filenames.strip()
            updatelist = []
            updatelist.append(data_filenames)
            updatelist.append(molecule_id)
            cur.execute(sqlupdate,updatelist)
            if theory=="pspw" or theory=="pspw4" or theory=="paw" or theory=="paw4":
               cur.execute(sqlupdate2,updatelist2)
 

      print() 
      print("Updating HOMOLUMO id               = ",molecule_id)
      print("filename                           = ",nwfilename)
      print("extra_datafiles                    = ",nwdatafiles)
      print("theory,mult                        = ",theory,mult)
      print()


    except:
      print("The job= ",outfile, " was not able to be parsed by insert_homolumo.")

  else:
     print("The job= ",outfile, " was not able to be parsed by insert_homolumo.")



###############################################
#                                             #
#            insert_hrotor                    #
#                                             #
###############################################

def insert_hrotor(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles):

  if (hup=='sqlite3'):
      issqlite3 = True
  else:
      issqlite3 = False

  tt1 = time.localtime()
  dd1 = "-hrotor-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2

  if (os.path.exists(outfile)):
    #if (parse_jobfinished(outfile)):
    try:

      with open(outfile,'r') as ff:
         aa = ff.read()

      nwfilename = nwmachine + "/" + outfile[outfile.rfind('/')+1:] + dd1
      print("nwfilename=",nwfilename)

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")

      homolumo_id = aa.split("hrotorresubmitjob:")[1].split(":hrotorresubmitjob")[0]
      print("homolumo_id=",homolumo_id)
      molecule_id = eval(homolumo_id)
      nwdatafiles = nwfilename + " "
      nwdatacopy = []
      nwdatacopy.append((outfile,nwfilename))
      nwdatafiles = nwdatafiles.strip()
      
      if (issqlite3):
         sqlcheck = "select charge,mult,theory,data_filenames,hrotors_blob,xyz_blob,frequencies_blob from " + table + " where Id=?;"
      else:
         sqlcheck = "select charge,mult,theory,data_filenames,hrotors_blob,xyz_blob,frequencies_blob from " + table + " where Id=%s;"
      checklist = [molecule_id]

      if (issqlite3):
         sqlupdate  = "update " + table + " set data_filenames=? where Id=?;"
         sqlupdate2 = "update " + table + " set hrotors_blob=? where Id=?;"
      else:
         sqlupdate  = "update " + table + " set data_filenames=%s where Id=%s;"
         sqlupdate2 = "update " + table + " set hrotors_blob=%s where Id=%s;"

      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         #dbcon = MySQLdb.connect(host,user,pss,dbfile)
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')
      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row  = cur.fetchone()

         charge = row[0]
         mult   = row[1]
         theory = row[2]
         data_filenames = row[3].decode("utf-8")
         hrotors_blob   = row[4].decode("utf-8")
         if (data_filenames==None): data_filenames = ""
         if (hrotors_blob==None):   hrotors_blob = ""
         xyz_blob       = row[5].decode("utf-8")
         freq_blob      = row[6].decode("utf-8")
         
         print("into hrotor_blob")
         hrotor_blob  = parse_hrotor_blob(outfile,xyz_blob,freq_blob)
         #jjj = '#@@ drion/dphi =' + hrotor_blob.split('#@@ drion/dphi =')[1].split('\n')[0]
         #alreadyhasrotor = True
         #for xxx in hrotor_blob.split('#@@ drion/dphi =')[1:]:
         #   jjj = xxx.split("\n")[0]
         #   alreadyhasrotor = alreadyhasrotor and (jjj in hrotors_blob)
         xxx = '#@@   rbond    =' + hrotor_blob.split('#@@   rbond    =')[1].split('\n')[0]
         yyy = '#@@   rgroup   =' + hrotor_blob.split('#@@   rgroup   =')[1].split('\n')[0]
         alreadyhasrotor = (xxx in hrotors_blob) and (yyy in hrotors_blob)
         print("out hrotor_blob",alreadyhasrotor)

         hrotorreplacejob = parse_hrotorreplacejob(outfile)
         print("hrotorreplacejob=",hrotorreplacejob)

         if (not alreadyhasrotor) or hrotorreplacejob:
            for bbb in nwdatacopy:
               cmd0 = "scp " + bbb[0]  + " " + bbb[1]
               if ((":/" not in bbb[0]) and (":/" not in bbb[1])): 
                  cmd0 = cmd0.replace("scp","cp")
                  ppth = os.path.dirname(bbb[1])
                  if (not os.path.isdir(ppth)):
                     cmd9 = "mkdir -p " + ppth
                     pexpect_command(cmd9,nwpassword)
               print(cmd0)
               pexpect_command(cmd0,nwpassword)

            if alreadyhasrotor and hrotorreplacejob:
               hrotors_blob = replace_hrotor_blob(hrotors_blob,hrotor_blob)
            else:
               hrotors_blob += hrotor_blob

            updatelist2 = []
            updatelist2.append(hrotors_blob)
            updatelist2.append(molecule_id)
        
            data_filenames += " " + nwdatafiles
            data_filenames = data_filenames.strip()
            updatelist = []
            updatelist.append(data_filenames)
            updatelist.append(molecule_id)

            print("data_filenames = ",data_filenames)
            print()
            #print "hrotors_blob="
            #print hrotors_blob
            cur.execute(sqlupdate,updatelist)
            cur.execute(sqlupdate2,updatelist2)
            print()
            print("Updating HROTOR id                 = ",molecule_id)
            print("filename                           = ",nwfilename)
            print("extra_datafiles                    = ",data_filenames)
            print("theory,mult                        = ",theory,charge,mult)
            print()
         else:
            print("rotor already exists")
            print("hrotors_blob=")
            print(hrotors_blob)
 

      #print 
      #print "Updating HROTOR id                 = ",molecule_id
      #print "filename                           = ",nwfilename
      #print "extra_datafiles                    = ",nwdatafiles
      #print "theory,mult                        = ",theory,charge,mult
      #print 


    except:
      print("The job= ",outfile, " was not able to be parsed by insert_hrotor.")

  else:
     print("The job= ",outfile, " was not able to be parsed by insert_hrotor.")






def update_calculationscount(hup,dbfile,table,countfilename):

   try:
      sqlcheck = "select count(*) from " + table
      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         #dbcon = MySQLdb.connect(host,user,pss,dbfile)
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,autocommit=True,charset='utf8mb4')
      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck)
         row  = cur.fetchone()
         count = row[0]

      print("MOLECULECOUNT=",count)

      with open(countfilename,'w') as ff:
         ff.write("%d" % count)

   except:
      print("update_calculationscount failed")



##############################################################################
############################# main program ###################################
##############################################################################
usage = \
"""
Remote chemdb_add_nwout7 mysql  program

  Usage: chemdb_add_nwout7 -h hup_string -d database -t table -q requests_table -b bad_table -n nmr_table -c bad_nmr_table -m nwmachine -p nwpasswrd -z string_of_datafiles nwoutfiles

  -h hup_string="machine user password" or enter sqlite3 for sqlite3 db
  -d database = "name of database"
  -t table = "name of table"
  -q requests_table = "name of requests_table"
  -b bad_table = "name of bad_table"
  -n nmr_table = "name of nmr_table"
  -c bad_nmr_table = "name of bad_nmr_table"
  -m nwmachine = "machine:directory"
  -p nwpassrd = password for nwmachine
  -x prints this message
  -z string of extra_datafiles
  -s no resubmit

"""

#Database defaults
hup    = hup0
dbfile = "TNT_Project"
table  = "calculations"
requests_table  = "requests"
bad_table       = "bad_calculations"
nmr_table       = "nmr_calculations"
bad_nmr_table   = "bad_nmr_calculations"
abrev_table     = "abbreviations"
aimd_table      = "aimd_calculations"
solute_table    = "solute_structures"
extra_datafiles = ''
noresubmit = False

nwmachine  = archivemachine + "/%d/%d" % (random.randint(0,99),random.randint(0,99))
nwpassword = archivepassword

a = random.randint(0,9)
b = random.randint(0,9)
c = random.randint(0,9)
d = random.randint(0,9)
e = random.randint(0,9)
nwmachine_aimd = archivemachine+"/aimd_simulations/%d/%d/%d/%d/%d/" % (a,b,c,d,e)



print()
print()
print()
print("+---------------------------------+")
print("| chemdb_add_nwout7 mysql version |")
print("+---------------------------------+")
print()
tt = time.localtime()
dd = "-%d-%d-%d-%d:%d.%d" % (tt[0],tt[1],tt[2],tt[3],tt[4],tt[5])


opts, args = getopt.getopt(sys.argv[1:], "h:d:t:q:b:n:c:m:p:z:xs")
for o, a in opts:
  if '-s' in o:
     noresubmit = True
  if '-h' in o:
     hup = a
  if '-d' in o:
     dbfile = a
  if '-t' in o:
     table = a
  if '-q' in o:
     requests_table = a
  if '-b' in o:
     bad_table = a
  if '-n' in o:
     nmr_table = a
  if '-c' in o:
     bad_nmr_table = a
  if '-m' in o:
     nwmachine = a
  if '-p' in o:
     nwpassword = a
  if '-z' in o:
     extra_datafiles = a
  if o in ("-x","--help"):
    print(usage)
    exit()

if (len(args)<1):
   print(usage)
   exit()

nwofiles  = []
for i in range(len(args)):
   nwofiles.append(args[i])


if (hup=='sqlite3'):
   issqlite3 = True
   print("sqlite3 db file      =",dbfile)
else:
   issqlite3 = False
   print("mysql db             =",dbfile)

print("table name           =",table)
print("requests table name  =",requests_table)
print("bad table name       =",bad_table)
print("nmr table name       =",nmr_table)
print("aimd table name      =",aimd_table)
print("solute table name    =",solute_table)
print("bad nmr table name   =",bad_nmr_table)
print("abbreviations name   =",abrev_table)
print("nwout filenames      =",nwofiles)


for outfile in nwofiles:
   if parse_aimdjob(outfile):
       insert_aimd_calculation(outfile,hup,dbfile,aimd_table,solute_table,nwpassword,nwmachine_aimd)
   elif parse_homolumojob(outfile):
       insert_homolumo(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles)
   elif parse_hrotorjob(outfile):
       print("into insert_hrotor")
       insert_hrotor(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles)
   else:
       insert_calculation(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine,extra_datafiles,noresubmit)

   #nmr_blob = parse_nmrblob(outfile)
   #if (nmr_blob!=''):
   #   insert_nmr_calculation(outfile,hup,dbfile,nmr_table,bad_nmr_table,nwpassword,nwmachine)

update_calculationscount(hup,dbfile,table,calculationscountfilename)

### delete temporary wrkdir files ###
try:
   os.unlink(wrkdir + "/" + tmpsmi1)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpsmi1)

try:
   os.unlink(wrkdir + "/" + tmpsmi2)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpsmi2)

try:
   os.unlink(wrkdir + "/" + tmpsmi3)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpsmi3)

try:
   os.unlink(wrkdir + "/" + tmpxyz1)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpxyz1)

try:
   os.unlink(wrkdir + "/" + tmpxyz2)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpxyz2)

try:
   os.unlink(wrkdir + "/" + outfile99)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + outfile99)

try:
   os.unlink(wrkdir + "/" + tmpxyz99)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpxyz99)

try:
   os.unlink(wrkdir + "/" + tmpgr)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmpgr)

try:
   os.unlink(wrkdir + "/" + tmphist)
except:
   print("chemdb_add_nwout7 Failed removing "+ wrkdir + "/" + tmphist)
