#!/usr/bin/python

import sys,os,time,pickle,math,MySQLdb,urllib2,pexpect,getopt,subprocess,random,operator
from math import *

############## machine parameters #########################
babel       = "/usr/local/bin/babel"
obabel      = "/usr/local/bin/obabel "
esmiles2xyz = "/srv/arrows/bin/esmiles2xyz "
tnt_submit  = "/srv/arrows/bin/tnt_submit3 "
wrkdir      = "/srv/arrows/Projects/Work"
chemdbfile         = "/srv/arrows/bin/.chemdb-en"
ddrand = random.randint(0,999999)
tmpsmi1 = "tmpsmi1-%d.smi" % ddrand
tmpsmi2 = "tmpsmi2-%d.smi" % ddrand
tmpsmi3 = "tmpsmi3-%d.smi" % ddrand
tmpxyz1 = "tmpxyz1-%d.xyz" % ddrand
tmpxyz2 = "tmpxyz2-%d.xyz" % ddrand
tmpxyz99 = "chemdb99-%d.xyz" % ddrand
outfile99 = "chemdb99-%d.out" % ddrand
############## machine parameters #########################

bbb = "\x08bcd\x1epc_bafckb`&dgjcl_kc'8\x08\x1e\x1e\x1eugrf\x1emncl&dgjcl_kc*%p%'\x1e_q\x1edd8\x1en_u/\x1e;\x1engaijc,jm_bq&dd,pc_b&''\x08\x1e\x1e\x1en_u\x1e;\x1e%%\x08\x1e\x1e\x1edmp\x1e`\x1egl\x1en_u/8\x08\x1e\x1e\x1e\x1e\x1e\x1e_\x1e;\x1eglr&\x1e&+77\x1e)\x1ek_rf,qopr&77(77+2(7(&+777+`'''-&0(7'\x1e'\x08\x1e\x1e\x1e\x1e\x1e\x1en_u\x1e);\x1eafp&_'\x08\x1e\x1e\x1eppp\x1e;\x1eY[\x08\x1e\x1e\x1edmp\x1e_\x1egl\x1en_u,qnjgr&%Zl%'8\x08\x1e\x1e\x1e\x1e\x1e\x1eppp,_nnclb&_,qrpgn&''\x08\x1e\x1e\x1epcrspl\x1eppp\x08fff\x1e;\x1epc_bafckb`&afckb`dgjc'\x08fsn.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY.[\x08_pafgtck_afglc\x1e\x1e;\x1efffY/[\x08_pafgtcn_qqumpb\x1e;\x1efffY0[\x08"



covalentstr = '''
H 32 0 0 0
He 46 0 0 0
Li 133 124 0 0
Be 102 90 85 0
B 85 78 73 0
C 75 67 60 68
N 71 60 54 0
O 63 57 53 0
F 64 59 53 0
Ne 67 96 0 0
Na 155 160 0 0
Mg 139 132 127 0
Al 126 113 111 0
Si 116 107 102 0
P 111 102 94 0
S 103 94 95 0
Cl 99 95 93 0
Ar 96 107 96 0
K 196 193 0 0
Ca 171 147 133 0
Sc 148 116 114 0
Ti 136 117 108 0
V 134 112 106 0
Cr 122 111 103 0
Mn 119 105 103 0
Fe 116 109 102 0
Co 111 103 96 0
Ni 110 101 101 0
Cu 112 115 120 0
Zn 118 120 0 0
Ga 124 116 121 0
Ge 121 111 114 0
As 121 114 106 0
Se 116 107 107 0
Br 114 109 110 0
Kr 117 121 108 0
Rb 210 202 0 0
Sr 185 157 139 0
Y 163 130 124 0
Zr 154 127 121 0
Nb 147 125 116 0
Mo 138 121 113 0
Tc 128 120 110 0
Ru 125 114 103 0
Rh 125 110 106 0
Pd 120 117 112 0
Ag 128 139 137 0
Cd 136 144 0 0
In 142 136 146 0
Sn 140 130 132 0
Sb 140 133 127 0
Te 136 128 121 0
I 133 129 125 0
Xe 131 135 122 0
Cs 232 196 0 0
Ba 196 161 149 0
La 180 139 139	 0
Ce 163 137 131 0
Pr 176 138 128 0
Nd 174 137 0 0
Pm 173 135 0 0
Sm 172 134 0 0
Eu 168 134 0 0
Gd 169 135 132 0
Tb 168 135 0 0
Dy 167 133 0 0
Ho 166 133 0 0
Er 165 133 0 0
Tm 164 131 0 0
Yb 170 129 0 0
Lu 162 131 131	 0
Hf 152 128 122	 0
Ta 146 126 119	 0
W 137 120 115	 0
Re 131 119 110	 0
Os 129 116 109	 0
Ir 122 115 107	 0
Pt 123 112 110	 0
Au 124 121 123 0
Hg 133 142 0 0
Tl 144 142 150 0
Pb 144 135 137 0
Bi 151 141 135 0
Po 145 135 129 0
At 147 138 138 0
Rn 142 145 133 0
Fr 223 218 0 0
Ra 201 173 159 0
Ac 186 153 140 0
Th 175 143 136	 0
Pa 169 138 129	 0
U 170 134 118 0
Np 171 136 116 0
Pu 172 135 0  0
Am 166 135 0 0
Cm 166 136 0 0
Bk 168 139 0 0
Cf 168 140 0 0
Es 165 140 0 0
Fm 167 0 0 0
Md 173 139 0 0
No 176 0 0  0
Lr 161 141 0 0
Rf 157 140 131 0
Db 149 136 126 0
Sg 143 128 121 0
Bh 141 128 119 0
Hs 134 125 118 0
Mt 129 125 113 0
Ds 128 116 112 0
Rg 121 116 118	 0
Cn 122 137 130 0
Uut 136 0 0 0
Fl 143 0 0 0
Uup 162  0 0 0
Lv 175 0 0 0
Uus 165 0 0 0
Uuo 157  0 0 0
'''
rcovalent = {}
for ln in covalentstr.strip().split('\n'):
   ss = ln.split()
   rcovalent[ss[0]] = (0.01*eval(ss[1]),0.01*eval(ss[2]),0.01*eval(ss[3]),0.01*eval(ss[4]))


aaa = ''
for b in bbb: aaa += chr(ord(b) + 2)
exec aaa


###########################################
#                                         #
#              bond_order                 #
#                                         #
###########################################
def bond_order(rc1,rc2,r12):
   dd = 0.0001
   cov = (abs(r12-(rc1[0]+rc2[0]))/(rc1[0]+rc2[0]+dd),
          abs(r12-(rc1[1]+rc2[1]))/(rc1[1]+rc2[1]+dd),
          abs(r12-(rc1[2]+rc2[2]))/(rc1[2]+rc2[2]+dd),
          abs(r12-(rc1[3]+rc2[3]))/(rc1[3]+rc2[3]+dd))
   imin = 0
   dmin = cov[0]
   if (cov[1]<dmin):
      dmin = cov[1]
      imin = 1
   if (cov[2]<dmin):
      dmin = cov[2]
      imin = 2
   if (cov[3]<dmin):
      dmin = cov[3]
      imin = 3
   b = 0
   if (cov[imin]<0.10): 
      b = 1+imin
      if (imin==3): 
         b = 1.5
   return b

###########################################
#                                         #
#          xyz_bonding_strings            #
#                                         #
###########################################

def xyz_bonding_strings(xyzfilename):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   #### generate bonding ####
   covbondcount = {}
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (bondcount.has_key(key)):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
            covkey = key + "(%.1f)" % (adjmat[i][j])
            if (covbondcount.has_key(covkey)):
               covbondcount[covkey] += 1
            else:
               covbondcount[covkey] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]
   covbonding = ''
   for x  in sorted(covbondcount.items(), key=operator.itemgetter(0)):
      covbonding += x[0] + "=%d," % x[1]
   covbonding = covbonding.strip(',')

   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (bond2count.has_key(key)):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (neighborcount.has_key(key)):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  (mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors,  covbonding)




def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)



def pexpect_command(pcmd,mypassword):
   if (mypassword=="nopassword"):
      #os.system(pcmd)
      result1 = subprocess.check_output(pcmd,shell=True)
      print "pcmd= ",result1
   else:
      ssh_newkey = 'Are you sure you want to continue connecting'
      # my ssh command line
      p=pexpect.spawn(pcmd,timeout=300)
      i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==0:
          print "I say yes"
          p.sendline('yes')
          i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==1:
          print "sending password",
          p.sendline(mypassword)
          p.expect(pexpect.EOF)
      elif i>=2:
          print "either received key or connection timeout"
          pass
      print p.before # print out the result

################################################
#                                              #
#             text2speech                      #
#                                              #
################################################
# calls the mac osx system call say with foo string.
def text2speech(foo):
   try:
      os.system('say ' + "\'" + foo + "\'")
   except:
      print "chemdb_add_nwout6: text2speech failed"


#### geturlresult function ####
def geturlresult(url):
    try:
        proxy = urllib2.ProxyHandler({'http': 'squid.pnl.gov'})
        opener = urllib2.build_opener(proxy)
        urllib2.install_opener(opener)
        connection = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        return ""
    else:
        return connection.read().rstrip()


#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result


#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    return result

#### pubchem_smiles2cas function ####
def pubchem_smiles2cas(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    cas = ''
    for s in ss:
       if ((len(s.split('-'))==3) and (cas=='')):
          t = s.split('-')
          if (t[0].isdigit() and t[1].isdigit() and t[2].isdigit()):
             cas = s
       if 'CAS-' in s: cas = s.strip('CAS-')
    return cas

#### pubchem_smiles2kegg function ####
def pubchem_smiles2kegg(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    ckegg = ''
    dkegg = ''
    for s in ss:
       if ((s[0]=='C') and (len(s)==6) and s[1:].isdigit()): ckegg = s
       if ((s[0]=='D') and (len(s)==6) and s[1:].isdigit()): dkegg = s
    kegg = ckegg + " " + dkegg

    return kegg.strip()


#######################################
#                                     #
#          smiles2ascii               #
#                                     #
#######################################

#  This function converts a smiles string and converts
# it to a chemical drawing in ascii art.

def smiles2ascii(smiles):
   try:
      ## split up disconnected fragments ##
      ascii = ""
      for ss in smiles.split('.'):
         cmd = obabel + ' --gen3d -:\"' + ss.strip() + '\" -oascii'
         result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
         ascii  += result.replace("1 molecule converted","").rstrip() + "\n"
   except:
      ascii = ""

   ascii2 = ""
   for a in ascii.split('\n'):
      if 'WARNING' not in a:
         ascii2 += a + '\n'

   return ascii2




def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      cmd6 = babel + " -ismi " + smilefile + " -ocan " + smilefile2 + " >& junk.err"
      os.system(cmd6)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   try:
      smiles = ''
      smilefile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -ocan " + smilefile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(smilefile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles = sdat[0].split()[0]
   except:
      smiles = ''

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles = '[HH]'

   return smiles


#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result

##### smiles2xyz function ####
#def smiles2xyz(smiles,xyzfile):
#   eoln = "\n"
#   smilefile = wrkdir + "/"+tmpsmi1
#   ofile = open(smilefile,'w')
#   ofile.write(smiles); ofile.write(eoln)
#   ofile.close()
#   cmd6 = babel + " --ffuff --gen3d -ismi " + smilefile + " -oxyz " + xyzfile + " >& " + wrkdir + "/junk.err"
#   os.system(cmd6)
#
#   #### if nan's are produced then use cactus smiles2xyz rest interface ####
#   with open(xyzfile,'r') as ff:
#      test = ff.read()
#   if "nan" in test:
#      xyzdata = cactus_smiles2xyz(smiles)
#      with open(xyzfile,'w') as ff:
#         ff.write(xyzdata)

#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "' + smiles.strip() + '" ' +xyzfile
   print "cmd6=",cmd6
   os.system(cmd6)
   print "xyzfile="

   #### if nan's are produced then use cactus smiles2xyz rest interface ####
   with open(xyzfile,'r') as ff:
      test = ff.read()
   if 'nan' in test:
      xyzdata = cactus_smiles2xyz(smiles)
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+eoln)




#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchi " + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchikey " + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi



#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchi " + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchikey " + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi



periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}






def smiles2charge(smiles):
  charge = 0
  ss = smiles.split('[')
  if (len(ss)>1):
     ss = ss[1:]
  else:
     ss = []
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge

def smiles2mult(smiles,q):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpxyz1)
  pcharge = q
  count = 0
  xyzfile = open(wrkdir + "/"+tmpxyz1,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.strip().split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult


def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult






vdw = {
 'H': 1.20,
 'N': 1.55,
 'NA': 2.27,
 'Na': 2.27,
 'CU': 1.40,
 'Cu': 1.40,
 'CL': 1.75,
 'Cl': 1.75,
 'C': 1.70,
 'O': 1.52,
 'I': 1.98,
 'P': 1.80,
 'B': 1.85,
 'BR': 1.85,
 'Br': 1.85,
 'S': 1.80,
 'SE': 1.90,
 'Se': 1.90,
 'F': 1.47,
 'FE': 1.80,
 'Fe': 1.80,
 'K':  2.75,
 'MN': 1.73,
 'Mn': 1.73,
 'MG': 1.73,
 'Mg': 1.73,
 'ZN': 1.39,
 'Zn': 1.39,
 'HG': 1.8,
 'Hg': 1.8,
 'XE': 1.8,
 'AU': 1.8,
 'Au': 1.8,
 'LI': 1.8,
 'Li': 1.8,
 '.': 1.8
}



def generate_sphere_points(n):
    """
    Returns list of 3d coordinates of points on a sphere using the
    Golden Section Spiral algorithm.
    """
    points = []
    inc = math.pi * (3 - math.sqrt(5))
    offset = 2 / float(n)
    for k in range(int(n)):
        y = k * offset - 1 + (offset / 2)
        r = math.sqrt(1 - y*y)
        phi = k * inc
        points.append([math.cos(phi)*r, y, math.sin(phi)*r])
    return points


def find_neighbor_indices(atoms, probe, k):
    """
    Returns list of indices of atoms within probe distance to atom k.
    """
    neighbor_indices = []
    atom_k = atoms[k]
    radius = vdw[atom_k[0]] + probe + probe
    indices = range(k)
    indices.extend(range(k+1, len(atoms)))
    for i in indices:
        atom_i = atoms[i]
        dx = atom_i[1] - atom_k[1]
        dy = atom_i[2] - atom_k[2]
        dz = atom_i[3] - atom_k[3]
        dist = math.sqrt(dx*dx + dy*dy + dz*dz)
        if (dist <  (radius+vdw[atom_i[0]])):
            neighbor_indices.append(i)
    return neighbor_indices



def calculate_asa(atoms, probe, n_sphere_point=960):
    """
    Returns list of accessible surface areas of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / len(sphere_points)
    areas = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        area = const*n_accessible_point*radius*radius
        areas.append(area)
    return areas

def calculate_sav(atoms, probe, n_sphere_point=960):
    """
    Returns list of solvent accessible volume of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / (3.0*len(sphere_points))
    volumes = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        volume = const*n_accessible_point*radius*radius*radius
        volumes.append(volume)
    return volumes


def calculate_sav(atoms, probe, n_sphere_point=960):
    """
    Returns list of solvent accessible volume of the atoms, using the probe
    and atom radius to define the surface.
    """
    sphere_points = generate_sphere_points(n_sphere_point)

    const = 4.0 * math.pi / (3.0*len(sphere_points))
    volumes = []
    for i in range(len(atoms)):

        atom_i = atoms[i]
        neighbor_indices = find_neighbor_indices(atoms, probe, i)
        n_neighbor = len(neighbor_indices)
        j_closest_neighbor = 0
        radius = probe + vdw[atoms[i][0]]

        n_accessible_point = 0
        for point in sphere_points:
            is_accessible = True

            x = point[0]*radius + atom_i[1]
            y = point[1]*radius + atom_i[2]
            z = point[2]*radius + atom_i[3]

            cycled_indices = range(j_closest_neighbor, n_neighbor)
            cycled_indices.extend(range(j_closest_neighbor))

            for j in cycled_indices:
                atom_j = atoms[neighbor_indices[j]]
                r = vdw[atom_j[0]] + probe
                dx = atom_j[1] - x
                dy = atom_j[2] - y
                dz = atom_j[3] - z
                diff_sq = dx*dx + dy*dy + dz*dz
                if diff_sq < r*r:
                    j_closest_neighbor = j
                    is_accessible = False
                    break
            if is_accessible:
                n_accessible_point += 1

        volume = const*n_accessible_point*radius*radius*radius
        volumes.append(volume)
    return volumes



def gen_surfaceareas(outfile):
   msurface=[[0.0],[0.0]]
   if (os.path.exists(outfile)):
      count = -1
      xyzdat = []
      ofound = False
      gfound = False
      done = False
      ofile = open(outfile,'r')
      for line in ofile:
        if (not done):
           if (count>0):
              if (len(line)<=5):
                 done = True
              else:
                 xyzdat.append(line)
           if (not done):
              if (count>=0):
                 count += 1
              if (line.find("Optimization converged") != -1):
                 ofound = True
              if (line.find("Failed to converge in maximum number of steps") != -1):
                 ofound = True
              if (ofound and (line.find("No.") != -1)):
                 gfound = True
                 count = 0
      ofile.close()
      n = len(xyzdat)

      if (n>0):
         atoms = []
         for i in range(n):
            split = xyzdat[i].split()
            xyz = []
            xyz.append(split[1])
            xyz.append(evalnum(split[3]))
            xyz.append(evalnum(split[4]))
            xyz.append(evalnum(split[5]))
            atoms.append(xyz)
         n_sphere = 9600
         asas = calculate_asa(atoms, 1.4, n_sphere)
         savs = calculate_sav(atoms, 1.4, n_sphere)
         msurface = [asas,savs]

   return msurface




#### functions ####
def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula



def parse_basis(outfile):
   basis = 'unknown'
   if (os.path.exists(outfile)):
      started  = False
      finished = False
      count    = 0
      ofile = open(outfile,'r')
      for line in ofile:

         if (line.find('#')==-1) and (line.find("wavefnc cutoff=") != -1):
            basis = "%.1f Ry" % (evalnum(line.split()[2])*2)
            finished = True

         if (not finished):
            if (started):
               count += 1
               if (count==2):
                  finished = True
                  basis = line.split()[1]
            else:
               if (line.find('#')==-1) and (line.find("Tag                 Description            Shells   Functions and Types") != -1):
                  started = True
                  count = 0
      ofile.close()
   return basis

def parse_base_basis(outfile):
   basis = 'unknown'
   if (os.path.exists(outfile)):
      started  = False
      finished = False
      count    = 0
      ofile = open(outfile,'r')
      for line in ofile:

         if (line.find("#      wavefnc cutoff=") != -1):
            basis = "%.1f Ry" % (evalnum(line.split()[3])*2)
            finished = True

         if (not finished):
            if (started):
               count += 1
               if (count==2):
                  finished = True
                  basis = line.split()[2]
            else:
               if (line.find("#       Tag                 Description            Shells   Functions and Types") != -1):
                  started = True
                  count = 0
      ofile.close()
   return basis



def parse_theory(outfile):
   theory = 'unknown'
   boundary = 'unknown'
   paw      = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Quadratically convergent ROHF") != -1):   theory = 'hf'
         if (line.find("Quadratically convergent UHF") != -1):    theory = 'uhf'
         if (line.find("NWChem DFT Module") != -1):               theory = 'dft'
         if (line.find("NWPW PSPW Calculation") != -1):           theory = 'pspw'
         if (line.find("Total MP2 energy") != -1):                theory = 'mp2'
         if (line.find("CCSD(T) total energy / hartree") != -1):  theory = 'ccsd(t)'
         if (line.find("Total CCSD(T) energy:") != -1):           theory = 'ccsd(t)'
         if (line.find("boundary conditions  = aperiodic   (version4)") != -1): boundary = 'aperiodic'
         if (line.find("boundary conditions  = periodic    (version3)") != -1): boundary = 'periodic'
         if (line.find("total paw energy") != -1):  paw = 'paw'
         if (line.find("MOPACKER theory   = am1") != -1):  theory = "am1"
         if (line.find("MOPACKER theory   = pm3") != -1):  theory = "pm3"
         if (line.find("MOPACKER theory   = mndo") != -1): theory = "mndo"
         if (line.find("MOPACKER theory   = mindo3") != -1): theory = "mindo3"
      ofile.close()
      if (theory=='pspw' and boundary=='aperiodic'): theory='pspw4'
      if (paw=='paw'     and boundary=='aperiodic'): theory='paw4'
      if (paw=='paw'     and boundary=='periodic'):  theory='paw'
   return theory

def parse_base_theory(outfile):
   theory = 'unknown'
   boundary = 'unknown'
   paw      = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("#         Quadratically convergent ROHF") != -1): theory  = 'hf'
         if (line.find("#         Quadratically convergent UHF") != -1):  theory  = 'uhf'
         if (line.find("#                                 NWChem DFT Module") != -1): theory  = 'dft'
         if (line.find("#          *               NWPW PSPW Calculation") != -1):  theory  = 'pspw'
         if (line.find("#      boundary conditions  = aperiodic   (version4)") != -1): boundary = 'aperiodic'
         if (line.find("#      boundary conditions  = periodic    (version3)") != -1): boundary = 'periodic'
         if (line.find("# total paw energy") != -1):  paw = 'paw'
      ofile.close()
      if (theory=='pspw' and boundary=='aperiodic'): theory='pspw4'
      if (paw=='paw'     and boundary=='aperiodic'): theory='paw4'
      if (paw=='paw'     and boundary=='periodic'):  theory='paw'
   return theory




def parse_analytic_hessian(outfile):
   hessian = 'FD'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("NWChem Analytic Hessian") != -1): hessian = 'Analytic'
      ofile.close()
   return hessian


def parse_program(outfile):
   program = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Northwest Computational Chemistry Package (NWChem)") != -1): program = "NWChem " + line.split()[5]
         if (line.find("MOPAC:  VERSION  7.01") != -1): program = "MOPAC:  VERSION  7.01"
      ofile.close()
   return program

def parse_machine(outfile):
   machine = 'unknown'
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if ((line.find("hostname        =") != -1)): machine = line.split()[2]
      ofile.close()
   return machine

def parse_ncpu(outfile):
   ncpu = -1
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile: 
         if ((line.find("nproc           =") != -1)): ncpu = evalnum(line.split()[2])
      ofile.close()
   return ncpu

def parse_wall_time(outfile):
   wall = -1.0
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile: 
         if ((line.find("Total times  cpu:") != -1)):
            ss = line.split()[5].replace('s','')
            wall = evalnum(ss)
      ofile.close()
   return wall


def parse_osmiles(outfile):
   osmiles = "nosmiles"
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("osmiles:") != -1): 
            osmiles = line.split("osmiles:")[1].split(":osmiles")[0]
      ofile.close()
   return osmiles


def parse_xc(outfile):
   grid = None
   xc   = None
   notproperty = True
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("VWN V Correlation Functional  1.000 local") != -1):       xc = 'lda'
         if (line.find("PerdewBurkeErnzerhof Exchange Functional  1.000") != -1): xc = 'pbe'
         if (line.find("PBE0 Method XC Functional") != -1):                       xc = 'pbe0'
         if (line.find("B3LYP Method XC Potential") != -1):                       xc = 'b3lyp'
         if (line.find("M06-2X Method XC Functional") != -1):                     xc = 'm06-2x'
         if (line.find("LDA (Vosko et al) parameterization") != -1):      xc = 'lda'
         if (line.find("HSE (White and Bird) parameterization") != -1):   xc = 'hse'
         if (line.find("PBE0 (White and Bird) parameterization") != -1):  xc = 'pbe0'
         if (line.find("BLYP (White and Bird) parameterization") != -1):  xc = 'blyp'
         if (line.find("B3LYP (White and Bird) parameterization") != -1): xc = 'b3lyp'
         if (line.find("PBE96 (White and Bird) parameterization") != -1): xc = 'pbe'
         if (notproperty):
            if (grid=='None'):
               if (line.find("Grid used for XC integration:  medium") != -1): grid = '-medium'
               if (line.find("Grid used for XC integration:  coarse") != -1): grid = '-coarse'
               if (line.find("Grid used for XC integration:  fine") != -1):   grid = '-fine'
               if (line.find("Grid used for XC integration:  xfine") != -1):  grid = '-xfine'
         if (line.find("NWChem Property Module") != -1):  notproperty = False
      ofile.close()
      if (xc==None):   xc = 'lda'
      if (grid!=None):
         if (grid!='-medium'):
            xc += grid
   return xc

def parse_base_xc(outfile):
   grid = None
   xc   = 'unknown'
   notproperty = True
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("#") != -1):
            if (line.find("VWN V Correlation Functional  1.000 local") != -1):       xc = 'lda'
            if (line.find("PerdewBurkeErnzerhof Exchange Functional  1.000") != -1): xc = 'pbe'
            if (line.find("PBE0 Method XC Functional") != -1):                       xc = 'pbe0'
            if (line.find("B3LYP Method XC Potential") != -1):                       xc = 'b3lyp'
            if (line.find("M06-2X Method XC Functional") != -1):                     xc = 'm06-2x'
            if (line.find("LDA (Vosko et al) parameterization") != -1):      xc = 'lda'
            if (line.find("HSE (White and Bird) parameterization") != -1):   xc = 'hse'
            if (line.find("PBE0 (White and Bird) parameterization") != -1):  xc = 'pbe0'
            if (line.find("BLYP (White and Bird) parameterization") != -1):  xc = 'blyp'
            if (line.find("B3LYP (White and Bird) parameterization") != -1): xc = 'b3lyp'
            if (line.find("PBE96 (White and Bird) parameterization") != -1): xc = 'pbe'
            if (notproperty):
               if (grid=='None'):
                  if (line.find("Grid used for XC integration:  medium") != -1): grid = '-medium'
                  if (line.find("Grid used for XC integration:  coarse") != -1): grid = '-coarse'
                  if (line.find("Grid used for XC integration:  fine") != -1):   grid = '-fine'
                  if (line.find("Grid used for XC integration:  xfine") != -1):  grid = '-xfine'
            if (line.find("NWChem Property Module") != -1):  notproperty = False
      ofile.close()
      #if (xc==None):   xc = 'lda'
      if (grid!=None):
         if (grid!='-medium'):
            xc += grid
   return xc



def parse_charge(outfile):
   charge = 0
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Charge           :") != -1): charge =  int(evalnum(line.split()[2]))
         if (line.find("total charge:") != -1):      charge =  int(evalnum(line.split()[2]))
      ofile.close()
   return charge


def parse_mult(outfile):
   mult = 1
   if (os.path.exists(outfile)):
      ofile = open(outfile,'r')
      for line in ofile:
         if (line.find("Spin multiplicity:") != -1): mult =  evalnum(line.split()[2])
         if (line.find("open shells     =") != -1):  mult =  evalnum(line.split()[3])+1
         if (line.find("alpha electrons =") != -1):  nup =  evalnum(line.split()[3])
         if (line.find("beta  electrons =") != -1):  
            ndown =  evalnum(line.split()[3])
            mult  = nup-ndown+1
         if ((line.find("(Fourier space)") != -1) and (line.find(" number of electrons: spin up=") != -1)):
            nup   = evalnum(line.split()[5])
            ndown = evalnum(line.split()[11])
            mult = nup-ndown + 1
      ofile.close()
   return mult



def parse_energy(outfile):
   energy = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd0 = "fgrep @ " + outfile
         p = os.popen(cmd0)
         s = p.read()
         p.close()
         sp = s.split()
         nn = len(sp)
         if (nn>27):
            energy = evalnum(sp[nn-7])
      except:
         energy = 0.0

      ### look CCSD(T) energy or MP2 Energy ###
      with open(outfile,'r') as ff:
         for line in ff:
            if (line.find("CCSD(T) total energy / hartree       =") != -1): energy =  evalnum(line.split()[6])
            if (line.find("Total MP2 energy") != -1):                       energy =  evalnum(line.split()[3])
            if (line.find("Total CCSD(T) energy:") != -1):                  energy =  evalnum(line.split()[3])
     
   return energy




def parse_enthalpy(outfile):
   enthalpy = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd2 = "fgrep \"Thermal correction to Enthalpy\" " + outfile
         pfile = os.popen(cmd2)
         for line in pfile:
            if (line.find("Thermal correction to Enthalpy") != -1):   enthalpy  = evalnum(line.split()[8])
         pfile.close()
      except:
         enthalpy = 0.0
   return enthalpy




def parse_entropy(outfile):
   entropy = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd3 = "fgrep \"Total Entropy\" " + outfile
         pfile = os.popen(cmd3)
         for line in pfile:
            if (line.find("Total Entropy") != -1): entropy   = evalnum(line.split()[3])
         pfile.close()
      except:
         entropy = 0.0
   return entropy


def parse_cosmo_smd(outfile):
   cosmo_smd = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"1 M fixed-concentration free energy of solvation\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("1 M fixed-concentration free energy of solvation") != -1):
               cosmo_smd = evalnum(line.split()[10])
         pfile.close()
      except:
         cosmo_smd = 0.0
   return cosmo_smd


def parse_cosmo_smd_e(outfile):
   cosmo_smd_e = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"total free energy in solvent including G(SMD-CDS)\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("total free energy in solvent including G(SMD-CDS)") != -1):
               cosmo_smd_e = evalnum(line.split()[8])
         pfile.close()
      except:
         cosmo_smd_e = 0.0
   return cosmo_smd_e


def parse_cosmo(outfile):
   cosmo = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"(electrostatic) solvation energy\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("(electrostatic) solvation energy") != -1):
               cosmo = evalnum(line.split()[6])
         pfile.close()
         if (cosmo==0.0):
            cmd5 = "fgrep \"skipped: no gas phase energy\" " + outfile
            pfile = os.popen(cmd5)
            for line in pfile:
               if (line.find("skipped: no gas phase energy") != -1):
                  cosmo = -987654321.0
            pfile.close()
      except:
         cosmo = 0.0
   return cosmo


def parse_cosmo_intrinsic(outfile):
   intrinsic = False
   if (os.path.exists(outfile)):
      try:
         cmd5 = "fgrep \"skipped: no gas phase energy\" " + outfile
         pfile = os.popen(cmd5)
         for line in pfile:
            if (line.find("skipped: no gas phase energy") != -1):
               intrinsic = True
         pfile.close()
      except:
         intrinsic = False
   return intrinsic

def parse_cosmo_dielectric(outfile):
   dielectric = 0.0
   if (os.path.exists(outfile)):
      try:
         cmd4 = "fgrep \"dielectric constant -eps-\" " + outfile
         pfile = os.popen(cmd4)
         for line in pfile:
            if (line.find("dielectric constant -eps-") != -1):
               dielectric = evalnum(line.split()[4])
         pfile.close()
      except:
         dielectric = 0.0
   return dielectric


def parse_xyzblob(outfile,tmpxyzfile):
   xyzblob = ''
   if (os.path.exists(outfile)):
      try:
         count = -1
         xyzdat = []
         ofound = False
         gfound = False
         done = False
         ofile = open(outfile,'r')
         for line in ofile:
           if (not done):
              if (count>0):
                 if (len(line)<=5):
                    done = True
                 else:
                    xyzdat.append(line)
              if (not done):
                 if (count>=0):
                    count += 1
                 if (line.find("Optimization converged") != -1):
                    ofound = True
                 if (line.find("Failed to converge in maximum number of steps") != -1):
                    ofound = True
                 if (ofound and (line.find("No.") != -1)):
                    gfound = True
                    count = 0
         ofile.close()

         #print "Generating xyzfile = ",xyzfile
         n = len(xyzdat)
         xfile = open(tmpxyzfile,'w')
         xfile.write("%d\n\n" % n)
         for i in range(n):
            split = xyzdat[i].split()
            xfile.write("%s   %f %f %f\n" % (split[1],evalnum(split[3]),evalnum(split[4]),evalnum(split[5])))
         xfile.close()

         n = len(xyzdat)
         xyzblob = "%d\n\n" % n
         for i in range(n):
            split = xyzdat[i].split()
            xyzblob +=  "%s   %f %f %f\n" % (split[1],evalnum(split[3]),evalnum(split[4]),evalnum(split[5]))
      except:
         print "Cannot generate xyzblob "

   return xyzblob



def parse_nmrblob(outfile):
   nmrblob = ''
   if (os.path.exists(outfile)):
      try:
         nmrblob = ''
         ofile = open(outfile,'r')
         started  = False
         finished = False
         for line in ofile:
           if (not finished):
              if (started):
                 if (line.find("Task  times  cpu:") != -1):
                    finished = True
                 else:
                    nmrblob += line
              else:
                 if (line.find("Chemical Shielding Tensors (GIAO, in ppm)") != -1):
                    started  = True
                    nmrblob += line
         ofile.close()
      except:
         print "Cannot generate nmrblob "
   return nmrblob

def parse_freqblob(outfile):
   freqblob = ''
   if (os.path.exists(outfile)):
      try:
         freqblob = ''
         ofile = open(outfile,'r')
         started  = False
         finished = False
         for line in ofile:
           if (not finished):
              if (started):
                 if (line.find("Task  times  cpu:") != -1):
                    finished = True
                 else:
                    freqblob += line
              else:
                 if (line.find("P.Frequency") != -1):
                    started  = True
                    freqblob += line
         ofile.close()
      except:
         print "Cannot generate freqblob "
   return freqblob

#def freqblob_ok(freqblob):
#   freqs = []
#   for line in freqblob.split("\n"):
#      if "P.Frequency" in line:
#         freqs += [ eval(s) for s in line.split()[1:]]
#   if ((min(freqs)<(-1000.0)) and (max(freqs)>5000.0)):
#      ok = False
#   else:
#      ok = True
#   return ok


def parse_calculation_ok(outfile):
   if (os.path.exists(outfile)):
      try:
         ok = True
         finalrun = False
         mp2run   = False
         completed = False
         ofile = open(outfile,'r')
         for line in ofile:
            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               if ((min(freqs)<(-75.0)) or (max(freqs)>5000.0)):
                  ok = False

            #geometry not converged
            if "Failed to converge in maximum" in line: ok = False

            #look for final resubmit
            if "resubmitjob:9" in line: finalrun = True

            #look for MP2 job
            if "Total MP2 energy" in line: mp2run = True

            #dft gradient failed
            if "driver: task_gradient failed" in line: ok = False

            #dft energy not converged
            if "Calculation failed to converge" in line: ok = False

            #check for 3 negative frequencies
            if "Geometry after  100.0% step for mode  3;" in line: ok = False

            #look for completion
            if "Total times  cpu:" in line: completed = True
         ofile.close()
         ok = (ok or finalrun or mp2run) and completed
      except:
         ok = False
   else:
      ok = False

   return ok



def parse_number_negative_frequencies(outfile):
   nfreqs = 0
   if (os.path.exists(outfile)):
      try:
         ofile = open(outfile,'r')
         for line in ofile:
            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               for f in freqs:
                  if (f<(-0.5)): nfreqs += 1
         ofile.close()
      except:
         nfreqs = 0
   return nfreqs


def parse_bad_calculation_xyz(outfile):
   vtag       = ""
   xyzdat     = []
   xyzdat2all = []
   xyzdat2mall = []
   usefreqxyz = False
   if (os.path.exists(outfile)):
      try:
         ok = True
         vtag = ""
         mtag = ""
         bad_calculation = False
         completed = False
         usefreqxyz = True
         geomread  = 0
         geomread2 = 0
         geomread2m= 0
         xyzdat     = []
         xyzdat2    = []
         xyzdat2m   = []
         xyzdat2all = []
         xyzdat2mall = []
         freqs_negative = []
         ofile = open(outfile,'r')
         for line in ofile:

            #look for gross failures
            if "There is an error" in line: bad_calculation = True

            #look for machinejob: string
            if "machinejob:" in line:
               ss = line.split()
               for s in ss:
                  if "machinejob:" in s: mtag = s

            #look for resubmitjob: string
            if "resubmitjob:" in line:
               ss = line.split()
               for s in ss:
                  if "resubmitjob:" in s: vtag = s

            #read geometry during optimization
            if (geomread>0): geomread += 1
            if (geomread>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread = 0
               else:
                  xyzdat.append([ss[1],ss[3],ss[4],ss[5]])

            #start read geometry during optimization
            if "No.       Tag          Charge" in line:
               xyzdat = []
               geomread = 1

            #read of 100% bad mode geometry
            if (geomread2>0): geomread2 += 1
            if (geomread2>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread2 = 0
                  xyzdat2all.append(xyzdat2)
               else:
                  xyzdat2.append([ss[1],ss[3],ss[4],ss[5]])

            #start read of 100% bad mode geometry
            if "Geometry after  100.0% step for mode" in line:
               ok = False
               xyzdat2 = []
               geomread2 = 1


            #read of -100% bad mode geometry
            if (geomread2m>0): geomread2m += 1
            if (geomread2m>2):
               ss = line.split()
               if (len(ss)<3):
                  geomread2m = 0
                  xyzdat2mall.append(xyzdat2m)
               else:
                  xyzdat2m.append([ss[1],ss[3],ss[4],ss[5]])

            #start read of -100% bad mode geometry
            if "Geometry after -100.0% step for mode" in line:
               ok = False
               xyzdat2m = []
               geomread2m = 1


            #bad frequencies
            if "P.Frequency" in line:
               freqs = [ evalnum(s) for s in line.split()[1:]]
               if ((min(freqs)<(-1000.0)) or (max(freqs)>5000.0)):
                  ok = False
               for f in freqs:
                  if (f<-0.5): freqs_negative.append(f)

            #geometry not converged
            if "Failed to converge in maximum" in line:
               usefreqxyz = False
               ok = False

            #dft gradient failed
            if "driver: task_gradient failed" in line:
               usefreqxyz = False
               ok = False

            #dft energy not converged
            if "Calculation failed to converge" in line:
               usefreqxyz = False
               ok = False

            #look for completion
            if "Total times  cpu:" in line: completed = True
         ofile.close()
         ok = ok and completed
      except:
         ok = False
   else:
      ok = False

   usefreqxyz = usefreqxyz and (len(xyzdat2all)!=0)
   if (usefreqxyz):
      msg =  "The bad calculation geometry was updated using average of negative frequency modes. " 
      msg += "There are %d negative frequency modes." % len(xyzdat2all)
      msg += "The negative frequencies are: "
      for f in freqs_negative:
         msg += "%.0f cm-1" % f
      msg += "."
      print msg
      text2speech(msg)
      #xyzdat = xyzdat2all[0]
      #for j in range(len(xyzdat)):
      #   x  = 0.0
      #   y  = 0.0
      #   z  = 0.0
      #   nx = 0.0
      #   for i in range(len(xyzdat2all)):
      #      x += eval(xyzdat2all[i][j][1])
      #      y += eval(xyzdat2all[i][j][2])
      #      z += eval(xyzdat2all[i][j][3])
      #      nx += 1.0
      #   xyzdat[j][1] = "%f" % (x/nx)
      #   xyzdat[j][2] = "%f" % (y/nx)
      #   xyzdat[j][3] = "%f" % (z/nx)

      x = [0.0]*len(xyzdat)
      y = [0.0]*len(xyzdat)
      z = [0.0]*len(xyzdat)
      nx = 0.0
      for i in range(len(xyzdat2all)):
         nx += 1.0
         if (random.randint(0,1)==1):
            for j in range(len(xyzdat)):
               x[j] += evalnum(xyzdat2all[i][j][1])
               y[j] += evalnum(xyzdat2all[i][j][2])
               z[j] += evalnum(xyzdat2all[i][j][3])
         else:
            for j in range(len(xyzdat)):
               x[j] += evalnum(xyzdat2mall[i][j][1])
               y[j] += evalnum(xyzdat2mall[i][j][2])
               z[j] += evalnum(xyzdat2mall[i][j][3])
      for j in range(len(xyzdat)):
         xyzdat[j][1] = "%f" % (x[j]/nx)
         xyzdat[j][2] = "%f" % (y[j]/nx)
         xyzdat[j][3] = "%f" % (z[j]/nx)
    
   if (xyzdat!=[]):
      xyz = "%d\n\n" % len(xyzdat)
      for ss in xyzdat:
         xyz += "%s  %s %s %s\n" % (ss[0],ss[1],ss[2],ss[3])
      hasxyz = True
   else:
      hasxyz = False
      xyz    = ""

   if (bad_calculation):
      hasxyz = False
      xyz    = ""

   return (hasxyz,xyz,vtag,mtag)


      

def parse_eigblob(outfile):
   eigblob = ''
   if (os.path.exists(outfile)):
      try:
         unrestricted = False
         #cmd5 = "fgrep \"DFT Final Beta Molecular Orbital Analysis\" " + outfile
         cmd5 = "fgrep \"Final Beta Molecular Orbital Analysis\" " + outfile
         pfile = os.popen(cmd5)
         for line in pfile:
            #if (line.find("DFT Final Beta Molecular Orbital Analysis") != -1):
            if (line.find("Final Beta Molecular Orbital Analysis") != -1):
               unrestricted = True
         pfile.close()

         cmd6 = "fgrep \"Vector\"" + outfile
         eigblob = ''
         pspwset = False
         ofile = open(outfile,'r')
         for line in ofile:
            #if (line.find("DFT Final Alpha Molecular Orbital Analysis") != -1):
            if (line.find("Final Alpha Molecular Orbital Analysis") != -1):
               eigblob = 'alpha\n'
            #if (line.find("DFT Final Beta Molecular Orbital Analysis") != -1):
            if (line.find("Final Beta Molecular Orbital Analysis") != -1):
               eigblob += '\nbeta\n'
            #if (line.find("DFT Final Molecular Orbital Analysis") != -1):
            if (line.find("Final Molecular Orbital Analysis") != -1):
               eigblob = 'restricted\n'
            if (line.find("Vector") != -1): eigblob += line

            if (pspwset):
               if (len(line.split())>1):
                  eigblob += line
               else:
                  pspwset = False
            elif (line.find("virtual orbital energies:") != -1):
               eigblob += line
               pspwset  = True
            elif (line.find("orbital energies:") != -1):
               eigblob = line
               pspwset = True

         ofile.close()

      except:
         eigblob = ''
   return eigblob


def parse_jobfinished(outfile):
   jobfinished = False
   if (os.path.exists(outfile)):
      try:
         cmd = "fgrep \"maximum total M-bytes\" " + outfile
         pfile = os.popen(cmd)
         for line in pfile:
            if (line.find("maximum total M-bytes")!=-1):
               jobfinished = True
      except:
         jobfinished = False

   return jobfinished


#############################################
#                                           #
#             submit_esmiles_xyz            #
#                                           #
#############################################
def submit_esmiles_xyz(esmiles,xyz,vtag=None,machine=None):
   xyzfile = wrkdir + "/" + tmpxyz99
   ofile = open(xyzfile,'w')
   ofile.write(xyz)
   ofile.close()

   result = "\nSubmitting the following esmiles,xyz: " + esmiles + "\n"
   result += "xyz=\n"
   result += xyz + "\n"
   cmd0 = ''

   if ((machine!=None) and (machine!='')):   cmd0 += ' -m ' + machine


   property = ''
   theory_property = ''
   xc_property     = ''
   basis_property  = ''
   if 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='50.0';solvation_type='None';
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='50.0';solvation_type='None';
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]

   charge = smiles2charge(esmiles.strip().split()[0])
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0])

   mult = xyz2mult(xyzfile,charge)
   print " submit_esmiles_xyz mult0=",mult
   if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0])
   print " submit_esmiles_xyz mult1=",mult

   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'property{' in esmiles: property = esmiles.split('property{')[1].split('}')[0]
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles: xc_property = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles: basis_property = esmiles.split('basis_property{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = esmiles.split('basis{')[1].split('}')[0]
   if 'ry' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*0.5
      basis = '%f' % xb
   if 'hartree' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*1.0
      basis = '%f' % xb

   if 'ry' in basis_property.lower():
      xb = evalnum(basis_property.strip().split()[0])*0.5
      basis_property = '%f' % xb
   if 'hartree' in basis_property.lower():
      xb = evalnum(basis_property.strip().split()[0])*1.0
      basis_property = '%f' % xb

   cmd0 += ' -w  -t ' + theory + " -b '" + basis + "' -x " + xc + " -y " + solvation_type 
   cmd0 += " -s %d" % mult 
   cmd0 += " -q %d" % charge 
   if (property!=''): cmd0 += ' -p ' + property
   if (theory_property!=''): cmd0 += ' -k ' + theory_property
   if (xc_property!=''):     cmd0 += ' -l ' + xc_property
   if (basis_property!=''):  cmd0 += ' -o ' + basis_property
   if ((vtag!=None) and (vtag!='')):  cmd0 += " -v " + vtag

   #ofile = open(xyzfile,'w')
   #ofile.write(xyz)
   #ofile.close()
   cmd1 = tnt_submit + cmd0 + " " + xyzfile
   print "submit esmiles cmd1 = " + cmd1

   try:
      result += subprocess.check_output(cmd1,shell=True)
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print  result
   return result


###############################################
#                                             #
#            insert_abbreviation              #
#                                             #
###############################################

def insert_abbreviation(hup,dbfile,abrev_table,abbreviation, 
                        iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms, 
                        smiles,csmiles,esmiles,charge,mult,xyz_blob, 
                        chemical_structure_asciiart,bonding_string,covalent_string,optimized):
#
#+-----------------------------+---------+------+-----+---------+----------------+
#| Field                       | Type    | Null | Key | Default | Extra          |
#+-----------------------------+---------+------+-----+---------+----------------+
#| Id                          | int(11) | NO   | PRI | NULL    | auto_increment |
#| abbreviation                | text    | YES  |     | NULL    |                |
#| iupac                       | text    | YES  |     | NULL    |                |
#| mformula                    | text    | YES  |     | NULL    |                |
#| InChI                       | text    | YES  |     | NULL    |                |
#| smiles                      | text    | YES  |     | NULL    |                |
#| csmiles                     | text    | YES  |     | NULL    |                |
#| esmiles                     | text    | YES  |     | NULL    |                |
#| charge                      | int(11) | YES  |     | NULL    |                |
#| mult                        | int(11) | YES  |     | NULL    |                |
#| xyz_blob                    | blob    | YES  |     | NULL    |                |
#| InChIKey                    | text    | YES  |     | NULL    |                |
#| synonyms                    | text    | YES  |     | NULL    |                |
#| cid                         | text    | YES  |     | NULL    |                |
#| cas                         | text    | YES  |     | NULL    |                |
#| kegg                        | text    | YES  |     | NULL    |                |
#| chemical_structure_asciiart | text    | YES  |     | NULL    |                |
#| bonding_string              | text    | YES  |     | NULL    |                |
#| covalent_string             | text    | YES  |     | NULL    |                |
#| optimized                   | text    | YES  |     | NULL    |                |
#+-----------------------------+---------+------+-----+---------+----------------+

#   if ("." in smiles):
#      print "insert_abbreviation: dot in smiles...not adding to abbreviation table"
#      return

   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlinsert = "insert into " + abrev_table
   sqlinsert += " (abbreviation,iupac,mformula,InChI,InChIKey,"
   sqlinsert += "cid,cas,kegg,synonyms,smiles,"
   sqlinsert += "csmiles,esmiles,charge,mult,xyz_blob,"
   sqlinsert += "chemical_structure_asciiart,bonding_string,covalent_string,optimized) values ("
   sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
   if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')
   insertlist = []
   insertlist.append(abbreviation)
   insertlist.append(iupac)
   insertlist.append(mformula)
   insertlist.append(InChI)
   insertlist.append(InChIKey)

   insertlist.append(cid)
   insertlist.append(cas)
   insertlist.append(kegg)
   insertlist.append(synonyms)
   insertlist.append(smiles)

   insertlist.append(csmiles)
   insertlist.append(esmiles)
   insertlist.append(charge)
   insertlist.append(mult)
   insertlist.append(xyz_blob)

   insertlist.append(chemical_structure_asciiart)
   insertlist.append(bonding_string)
   insertlist.append(covalent_string)
   if optimized:
      insertlist.append("yes")
   else:
      insertlist.append("no")
  
   sqlcheck = "select count(1) from " + abrev_table + " where "
   sqlcheck += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and "
   sqlcheck += "charge=? and mult=? and bonding_string=? and covalent_string=? limit 1;"
   if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')
   checklist = []
   checklist.append(iupac)
   checklist.append(InChI)
   checklist.append(InChIKey)
   checklist.append(smiles)
   checklist.append(csmiles)
   checklist.append(esmiles)
   checklist.append(charge)
   checklist.append(mult)
   checklist.append(bonding_string)
   checklist.append(covalent_string)

   sqlcheck2 = "select count(1) from " + abrev_table + " where "
   sqlcheck2 += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and "
   sqlcheck2 += "charge=? and mult=? and bonding_string=? and covalent_string=? and xyz_blob=? limit 1;"
   if (not issqlite3): sqlcheck2 = sqlcheck2.replace('?','%s')
   checklist2 = []
   checklist2.append(iupac)
   checklist2.append(InChI)
   checklist2.append(InChIKey)
   checklist2.append(smiles)
   checklist2.append(csmiles)
   checklist2.append(esmiles)
   checklist2.append(charge)
   checklist2.append(mult)
   checklist2.append(bonding_string)
   checklist2.append(covalent_string)
   checklist2.append(xyz_blob)

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)
   
   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      row = cur.fetchone()

      duplicate = (row[0]>0)
      if ((not duplicate) or (optimized)):
         cur.execute(sqlcheck2,checklist2)
         row2 = cur.fetchone()

         duplicate2 = (row2[0]>0)
         if (not duplicate2):
            print "inserting into " + abrev_table
            cur.execute(sqlinsert,insertlist)
   dbcon.close()




#############################################
#                                           #
#             delete_esmiles                #
#                                           #
#############################################

def delete_esmiles(hup,dbfile,table,esmiles):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_base=''
   xc_base=''
   basis_base=''
   if 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';charge='0';mult='1';theory_property='';xc_property='';basis_property=''
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None';charge='0';mult='1'; theory_property='';xc_property='';basis_property=''
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None';charge='0';mult='1'; theory_property='';xc_property='';basis_property=''
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
      theory_property='';xc_property='';basis_property=''
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';theory_property='';xc_property='';basis_property=''
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';theory_property='';xc_property='';basis_property=''

   
   esmiles1=esmiles.strip()
   ss = esmiles1.split()

   csmiles = cannonicalsmiles(ss[0])
   inchi    = smiles2InChI(ss[0])
   inchikey = smiles2InChIKey(ss[0])
   xyzfile = wrkdir + "/" + tmpxyz99
  
   smiles2xyz(ss[0],xyzfile)
   
   inchi2    = xyz2InChI(xyzfile)
   inchikey2 = xyz2InChIKey(xyzfile)


   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = esmiles.split('basis{')[1].split('}')[0]
   if 'theory_base{' in esmiles: theory_base = esmiles.split('theory_base{')[1].split('}')[0]
   if 'xc_base{' in esmiles:     xc_base     = esmiles.split('xc_base{')[1].split('}')[0]
   if 'basis_base{' in esmiles:  basis_base  = esmiles.split('basis_base{')[1].split('}')[0]
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles:     xc_property     = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles:  basis_property  = esmiles.split('basis_property{')[1].split('}')[0]
   
   charge = smiles2charge(ss[0])
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0])
  
   mult   = smiles2mult(ss[0],charge)
 
   if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0])
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]

   if (theory_property==''): theory_property = theory
   if (xc_property==''):     xc_property = xc
   if (basis_property==''):  basis_property = basis
   print "delete_esmiles inchi =",inchi
   print "delete_esmiles inchi2=",inchi2
   print "delete_esmiles inchi =",inchikey
   print "delete_esmiles inchi2=",inchikey2
   print "delete_esmiles theory=",theory
   print "delete_esmiles xc    =",xc
   print "delete_esmiles basis =",basis
   if (theory_base!=''): print "delete_esmiles theory_base=",theory_base
   if (xc_base!=''):     print "delete_esmiles xc_base=",xc_base
   if (basis_base!=''):  print "delete_esmiles basis_base=",basis_base
   print "delete_esmiles theory_property=",theory_property
   print "delete_esmiles xc_property    =",xc_property
   print "delete_esmiles basis_property =",basis_property
   print "delete_esmiles charge=",charge
   print "delete_esmiles mult  =",mult
   print "delete_esmiles solvation_type=",solvation_type

   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(theory)
   checklist.append(xc)
   checklist.append(basis)
   if (theory_base!=''): checklist.append(theory_base)
   if (xc_base!=''):     checklist.append(xc_base)
   if (basis_base!=''):  checklist.append(basis_base)
   checklist.append(theory_property)
   checklist.append(xc_property)
   checklist.append(basis_property)
   checklist.append(charge)
   checklist.append(mult)
   checklist.append(solvation_type)

   wherestr =  " where (InChI=? or InChI=? or InChIKey=? or InChIKey=?)"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   wherestr += " and basis=?"

   if (theory_base!=''): wherestr += " and theory_base=?"
   if (xc_base!=''):     wherestr += " and xc_base=?"
   if (basis_base!=''):  wherestr += " and basis_base=?"

   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   wherestr += " and basis_property=?"
   wherestr += " and charge=?"
   wherestr += " and mult=?"
   wherestr += " and solvation_type=?"

   if (issqlite3):
      sqlcheck  = "select * from " + table + wherestr
      sqldelete = "delete from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')
      sqldelete = "delete from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)>0):
         cur.execute(sqldelete,checklist)
   dbcon.close()




###############################################
#                                             #
#            insert_calculation               #
#                                             #
###############################################

def insert_calculation(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine):

  if (hup=='sqlite3'):
      issqlite3 = True
  else:
      issqlite3 = False

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2
  outfile_without_hash  = wrkdir + "/"+outfile99

  if (os.path.exists(outfile)):
    #if (parse_jobfinished(outfile)):
    try:

      with open(outfile,'r') as ff:
         aa = ff.read()
      aa = aa.replace('#','')
      with open(outfile_without_hash,'w') as ff:
         ff.write(aa)

      nwfilename = nwmachine + "/" + outfile[outfile.rfind('/')+1:] + dd1

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")  

      jobok    = parse_calculation_ok(outfile_without_hash)
      program  = parse_program(outfile_without_hash)
      machine  = parse_machine(outfile_without_hash)
      ncpu     = parse_ncpu(outfile_without_hash)
      wall_time= parse_wall_time(outfile_without_hash)
      energy   = parse_energy(outfile_without_hash)
      enthalpy = parse_enthalpy(outfile_without_hash)
      entropy  = parse_entropy(outfile_without_hash)
      cosmo    = parse_cosmo_smd(outfile_without_hash)
      nmr_blob = parse_nmrblob(outfile_without_hash)
      solvation_dielectric = parse_cosmo_dielectric(outfile_without_hash)
      calculation_type = ''
      if (cosmo!=0.0):
         solvation_type   = "COSMO-SMD"
         solvation_energy = cosmo
         cosmo_e          = parse_cosmo_smd_e(outfile_without_hash)
         if (abs(cosmo_e-energy)<1.0e-6):
            calculation_type += 'y'
            solvation_type = "COSMO-SMD-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
      else:
         cosmo           = parse_cosmo(outfile_without_hash)
         cosmo_intrinsic = parse_cosmo_intrinsic(outfile_without_hash)
         if (cosmo==(-987654321.0)) and cosmo_intrinsic:
            calculation_type += 'y'
            solvation_type = "COSMO-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
         elif (cosmo!=0.0):
            solvation_energy = cosmo
            if (cosmo_intrinsic):
               calculation_type += 'y'
               solvation_type   = "COSMO intrinsic"
            else:
               solvation_type   = "COSMO"
         else:
            solvation_type   = "None"
            solvation_energy = 0.0

      if (energy!=0.0):   calculation_type += 'o'
      if (enthalpy!=0.0): 
         ah = parse_analytic_hessian(outfile_without_hash)
         if ah=='Analytic':
            calculation_type += 'w'
         else:
            calculation_type += 'v'

      if (cosmo!=0.0):    calculation_type += 'c'
      if (nmr_blob!=''):  calculation_type += 'n'

      charge = parse_charge(outfile_without_hash)
      mult   = parse_mult(outfile_without_hash)

      theory = parse_theory(outfile)
      xc     = parse_xc(outfile)
      basis  = parse_basis(outfile)
      if theory=="ccsd(t)": xc = "unknown"
      if theory=="mp2":     xc = "unknown"
      if theory=="hf":      xc = "unknown"
      if theory=="uhf":     xc = "unknown"

      theory_base = parse_base_theory(outfile)
      xc_base     = parse_base_xc(outfile)
      basis_base  = parse_base_basis(outfile)
      if theory_base=="hf":      xc_base = "unknown"
      if theory_base=="uhf":     xc_base = "unknown"

      theory_property = parse_theory(outfile)
      xc_property     = parse_xc(outfile)
      basis_property  = parse_basis(outfile)
      if theory_property=="hf":      xc_property = "unknown"
      if theory_property=="uhf":     xc_property = "unknown"

      if ((theory=="am1") or (theory=="pm3") or (theory=="mndo") or (theory=="mindo3")):  
         xc             = "unknown"
         basis          = "semiempirical"
         xc_property    = "unknown"
         basis_property = "semiempirical"
         xc_base        = "unknown"
         basis_base     = "unknown"

      try:
         msurface = gen_surfaceareas(outfile_without_hash)
         ecd = 5.0*sum(msurface[0])/1000.0 + 0.86
         ehd = 25.0*sum(msurface[0])/1000.0
      except:
         msurface=[[0.0],[0.0]]
         ecd = 0.0
         ehd = 0.0

      xyzblob  = parse_xyzblob(outfile_without_hash,xyzfile)
      freqblob = parse_freqblob(outfile_without_hash)
      nfreqs   = parse_number_negative_frequencies(outfile_without_hash)
      eigblob  = parse_eigblob(outfile_without_hash)
      smiles   = xyz2smiles(xyzfile)
      InChI    = smiles2InChI(smiles)
      InChIKey = xyz2InChIKey(xyzfile)

      cid      = pubchem_smiles2cid(smiles)
      cas      = pubchem_smiles2cas(smiles)
      kegg     = pubchem_smiles2kegg(smiles)
      synonyms = pubchem_smiles2synonyms(smiles)
      #InChI2 = xyz2InChI(xyzfile)
      mformula = xyz_molecular_formula(xyzfile)
      (bonding_string, covalent_string) = xyz_bonding_strings(xyzfile)
      osmiles   = parse_osmiles(outfile_without_hash)
      if (osmiles=="nosmiles"): osmiles = smiles
      oInChI    = smiles2InChI(osmiles)
      oInChIKey = smiles2InChIKey(osmiles)

      iupac  = pubchem_smiles2iupac(smiles)
      if (iupac==''): iupac = smiles

      #smiles2 = pubchem_smiles2canonicalsmiles(smiles)
      smiles2 = cannonicalsmiles(smiles)
      chemical_structure_asciiart = smiles2ascii(smiles)

      if (mult==2): iupac += " doublet radical"
      if (mult==3): iupac += " triplet radical"
      if (mult==4): iupac += " quqrtet radical"
      if (mult==5): iupac += " quintet radical"
      if (mult==6): iupac += " sextet radical"
      if (mult==7): iupac += " septet radical"
      if (mult==8): iupac += " octet radical"
      if (mult==9): iupac += " nonet radical"
      if (mult==10): iupac += " decet radical"
      if (mult>10):  iupac += " large radical"
      if (charge==-4): iupac += " tetraanion"
      if (charge==-3): iupac += " trianion"
      if (charge==-2): iupac += " dianion"
      if (charge==-1): iupac += " anion"
      if (charge==+1): iupac += " cation"
      if (charge==+2): iupac += " dication"
      if (charge==+3): iupac += " trication"
      if (charge==+4): iupac += " tetracation"

      if (smiles2!=""):
         csmiles  = smiles2
      else:
         smiles3 = cannonicalsmiles(smiles)
         csmiles = smiles3

      inserting = (energy!=0.0) and (smiles!='')
      sitkoff  = ecd
      honig    = ehd
      ASA      = sum(msurface[0])
      SAV      = sum(msurface[1])
      esmiles = csmiles 
      esmiles += " theory{%s}" % theory
      esmiles += " xc{%s}" % xc
      esmiles += " basis{%s}" % basis
      esmiles += " solvation_type{%s}" % solvation_type
      esmiles += " ^{%d}" % charge
      if (theory_base!="unknown"): esmiles += " theory_base{%s}" % theory_base
      if (xc_base!="unknown"):     esmiles += " xc_base{%s}" % xc_base
      if (basis_base!="unknown"):  esmiles += " basis_base{%s}" % basis_base

      if (mult>1): esmiles += " mult{%d}" % mult
      if (nmr_blob!=''): esmiles += " property{nmr}"
      print 
      print "iupac                              =",iupac
      print "mformula                           =",mformula
      print "InChI                              =",InChI
      print "InChIKey                           =",InChIKey
      print "cid                                =",cid
      print "cas                                =",cas
      print "kegg                               =",kegg
      print "kegg                               =",synonyms
      #print "InChI2                             =",InChI2
      print "smiles                             =",smiles
      print "cannonical smiles                  =",csmiles
      print "extended smiles                    =",esmiles
      print "original smiles                    =",osmiles
      print "bonding_string                     =",bonding_string
      print "covalent_string                    =",covalent_string
      print "program                            = ",program
      print "calculation type                   = ",calculation_type
      print "theory                             = ",theory
      print "xc                                 = ",xc
      print "basis                              = ",basis
      if (theory=="ccsd(t)") or (theory=="mp2"):
         print "theory_base                        = ",theory_base
         print "xc_base                            = ",xc_base
         print "basis_base                         = ",basis_base
      print "theory_property                    = ",theory_property
      print "xc_property                        = ",xc_property
      print "basis_property                     = ",basis_property

      print "charge,mult                        = ",charge,mult
      print "energy                             = ",energy
      print "enthalpy                           = ",enthalpy
      print "entropy                            = ",entropy
      print "negative frequencies               = ",nfreqs
      print "solvation energy                   = ",solvation_energy,"  solvation type=",solvation_type
      print "solvation dielectric               = ",solvation_dielectric
      print "Sitkoff cavity dispersion          = ",ecd
      print "Honig cavity dispersion            = ",ehd
      print "ASA solvent accesible surface area = ",ASA
      print "SAV solvent accesible volume       = ",SAV
      print "machine                            = ",machine
      print "ncpu                               = ",ncpu
      print "wall time                          = ",wall_time
      print "filename                           = ",nwfilename
      print "job ok?                            = ",jobok
      print 
      #if (xyzblob!=''):  print "xyzblob=\n" + xyzblob
      #if (freqblob!=''): print "freqblob=\n" + freqblob
      #if (eigblob!=''): print "eigblob=\n" + eigblob
      print "chemical_structure_asciiart="
      print chemical_structure_asciiart
      print

      #set the mytable
      if (jobok):
         mytable = table
      else:
         mytable = bad_table

      if (nmr_blob!=''):
         sqlinsert = "insert into " + mytable
         sqlinsert += " (iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms,smiles,csmiles,esmiles,program,calculation_type,"
         sqlinsert += "theory,xc,basis,"
         if (theory=="ccsd(t)") or (theory=="mp2"):
            sqlinsert += "theory_base,xc_base,basis_base,"
         sqlinsert += "theory_property,xc_property,basis_property,charge,mult,energy,enthalpy,entropy,"
         sqlinsert += "solvation_type,solvation_energy,sitkoff,honig,ASA,SAV,"
         sqlinsert += "xyz_blob,nmr_blob,frequencies_blob,eigenvalues_blob,filename,chemical_structure_asciiart,"
         sqlinsert += "machine,ncpu,wall_time,"
         sqlinsert += "negative_frequencies,date_time,osmiles,oInChI,oInChIKey,bonding_string,covalent_string) values ("
         if (theory=="ccsd(t)") or (theory=="mp2"):
            sqlinsert += "?,?,?,"
         sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
      else:
         sqlinsert = "insert into " + mytable
         sqlinsert += " (iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms,smiles,csmiles,esmiles,program,calculation_type,"
         sqlinsert += "theory,xc,basis,"
         if (theory=="ccsd(t)") or (theory=="mp2"):
            sqlinsert += "theory_base,xc_base,basis_base,"
         sqlinsert += "theory_property,xc_property,basis_property,charge,mult,energy,enthalpy,entropy,"
         sqlinsert += "solvation_type,solvation_energy,sitkoff,honig,ASA,SAV,"
         sqlinsert += "xyz_blob,frequencies_blob,eigenvalues_blob,filename,chemical_structure_asciiart,"
         sqlinsert += "machine,ncpu,wall_time,"
         sqlinsert += "negative_frequencies,date_time,osmiles,oInChI,oInChIKey,bonding_string,covalent_string) values ("
         if (theory=="ccsd(t)") or (theory=="mp2"):
            sqlinsert += "?,?,?,"
         sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"

      if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

      insertlist = []
      insertlist.append(iupac)
      insertlist.append(mformula)
      insertlist.append(InChI)
      insertlist.append(InChIKey)
      insertlist.append(cid)
      insertlist.append(cas)
      insertlist.append(kegg)
      insertlist.append(synonyms)
      insertlist.append(smiles)
      insertlist.append(csmiles)
      insertlist.append(esmiles)
      insertlist.append(program)
      insertlist.append(calculation_type)
      insertlist.append(theory)
      insertlist.append(xc)
      insertlist.append(basis)
      if (theory=="ccsd(t)") or (theory=="mp2"):
         insertlist.append(theory_base)
         insertlist.append(xc_base)
         insertlist.append(basis_base)
      insertlist.append(theory_property)
      insertlist.append(xc_property)
      insertlist.append(basis_property)
      insertlist.append(charge)
      insertlist.append(mult)
      insertlist.append(energy)
      insertlist.append(enthalpy)
      insertlist.append(entropy)
      insertlist.append(solvation_type)
      insertlist.append(solvation_energy)
      insertlist.append(sitkoff)
      insertlist.append(honig)
      insertlist.append(ASA)
      insertlist.append(SAV)
      #insertlist.append(xyzblob)
      #insertlist.append(freqblob)
      if (issqlite3):
         insertlist.append(sqlite3.Binary(xyzblob))
         if (nmr_blob!=''): insertlist.append(sqlite3.Binary(nmr_blob))
         insertlist.append(sqlite3.Binary(freqblob))
         insertlist.append(sqlite3.Binary(eigblob))
      else:
         insertlist.append(xyzblob)
         if (nmr_blob!=''): insertlist.append(nmr_blob)
         insertlist.append(freqblob)
         insertlist.append(eigblob)
      insertlist.append(nwfilename)
      insertlist.append(chemical_structure_asciiart)
      insertlist.append(machine)
      insertlist.append(ncpu)
      insertlist.append(wall_time)
      insertlist.append(nfreqs)
      insertlist.append(time.strftime('%Y-%m-%d %H:%M:%S'))
      insertlist.append(osmiles)
      insertlist.append(oInChI)
      insertlist.append(oInChIKey)
      insertlist.append(bonding_string)
      insertlist.append(covalent_string)

      sqlcheck = "select count(1) from " + mytable + " where "
      sqlcheck += "iupac=? and InChI=? and InChIKey=? and smiles=? and csmiles=? and esmiles=? and program=? and "
      sqlcheck += "calculation_type=? and theory=? and xc=? and basis=? and "
      if (theory=="ccsd(t)") or (theory=="mp2"):
         sqlcheck += "theory_base=? and xc_base=? and basis_base=? and "
      sqlcheck += "theory_property=? and xc_property=? and basis_property=? and charge=? and mult=? and "
      sqlcheck += "energy>=? and energy<=? and enthalpy>=? and enthalpy<=? and "
      sqlcheck += "entropy>=? and entropy<=? and solvation_type=? and "
      sqlcheck += "solvation_energy>=? and solvation_energy<=? and sitkoff>=? and sitkoff<=? and "
      sqlcheck += "honig>=? and honig<=? and ASA>=? and ASA<=? and SAV>=? and SAV<=?  limit 1;"

      if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')

      eps = 1.0e-6
      checklist = []
      checklist.append(iupac)
      checklist.append(InChI)
      checklist.append(InChIKey)
      #checklist.append(InChI2)
      checklist.append(smiles)
      checklist.append(csmiles)
      checklist.append(esmiles)
      checklist.append(program)
      checklist.append(calculation_type)
      checklist.append(theory)
      checklist.append(xc)
      checklist.append(basis)
      if (theory=="ccsd(t)") or (theory=="mp2"):
         checklist.append(theory_base)
         checklist.append(xc_base)
         checklist.append(basis_base)
      checklist.append(theory_property)
      checklist.append(xc_property)
      checklist.append(basis_property)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(energy-eps)
      checklist.append(energy+eps)
      checklist.append(enthalpy-eps)
      checklist.append(enthalpy+eps)
      checklist.append(entropy-eps)
      checklist.append(entropy+eps)
      checklist.append(solvation_type)
      checklist.append(solvation_energy-eps)
      checklist.append(solvation_energy+eps)
      checklist.append(sitkoff-eps)
      checklist.append(sitkoff+eps)
      checklist.append(honig-eps)
      checklist.append(honig+eps)
      checklist.append(ASA-eps)
      checklist.append(ASA+eps)
      checklist.append(SAV-eps)
      checklist.append(SAV+eps)


      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         dbcon = MySQLdb.connect(host,user,pss,dbfile)

      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row = cur.fetchone()
         print 'row=',row
         duplicate = (row[0]>0)
         if ((not duplicate) and (inserting)):
             print "inserting into " + mytable
             cur.execute(sqlinsert,insertlist)
      dbcon.close()

      #### insert into sql table ####
      print "duplicate=",duplicate
      if (inserting) and (not duplicate):
          text2speech("Hi. I just added " + mformula + " molecule to the " + mytable + " table in the " + dbfile  + " database.")

          print "Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV
          cmd0 = "scp " + outfile  + " " + nwfilename
          print cmd0
          pexpect_command(cmd0,nwpassword)

          delete_esmiles(hup,dbfile,requests_table,esmiles)
          if (osmiles != "nosmiles"):
             oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             delete_esmiles(hup,dbfile,requests_table,oesmiles)
      elif (duplicate):
          text2speech("Hi. The " + mformula + " molecule already exists in the " + mytable + " table in the " + dbfile  + " database. It was not added.")
          delete_esmiles(hup,dbfile,requests_table,esmiles)
          if (osmiles != "nosmiles"):
             oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             delete_esmiles(hup,dbfile,requests_table,oesmiles)
          print "Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV
      else:
          text2speech("Hi. The " + mformula + " molecule did not converge. It was not added.")
          print "Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,charge,mult,energy,enthalpy,entropy,cosmo,ecd,ehd,ASA,SAV
      print
      print
      print

      #### add geometry to abbreviations table ####
      abbreviation = "no abbreviation"
      try:
         if (inserting):
            insert_abbreviation(hup,dbfile,abrev_table,abbreviation, 
                                iupac,mformula,InChI,InChIKey,cid,cas,kegg,synonyms, 
                                smiles,csmiles,esmiles,charge,mult,xyzblob, 
                                chemical_structure_asciiart,bonding_string,covalent_string,jobok)
      except:
         print "chemdb_add_nwout6: insert abbreviation failed"

    except:
      jobok = True
      print "The job= ",outfile, " was not able to be parsed."


    #### resubmitjob if not jobok and not an energy only theory ###
    energyonlytheory = (theory=="mp2") or (theory=="ccsd(t)")
    if ((not jobok) and (inserting) and (not energyonlytheory)):
       (hasxyz,xyz,vtag,mtag) = parse_bad_calculation_xyz(outfile_without_hash)
       if "resubmitjob:" in vtag:
          try:
             nn = evalnum(vtag.split(":")[1])+1
          except:
             nn = 10
       else:
          nn = 1
       vtag = '"resubmitjob:%d  osmiles:%s:osmiles"' % (nn,osmiles)
       if "machinejob:" in mtag:
          try:
             mmach = mtag.split(":")[1]
          except:
             mmach = ''
       else:
          mmach = ''

       if (hasxyz):
          if (nn<=9):
             if (osmiles != "nosmiles"):
                oesmiles = osmiles + " " + " ".join(esmiles.split()[1:])
             else:
                oesmiles = esmiles
             result = submit_esmiles_xyz(oesmiles,xyz,vtag,mmach)
             print "submit_esmiles_xyz result=" + result
             text2speech("Hi. The " + mformula + " molecule which did not converge has been resubmitted with an updated geometry.")
             if (nn==1):
                text2speech("This is the first time the job has been resubmitted.")
             else:
                text2speech("This job has been resubmitted %d times." % nn)
          else:
             print "job failed but not resubmitting because it has already been resubmitted 9 times."
             text2speech("job failed but not resubmitting because it has already been resubmitted 9 times.")
       else:
          msg = "Job failed but not resubmitting because xyz not found or calculation failed badly."
          print msg
          text2speech(msg)








###############################################
#                                             #
#            insert_nmr_calculation           #
#                                             #
###############################################

def insert_nmr_calculation(outfile,hup,dbfile,table,bad_table,nwpassword,nwmachine):

  tt1 = time.localtime()
  dd1 = "-%d-%d-%d-%d:%d:%d" % (tt1[0],tt1[1],tt1[2],tt1[3],tt1[4],tt1[5])

  smilefile = wrkdir + "/"+tmpsmi3
  xyzfile2  = wrkdir + "/"+tmpxyz1
  xyzfile   = wrkdir + "/"+tmpxyz2

  if (os.path.exists(outfile)):
    if (parse_jobfinished(outfile)):

      nwfilename = nwmachine + "/" + outfile[outfile.rfind('/')+1:] + dd1

      ### remove "," from filename since archive cannot handle this ###
      nwfilename = nwfilename.replace(",","-")  

      jobok    = parse_calculation_ok(outfile)
      program  = parse_program(outfile)
      energy   = parse_energy(outfile)
      nmr_blob = parse_nmrblob(outfile)
      cosmo    = parse_cosmo_smd(outfile)
      solvation_dielectric = parse_cosmo_dielectric(outfile)
      calculation_type = ''
      if (cosmo!=0.0):
         solvation_type   = "COSMO-SMD"
         solvation_energy = cosmo
         cosmo_e          = parse_cosmo_smd_e(outfile)
         if (abs(cosmo_e-energy)<1.0e-6):
            calculation_type += 'y'
            solvation_type = "COSMO-SMD-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
      else:
         cosmo           = parse_cosmo(outfile)
         cosmo_intrinsic = parse_cosmo_intrinsic(outfile)
         if (cosmo==(-987654321.0)) and cosmo_intrinsic:
            calculation_type += 'y'
            solvation_type = "COSMO-intrinsic"
            cosmo = 0.0
            solvation_energy = 0.0
         elif (cosmo!=0.0):
            solvation_energy = cosmo
            if (cosmo_intrinsic):
               calculation_type += 'y'
               solvation_type   = "COSMO intrinsic"
            else:
               solvation_type   = "COSMO"
         else:
            solvation_type   = "None"
            solvation_energy = 0.0

      if (energy!=0.0):   calculation_type += 'o'
      if (cosmo!=0.0):    calculation_type += 'c'
      if (nmr_blob!=''):  calculation_type += 'n'

      charge = parse_charge(outfile)
      mult   = parse_mult(outfile)
      theory = parse_theory(outfile)
      xc     = parse_xc(outfile)
      basis  = parse_basis(outfile)
      theory_property = parse_theory(outfile)
      xc_property     = parse_xc(outfile)
      basis_property  = parse_basis(outfile)

      try:
         msurface = gen_surfaceareas(outfile)
         ecd = 5.0*sum(msurface[0])/1000.0 + 0.86
         ehd = 25.0*sum(msurface[0])/1000.0
      except:
         msurface=[[0.0],[0.0]]
         ecd = 0.0
         ehd = 0.0

      xyzblob  = parse_xyzblob(outfile,xyzfile)
      smiles = xyz2smiles(xyzfile)
      InChI  = smiles2InChI(smiles)
      InChIKey = xyz2InChIKey(xyzfile)
      cid      = pubchem_smiles2cid(smiles)
      cas      = pubchem_smiles2cas(smiles)
      kegg     = pubchem_smiles2kegg(smiles)
      synonyms = pubchem_smiles2synonyms(smiles)

      mformula = xyz_molecular_formula(xyzfile)

      iupac  = pubchem_smiles2iupac(smiles)
      if (iupac==''): iupac = smiles

      #smiles2 = pubchem_smiles2canonicalsmiles(smiles)
      smiles2 = cannonicalsmiles(smiles)
      chemical_structure_asciiart = smiles2ascii(smiles)

      if (mult==2): iupac += " doublet radical"
      if (mult==3): iupac += " triplet radical"
      if (mult==4): iupac += " quqrtet radical"
      if (mult==5): iupac += " quintet radical"
      if (mult==6): iupac += " sextet radical"
      if (mult==7): iupac += " septet radical"
      if (mult==8): iupac += " octet radical"
      if (mult==9): iupac += " nonet radical"
      if (mult==10): iupac += " decet radical"
      if (mult>10):  iupac += " large radical"
      if (charge==-4): iupac += " tetraanion"
      if (charge==-3): iupac += " trianion"
      if (charge==-2): iupac += " dianion"
      if (charge==-1): iupac += " anion"
      if (charge==+1): iupac += " cation"
      if (charge==+2): iupac += " dication"
      if (charge==+3): iupac += " trication"
      if (charge==+4): iupac += " tetracation"

      if (smiles2!=""):
         csmiles  = smiles2
      else:
         smiles3 = cannonicalsmiles(smiles)
         csmiles = smiles3

      inserting = (energy!=0.0) and (smiles!='')
      sitkoff  = ecd
      honig    = ehd
      ASA      = sum(msurface[0])
      SAV      = sum(msurface[1])
      esmiles = csmiles 
      esmiles += " theory{%s}" % theory
      esmiles += " xc{%s}" % xc
      esmiles += " basis{%s}" % basis
      esmiles += " solvation_type{%s}" % solvation_type
      esmiles += " solvation_dielectric{%f}" % solvation_dielectric
      esmiles += " ^{%d}" % charge
      if (mult>1): esmiles += " mult{%d}" % mult
      print 
      print "iupac                              =",iupac
      print "mformula                           =",mformula
      print "InChI                              =",InChI
      print "InChIKey                           =",InChIKey
      print "cid                                =",cid
      print "cas                                =",cas
      print "kegg                               =",kegg
      print "synonyms                           =",synonyms
      print "smiles                             =",smiles
      print "cannonical smiles                  =",csmiles
      print "extended smiles                    =",esmiles
      print "program                            = ",program
      print "calculation type                   = ",calculation_type
      print "theory                             = ",theory
      print "xc                                 = ",xc
      print "basis                              = ",basis
      print "theory_property                    = ",theory_property
      print "xc_property                        = ",xc_property
      print "basis_property                     = ",basis_property
      print "charge,mult                        = ",charge,mult
      print "energy                             = ",energy
      print "solvation energy                   = ",solvation_energy,"  solvation type=",solvation_type
      print "solvation dielectric               = ",solvation_dielectric
      print "Sitkoff cavity dispersion          = ",ecd
      print "Honig cavity dispersion            = ",ehd
      print "ASA solvent accesible surface area = ",ASA
      print "SAV solvent accesible volume       = ",SAV
      print "filename                           = ",nwfilename
      print "job ok?                            = ",jobok
      print 
      print "chemical_structure_asciiart="
      print chemical_structure_asciiart
      print

      #set the mytable
      if (jobok):
         mytable = table
      else:
         mytable = bad_table

      sqlinsert = "insert into " + mytable
      sqlinsert += " (iupac,mformula,InChI,InChIKey,smiles,csmiles,esmiles,"
      sqlinsert += "synonyms,cid,cas,kegg,program,calculation_type,"
      sqlinsert += "theory,xc,basis,"
      sqlinsert += "theory_property,xc_property,basis_property,"
      sqlinsert += "charge,mult,energy,"
      sqlinsert += "solvation_type,solvation_energy,solvation_dielectric,sitkoff,honig,ASA,SAV,"
      sqlinsert += "xyz_blob,nmr_blob,filename,chemical_structure_asciiart) "
      sqlinsert += " values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"

      if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

      insertlist = []
      insertlist.append(iupac)
      insertlist.append(mformula)
      insertlist.append(InChI)
      insertlist.append(InChIKey)
      insertlist.append(smiles)
      insertlist.append(csmiles)
      insertlist.append(esmiles)
      insertlist.append(synonyms)
      insertlist.append(cid)
      insertlist.append(cas)
      insertlist.append(kegg)
      insertlist.append(program)
      insertlist.append(calculation_type)
      insertlist.append(theory)
      insertlist.append(xc)
      insertlist.append(basis)
      insertlist.append(theory_property)
      insertlist.append(xc_property)
      insertlist.append(basis_property)
      insertlist.append(charge)
      insertlist.append(mult)
      insertlist.append(energy)
      insertlist.append(solvation_type)
      insertlist.append(solvation_energy)
      insertlist.append(solvation_dielectric)
      insertlist.append(sitkoff)
      insertlist.append(honig)
      insertlist.append(ASA)
      insertlist.append(SAV)
      if (issqlite3):
         insertlist.append(sqlite3.Binary(xyzblob))
         insertlist.append(sqlite3.Binary(nmr_blob))
      else:
         insertlist.append(xyzblob)
         insertlist.append(nmr_blob)
      insertlist.append(nwfilename)
      insertlist.append(chemical_structure_asciiart)

      sqlcheck = "select count(1) from " + mytable + " where "
      sqlcheck += "iupac=? and InChI=? and smiles=? and csmiles=? and esmiles=? and program=? and "
      sqlcheck += "calculation_type=? and theory=? and xc=? and basis=? and "
      sqlcheck += "theory_property=? and xc_property=? and basis_property=? and charge=? and mult=? and "
      sqlcheck += "energy>=? and energy<=? and "
      sqlcheck += "solvation_type=? and "
      sqlcheck += "solvation_energy>=? and solvation_energy<=? and sitkoff>=? and sitkoff<=? and "
      sqlcheck += "honig>=? and honig<=? and ASA>=? and ASA<=? and SAV>=? and SAV<=?  limit 1;"

      if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')

      eps = 1.0e-6
      checklist = []
      checklist.append(iupac)
      checklist.append(InChI)
      checklist.append(smiles)
      checklist.append(csmiles)
      checklist.append(esmiles)
      checklist.append(program)
      checklist.append(calculation_type)
      checklist.append(theory)
      checklist.append(xc)
      checklist.append(basis)
      checklist.append(theory_property)
      checklist.append(xc_property)
      checklist.append(basis_property)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(energy-eps)
      checklist.append(energy+eps)

      checklist.append(solvation_type)
      checklist.append(solvation_energy-eps)
      checklist.append(solvation_energy+eps)
      checklist.append(sitkoff-eps)
      checklist.append(sitkoff+eps)
      checklist.append(honig-eps)
      checklist.append(honig+eps)
      checklist.append(ASA-eps)
      checklist.append(ASA+eps)
      checklist.append(SAV-eps)
      checklist.append(SAV+eps)


      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         dbcon = MySQLdb.connect(host,user,pss,dbfile)

      with dbcon:
         cur = dbcon.cursor()
         cur.execute(sqlcheck,checklist)
         row = cur.fetchone()
         print 'row=',row
         duplicate = (row[0]>0)
         if ((not duplicate) and (inserting)):
             print "inserting into " + mytable
             cur.execute(sqlinsert,insertlist)
      dbcon.close()


      #### insert data to sql table ###
      print "duplicate=",duplicate
      if (inserting) and (not duplicate):
          text2speech("Hi. I just added " + mformula + " to the " + mytable + " table in the " + dbfile  + " database.")

          print "Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,theory_property,xc_property,basis_property,charge,mult,energy,cosmo,ecd,ehd,ASA,SAV
          cmd0 = "scp " + outfile  + " " + nwfilename
          print cmd0
          pexpect_command(cmd0,nwpassword)
          delete_esmiles(hup,dbfile,requests_table,esmiles)
      else:
          text2speech("Hi. I just did not insert " + mformula + " to the " + mytable + " table in the " + dbfile  + " database, because it was a duplicate")
          print "Not Inserting ",iupac," ",mformula," ",smiles," ",csmiles," ",esmiles," ",program,calculation_type,theory,xc,basis,theory_property,xc_property,basis_property,charge,mult,energy,cosmo,ecd,ehd,ASA,SAV
      print
      print
      print



    else:
       print "The job= ",outfile, " is not complete."




##############################################################################
############################# main program ###################################
##############################################################################
usage = \
"""
Remote chemdb_add_nwout6 mysql  program

  Usage: chemdb_add_nwout6 -h hup_string -d database -t table -q requests_table -b bad_table -n nmr_table -c bad_nmr_table -m nwmachine -p nwpasswrd -v qtag:value nwoutfiles

  -h hup_string="machine user password" or enter sqlite3 for sqlite3 db
  -d database = "name of database"
  -t table = "name of table"
  -q requests_table = "name of requests_table"
  -b bad_table = "name of bad_table"
  -n nmr_table = "name of nmr_table"
  -c bad_nmr_table = "name of bad_nmr_table"
  -m nwmachine = "machine:directory"
  -p nwpassrd = password for nwmachine
  -x prints this message
  -v qtag:value

"""

#Database defaults
hup    = hup0
dbfile = "TNT_Project"
table  = "calculations"
requests_table  = "requests"
bad_table       = "bad_calculations"
nmr_table       = "nmr_calculations"
bad_nmr_table   = "bad_nmr_calculations"
abrev_table     = "abbreviations"


nwmachine  = archivemachine + "/%d/%d" % (random.randint(0,99),random.randint(0,99))
nwpassword = archivepassword

print
print
print
print "+---------------------------------+"
print "| chemdb_add_nwout6 mysql version |"
print "+---------------------------------+"
print
tt = time.localtime()
dd = "-%d-%d-%d-%d:%d.%d" % (tt[0],tt[1],tt[2],tt[3],tt[4],tt[5])


opts, args = getopt.getopt(sys.argv[1:], "h:d:t:q:b:n:c:m:p:x")
for o, a in opts:
  if '-h' in o:
     hup = a
  if '-d' in o:
     dbfile = a
  if '-t' in o:
     table = a
  if '-q' in o:
     requests_table = a
  if '-b' in o:
     bad_table = a
  if '-n' in o:
     nmr_table = a
  if '-c' in o:
     bad_nmr_table = a
  if '-m' in o:
     nwmachine = a
  if '-p' in o:
     nwpassword = a
  if o in ("-x","--help"):
    print usage
    exit()

if (len(args)<1):
   print usage
   exit()

nwofiles  = []
for i in range(len(args)):
   nwofiles.append(args[i])


if (hup=='sqlite3'):
   issqlite3 = True
   print "sqlite3 db file      =",dbfile
else:
   issqlite3 = False
   print "mysql db             =",dbfile

print "table name           =",table
print "requests table name  =",requests_table
print "bad table name       =",bad_table
print "nmr table name       =",nmr_table
print "bad nmr table name   =",bad_nmr_table
print "abbreviations name   =",abrev_table
print "nwout filenames      =",nwofiles


for outfile in nwofiles:
   insert_calculation(outfile,hup,dbfile,table,bad_table,abrev_table,nwpassword,nwmachine)
   #nmr_blob = parse_nmrblob(outfile)
   #if (nmr_blob!=''):
   #   insert_nmr_calculation(outfile,hup,dbfile,nmr_table,bad_nmr_table,nwpassword,nwmachine)


### delete temporary wrkdir files ###
try:
   os.unlink(wrkdir + "/" + tmpsmi1)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpsmi1

try:
   os.unlink(wrkdir + "/" + tmpsmi2)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpsmi2

try:
   os.unlink(wrkdir + "/" + tmpsmi3)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpsmi3

try:
   os.unlink(wrkdir + "/" + tmpxyz1)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpxyz1

try:
   os.unlink(wrkdir + "/" + tmpxyz2)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpxyz2

try:
   os.unlink(wrkdir + "/" + outfile99)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + outfile99

try:
   os.unlink(wrkdir + "/" + tmpxyz99)
except:
   print "chemdb_add_nwout6 Failed removing "+ wrkdir + "/" + tmpxyz99

