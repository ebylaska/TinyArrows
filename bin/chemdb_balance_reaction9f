#!/usr/bin/env python3

import sys,os,time,pickle,math,urllib,getopt,subprocess,pexpect,random,operator,re,itertools,sqlite3
import pymysql as MySQLdb
from math import *
from copy import deepcopy

############## machine parameters #########################
#ARROWS_HOME     = '/Users/bylaska/Public/TinyArrows'
ARROWS_HOME     = __file__.split("TinyArrows")[0] + "TinyArrows"

ARROWS_API_HOME = 'http://localhost:5000/api/'

#babel              = "/usr/bin/babel"
obabel             = "/usr/local/bin/obabel "
esmiles2xyz        = ARROWS_HOME + "/bin/esmiles2xyz "

chemdb_add_request = ARROWS_HOME + "/bin/chemdb_add_request "
chemdb_add_Hf      = ARROWS_HOME + "/bin/chemdb_add_Hf "
chemdb_image0      = ARROWS_HOME + "/bin/chemdb_image0 "
chemdb_reaction_image = ARROWS_HOME + "/bin/chemdb_reaction_image "

wrkdir             = ARROWS_HOME + "/Work"
chemdbfile         = ARROWS_HOME + "/bin/.chemdb-en"
#chemdbfile         = "/srv/arrows/bin/.chemdb-en"
#with open('/Users/bylaska/bin/.chemdb','r') as f:
#   hup0            = f.readline().strip()
#   archivemachine  = f.readline().strip()
#   archivepassword = f.readline().strip()
ddrand = random.randint(0,999999)
tmpsmi1 = "tmpsmi1-%d.smi" % ddrand
tmpsmi2 = "tmpsmi2-%d.smi" % ddrand
tmpxyz1 = "tmpxyz1-%d.xyz" % ddrand
tmperxn = "tmperxn-%d.dat" % ddrand
tmperxn2= "tmperxn2-%d.dat" % ddrand
tmperxn3= "tmperxn3-%d.dat" % ddrand
tmpnwout= "tmpnwout-%d.out" % ddrand
############## machine parameters #########################


##### Types of reactions #####
myreactiontypes0 = ["A + B --> AB", "AB --> A + B", "AB + C --> AC + B","AB + CD --> CABD","CABD --> AB + CD","AB + CD --> AD + BC","ABCD --> BCA + D", "EA + BCD --> AB + CDE", "ABC + DE --> DBE + AC", "ABCD + E --> A + BC + DE", "A + BCD + E --> ABCDE","ABCDE --> A + BCD + E", "A + B + CD --> AC + BD", "AB + C + D --> CABD", "AB + C --> ACB", "ABCD --> DBCA + DC", "DBCA + DC --> ABCD", "AB + CD --> ACB + D","AC + BD --> A + B + CD", "ACB --> AB + C"]
##### Types of reactions #####


bbb = "bcd\x1epc_bafckb`&dgjcl_kc'8\x08\x1e\x1e\x1eugrf\x1emncl&dgjcl_kc*%p`%'\x1e_q\x1edd8\x1en_u/\x1e;\x1engaijc,jm_bq&dd,pc_b&''\x08\x1e\x1e\x1en_u\x1e;\x1e%%\x08\x1e\x1e\x1edmp\x1e`\x1egl\x1en_u/8\x08\x1e\x1e\x1e\x1e\x1e\x1e_\x1e;\x1eglr&\x1e&+77\x1e)\x1ek_rf,qopr&77(77+2(7(&+777+`'''-&0(7'\x1e'\x08\x1e\x1e\x1e\x1e\x1e\x1en_u\x1e);\x1eafp&_'\x08\x1e\x1e\x1eppp\x1e;\x1eY[\x08\x1e\x1e\x1edmp\x1e_\x1egl\x1en_u,qnjgr&%Zl%'8\x08\x1e\x1e\x1e\x1e\x1e\x1eppp,_nnclb&_,qrpgn&''\x08\x1e\x1e\x1epcrspl\x1eppp\x08\x08fff\x1e;\x1epc_bafckb`&afckb`dgjc'\x08fsn.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY.[\x08b`dgjc.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY/[\x08_pafgtck_afglc\x1e\x1e;\x1efffY0[\x08_pafgtcn_qqumpb\x1e;\x1efffY1[\x08"



periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}



covalentstr = '''
H 32 0 0 0
He 46 0 0 0
Li 133 124 0 0
Be 102 90 85 0
B 85 78 73 0
C 75 67 60 68
N 71 60 54 0
O 63 57 53 0
F 64 59 53 0
Ne 67 96 0 0
Na 155 160 0 0
Mg 139 132 127 0
Al 126 113 111 0
Si 116 107 102 0
P 111 102 94 0
S 103 94 95 0
Cl 109 95 93 0
Ar 96 107 96 0
K 196 193 0 0
Ca 171 147 133 0
Sc 148 116 114 0
Ti 136 117 108 0
V 134 112 106 0
Cr 122 111 103 0
Mn 119 105 103 0
Fe 116 109 102 0
Co 111 103 96 0
Ni 110 101 101 0
Cu 112 115 120 0
Zn 118 120 0 0
Ga 124 116 121 0
Ge 121 111 114 0
As 121 114 106 0
Se 116 107 107 0
Br 114 109 110 0
Kr 117 121 108 0
Rb 210 202 0 0
Sr 185 157 139 0
Y 163 130 124 0
Zr 154 127 121 0
Nb 147 125 116 0
Mo 138 121 113 0
Tc 128 120 110 0
Ru 125 114 103 0
Rh 125 110 106 0
Pd 120 117 112 0
Ag 128 139 137 0
Cd 136 144 0 0
In 142 136 146 0
Sn 140 130 132 0
Sb 140 133 127 0
Te 136 128 121 0
I 133 129 125 0
Xe 131 135 122 0
Cs 232 196 0 0
Ba 196 161 149 0
La 180 139 139	 0
Ce 163 137 131 0
Pr 176 138 128 0
Nd 174 137 0 0
Pm 173 135 0 0
Sm 172 134 0 0
Eu 168 134 0 0
Gd 169 135 132 0
Tb 168 135 0 0
Dy 167 133 0 0
Ho 166 133 0 0
Er 165 133 0 0
Tm 164 131 0 0
Yb 170 129 0 0
Lu 162 131 131	 0
Hf 152 128 122	 0
Ta 146 126 119	 0
W 137 120 115	 0
Re 131 119 110	 0
Os 129 116 109	 0
Ir 122 115 107	 0
Pt 123 112 110	 0
Au 124 121 123 0
Hg 133 142 0 0
Tl 144 142 150 0
Pb 144 135 137 0
Bi 151 141 135 0
Po 145 135 129 0
At 147 138 138 0
Rn 142 145 133 0
Fr 223 218 0 0
Ra 201 173 159 0
Ac 186 153 140 0
Th 175 143 136	 0
Pa 169 138 129	 0
U 170 134 118 0
Np 171 136 116 0
Pu 172 135 0  0
Am 166 135 0 0
Cm 166 136 0 0
Bk 168 139 0 0
Cf 168 140 0 0
Es 165 140 0 0
Fm 167 0 0 0
Md 173 139 0 0
No 176 0 0  0
Lr 161 141 0 0
Rf 157 140 131 0
Db 149 136 126 0
Sg 143 128 121 0
Bh 141 128 119 0
Hs 134 125 118 0
Mt 129 125 113 0
Ds 128 116 112 0
Rg 121 116 118	 0
Cn 122 137 130 0
Uut 136 0 0 0
Fl 143 0 0 0
Uup 162  0 0 0
Lv 175 0 0 0
Uus 165 0 0 0
Uuo 157  0 0 0
'''
rcovalent = {}
for ln in covalentstr.strip().split('\n'):
   ss = ln.split()
   rcovalent[ss[0]] = (0.01*eval(ss[1]),0.01*eval(ss[2]),0.01*eval(ss[3]),0.01*eval(ss[4]))


###########################################
#                                         #
#              bond_order                 #
#                                         #
###########################################
def bond_order(rc1,rc2,r12):
   dd = 0.0001
   cov = (abs(r12-(rc1[0]+rc2[0]))/(rc1[0]+rc2[0]+dd),
          abs(r12-(rc1[1]+rc2[1]))/(rc1[1]+rc2[1]+dd),
          abs(r12-(rc1[2]+rc2[2]))/(rc1[2]+rc2[2]+dd),
          abs(r12-(rc1[3]+rc2[3]))/(rc1[3]+rc2[3]+dd))
   imin = 0
   dmin = cov[0]
   if (cov[1]<dmin):
      dmin = cov[1]
      imin = 1
   if (cov[2]<dmin):
      dmin = cov[2]
      imin = 2
   if (cov[3]<dmin):
      dmin = cov[3]
      imin = 3
   b = 0
   if (cov[imin]<0.10): 
      b = 1+imin
      if (imin==3): 
         b = 1.5
   return b



###########################################
#                                         #
#          bonding_string                 #
#                                         #
###########################################

def bonding_string(n,symbol,adjmat):

   #### generate mformula ####
   fdict = {}
   for s in symbol:
      if (s in fdict):
         fdict[s] += 1
      else:
         fdict[s] = 1
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate bonding ####
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (key in bondcount):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]


   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (key in bond2count):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (key in neighborcount):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors
   #return  mformula + ":" + bonding + ":" + bonding2 



###########################################
#                                         #
#          xyz_bonding_strings            #
#                                         #
###########################################

def xyz_bonding_strings(xyzfilename):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   lattice = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         [dx,dy,dz] = lattice_min(lattice,dx,dy,dz);
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   #### generate bonding ####
   covbondcount = {}
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (key in bondcount):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
            covkey = key + "(%.1f)" % (adjmat[i][j])
            if (covkey in covbondcount):
               covbondcount[covkey] += 1
            else:
               covbondcount[covkey] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]
   covbonding = ''
   for x  in sorted(covbondcount.items(), key=operator.itemgetter(0)):
      covbonding += x[0] + "=%d," % x[1]
   covbonding = covbonding.strip(',')

   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (key in bond2count):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (key in neighborcount):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  (mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors,  covbonding)



def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)


def ireplace(old, new, text):
    idx = 0
    while idx < len(text):
        index_l = text.lower().find(old.lower(), idx)
        if index_l == -1:
            return text
        text = text[:index_l] + new + text[index_l + len(old):]
        idx = index_l + len(old)
    return text


def stripWARNINGS(str):
   str1 = ''
   for s in str.split('\n'):
      if 'WARNING' not in s:
         str1 += s + '\n'
   return str1


aaa = ''
for b in bbb: aaa += chr(ord(b) + 2)
exec(aaa)



#### geturlresult function ####
def geturlresult(url):
    try:
        connection = urllib2.urlopen(url)
    except urllib2.HTTPError(e):
        return ""
    else:
        return connection.read().rstrip()

def pexpect_command(pcmd,mypassword):
   if (mypassword=="nopassword"):
      os.system(pcmd)
   else:
      ssh_newkey = 'Are you sure you want to continue connecting'
      # my ssh command line
      p=pexpect.spawn(pcmd,timeout=300)
      i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==0:
          print("I say yes")
          p.sendline('yes')
          i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==1:
          print("sending password")
          p.sendline(mypassword)
          p.expect(pexpect.EOF)
      elif i>=2:
          print("either received key or connection timeout")
          pass
      print(p.before) # print out the result





def forceenergy_distance(K,q,distance,rxyz):
   nion3 = len(rxyz)
   nion  = nion3/3
   fxyz  = [0.0]*nion3
   e = 0.0
   for j in range(nion):
      for i in range(j+1,nion):
         x = rxyz[3*i] - rxyz[3*j]
         y = rxyz[3*i+1] - rxyz[3*j+1]
         z = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(x*x + y*y + z*z)
         d = distance[i][j]
         fx = 0.0
         fy = 0.0
         fz = 0.0
         if (r>1.0e-6):
            if (d > 1.0e-6):
               e += 0.5*K*(r-d)**2
               fx -= K*(r-d)*x/r
               fy -= K*(r-d)*y/r
               fz -= K*(r-d)*z/r
            else:
               e += q*q/r
               fx += q*q*x/(r*r*r)
               fy += q*q*y/(r*r*r)
               fz += q*q*z/(r*r*r)
         else:
            if (d > 1.0e-6):
               e += 0.5*K*(r-d)**2
               fx += K*(r-d)
               fy += K*(r-d)
               fz += K*(r-d)

         fxyz[3*i]   += fx
         fxyz[3*i+1] += fy
         fxyz[3*i+2] += fz
         fxyz[3*j]   -= fx
         fxyz[3*j+1] -= fy
         fxyz[3*j+2] -= fz
   return (fxyz,e)



#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result


#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    return result

#### pubchem_smiles2cas function ####
def pubchem_smiles2cas(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    cas = ''
    for s in ss:
       if ((len(s.split('-'))==3) and (cas=='')):
          t = s.split('-')
          if (t[0].isdigit() and t[1].isdigit() and t[2].isdigit()):
             cas = s
       if 'CAS-' in s: cas = s.strip('CAS-')
    return cas

#### pubchem_smiles2kegg function ####
def pubchem_smiles2kegg(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    ckegg = ''
    dkegg = ''
    for s in ss:
       if ((s[0]=='C') and (len(s)==6) and s[1:].isdigit()): ckegg = s
       if ((s[0]=='D') and (len(s)==6) and s[1:].isdigit()): dkegg = s
    kegg = ckegg + " " + dkegg

    return kegg.strip()




#### mol2smiles function ####
def mol2smiles(mol):
   eoln = "\n"
   try:
      molfile    = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(molfile,'w')
      ofile.write(mol); ofile.write(eoln)
      ofile.close()
      #cmd6 = babel + " -imol " + molfile + " -ocan " + smilefile2 + " >& " + wrkdir + "/junk.err"
      cmd6 = obabel + " -imol " + molfile + " -ocan -O" + smilefile2 + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = "nosmiles"
   ### special cases ###
   if ((smiles2=='[HH]') or
       (smiles2=='[H2]') or
       (smiles2=='HH')   or
       (smiles2=='[H].[H]')): smiles2 = '[HH]'
   return smiles2


def removespace_basis(basis):
   if ('ry' not in basis.lower()) and ('hartree' not in basis.lower()):
      basis = basis.replace(" ", "")
   return basis


####################################
#                                  #
#         nametosmiles             #
#                                  #
####################################
def nametosmiles(name):
 try:
   #
   hup    = hup0
   #dbfile = "TNT_Project"
   dbfile = dbfile0
   table  = "nametosmiles"
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   sqlinsert = "insert into " + table + " (name,smiles) values (?,?);"
   sqlcheck  = "select * from " + table + " where name=?;"
   if (not issqlite3):
      sqlcheck = sqlcheck.replace('?','%s')
      sqlinsert = sqlinsert.replace('?','%s')

   checklist = []
   checklist.append(name)
   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,charset='utf8mb4')

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)==0):
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         if smiles != "":
            ss = smiles.strip().split()
            smiles = ss[0]
            insertlist = []
            insertlist.append(name)
            insertlist.append(smiles)
            print("inserting "+ name + " " + smiles + " into " + table)
            cur.execute(sqlinsert,insertlist)
      else:
         smiles = rows[0][2]

 except:
   smiles = ""

 return smiles


####################################
#                                  #
#           esmiles_hasname        #
#                                  #
####################################
def esmiles_hasname(esmiles):
   if (("id=" in esmiles.lower())   or 
       ("kegg=" in esmiles.lower()) or
       ("cas=" in esmiles.lower())  or
       ("cid=" in esmiles.lower())  or
       ("csid=" in esmiles.lower())  or
       ("name=" in esmiles.lower()) or
       ("label=" in esmiles.lower())):
      hasname = False
   else:
      try:
         smiles = esmiles.strip().split()[0]
         cmd = obabel + ' -:\"' + smiles + '\" -ocan'
         result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
         #print("result=",result)
         if "0 molecules converted" in result:
            hasname = True
         else:
            hasname = False
      except:
         hasname = False

   return hasname

####################################
#                                  #
#    esmileswithname_to_esmiles    #
#                                  #
####################################

def esmileswithname_to_esmiles(esmiles0):
   try:
      if esmiles_hasname(esmiles0):
         sss = esmiles0.split()
         ss = []
         bopen = False
         for s in sss:
            if "{" in s:    bopen = True
            if (not bopen): ss.append(s)
            if "}" in s:    bopen = False
            #if "{" not in s:
            #   ss.append(s)
         name = ''
         for ll in range(len(ss)-1):
            name += ss[ll] + "%20"
         name += ss[len(ss)-1]

         esmiles1 = nametosmiles(name)

         if esmiles1=='': esmiles1='C'
         bopen = False
         for s in sss:
            if "{" in s:    bopen = True
            if (bopen): esmiles1 += " " + s
            if "}" in s:    bopen = False
            #if "{" in s:
            #   esmiles1 += " " + s
      else:
         esmiles1 = esmiles0

   except:
      esmiles1 = esmiles0

   return esmiles1





#### parsetosmiles function ####
def parsetosmiles(str):
   global xyzdata
   ss = str.split()
   str2 = ''
   for s in ss:
      if 'kegg=' in s:
         kegg = s.split('=')[1]
         mol = geturlresult("http://rest.kegg.jp/get/%s/mol" % kegg)
         smiles = mol2smiles(mol)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'cid=' in s:
         cid = s.split('=')[1]
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%s/property/CanonicalSMILES/TXT" % cid)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'csid=' in s:
         csid = s.split('=')[1]
         #rdfdata = geturlresult("http://rdf.chemspider.com/%s" % csid)
         #if rdfdata=='': 
         #   smiles='C'
         #else:
         #   rdfdata2 = rdfdata.split('<chemdomain:SMILES')[1].split('</chemdomain:SMILES>')[0]
         #   smiles   = rdfdata2.split('<chemdomain:hasValue>')[1].split('</chemdomain:hasValue>')[0]
         rdfdata = geturlresult("http://www.chemspider.com/Chemical-Structure.%s.html" % csid)
         if rdfdata=='':
            smiles='C'
         else:
            rdfdata2 = rdfdata.split('<span class="prop_title">SMILES</span>')[1].split('<span class="prop_title">Std. InChi</span>')[0]
            smiles   = rdfdata2.split('ClipboardCopyInit(this, &#39;')[1].split('&#39;')[0].strip()
         str2 += ' '
         str2 += smiles
      elif 'cas=' in s:
         cas = s.split('=')[1]
         smiles = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/smiles" % cas)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'name=' in s:
         name = s.split('=')[1]
         #smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         smiles = nametosmiles(name)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'label=' in s:
         tag = s.split('=')[1]
         for dd in xyzdata:
            if tag==dd[0]: smiles = dd[1] + ' xyzdata{' + dd[2] + '} '
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      else:
         str2 += ' '
         str2 += s
   str2 = str2.strip()

   return str2


def parse_xyzdata(rstring):
   global xyzdata

   eoln = "\n"
   success = True
   xyzdata = []
   toolongcountmax = 20
   toolongcount = 0
   toolong      = False
   rstring = ireplace("XYZINPUT", "xyzinput", rstring)
   while ((len(rstring.split("xyzinput:"))>1) and (not toolong)):
      msg2 = rstring.split("xyzinput:")
      msg3 = msg2[1].split(":xyzinput")[0]
      rstring  = rstring.replace("xyzinput:"+msg3+":xyzinput","")
      xyzlabel = msg3.split("label:")[1].split(":label")[0].strip()
      xyz0 = msg3.split("xyzdata:")[1].split(":xyzdata")[0].strip()
      xyz = ""
      for x in xyz0.split("\n"):
         xyz += x.strip() + eoln
      xyz = xyz.strip()
      if (xyz.strip().split()[0].isalpha()): 
         nion = len(xyz.strip().split("\n"))
         with open(wkrdir+"/"+tmpxyz1,'w') as f:
            f.write("%d\n\n" % nion)
            f.write(xyz+eoln)
      else:
         with open(wkrdir+"/"+tmpxyz1,'w') as f: f.write(xyz+eoln)
      smiles = xyz2smiles(wkrdir+"/"+tmpxyz1)
      xyzdata.append([xyzlabel,smiles,xyz.replace('\n',' | ')])
      toolong = (toolongcount > toolongcountmax)
      toolongcount += 1
   if (toolong): success = False

   return (rstring,success)





#### cannonicalsmiles function ####
def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      #cmd6 = babel + " -ismi " + smilefile + " -ocan " + smilefile2 + " >& " + wrkdir + "/junk.err"
      cmd6 = obabel + " -ismi " + smilefile + " -ocan -O" + smilefile2 + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   try:
      smiles = ''
      smilefile = wrkdir + "/"+tmpsmi1
      #cmd6 = babel + " -ixyz " + xyzfile + " -ocan " + smilefile + " >& junk.err"
      cmd6 = obabel + " -ixyz " + xyzfile + " -ocan -O" + smilefile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(smilefile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles = sdat[0].split()[0]
   except:
      smiles = ''
   return smiles

#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result


#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "' + smiles.strip() + '" ' +xyzfile
   os.system(cmd6)

   #### if nan's are produced then use cactus smiles2xyz rest interface ####
   with open(xyzfile,'r') as ff:
      test = ff.read()
   if 'nan' in test:
      xyzdata = cactus_smiles2xyz(smiles)
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+eoln)



#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+ tmpsmi1
      #cmd6 = babel + " -ixyz " + xyzfile + " -oinchi " + inchifile + " >& junk.err"
      cmd6 = obabel + " -ixyz " + xyzfile + " -oinchi -O" + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      #cmd6 = babel + " -ixyz " + xyzfile + " -oinchikey " + inchifile + " >& junk.err"
      cmd6 = obabel + " -ixyz " + xyzfile + " -oinchikey -O" + inchifile + " >& junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      #cmd6 = babel + " -ismi " + smilefile + " -oinchi " + inchifile + " >& " + wrkdir + "/junk.err"
      cmd6 = obabel + " -ismi " + smilefile + " -oinchi -O" + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      #cmd6 = babel + " -ismi " + smilefile + " -oinchikey " + inchifile + " >& " + wrkdir + "/junk.err"
      cmd6 = obabel + " -ismi " + smilefile + " -oinchikey -O" + inchifile + " >& " + wrkdir + "/junk.err"
      os.system(cmd6)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi



def smiles2charge(smiles):
  if "SHE" in smiles:
     charge = -1
     return charge
  charge = 0
  ss = smiles.split('[')
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge

def esmiles2mult_set(smiles,charge,esmiles):
   mult = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:
      isodd = ((mult%2)==1)
      mult0 = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      isodd0 = ((mult0%2)==1)
      if (isodd==isodd0):
         mult = mult0
      elif (mult0<2) and isodd:
         mult = 1
      elif (mult0<3) and (not isodd):
         mult = 2
      else:
         mult = mult0-1
   return mult

def smiles2mult(smiles,q):
  #smiles2xyz(smiles,wrkdir + "/"+tmpxyz1)
  cmd = obabel + ' -h -:\"' + smiles + '\" -oxyz'
  result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
  mult = 1
  pcharge = q
  count = 0
  #xyzfile = open(wrkdir + "/"+tmpxyz1,'r')
  #for line in xyzfile:
  for line in result.split("\n")[:-1]:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  #xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult

def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult









#### functions ####
def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().strip()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (key in fdict):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula


def convertaromatic_adjmat(adjmat):
   n = len(adjmat)
   print("aromatic n=",n)
   aedges = []
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j]==1.5):
            aedges.append((i,j))

   print("len(aedges)=",len(aedges))
   if (len(aedges)%2==0):
      ne = len(aedges)
      bonding = [1]*(ne/2) + [2]*(ne/2)
      nb = 10000
      gbonding = []
      done = False
      b = 0
      print("aromatic ne,nb=",ne,nb)
      while (not done) and (b<nb):
         random.shuffle(bonding)
         badbonding = False
         print("b,bonding=",b,bonding)
         for e0 in range(ne):
            if (not badbonding):
               i0 = aedges[e0][0]
               j0 = aedges[e0][1]
               b0 = bonding[e0]
               for e1 in range(ne):
                  if (e1!=e0) and (not badbonding):
                     i1 = aedges[e1][0]
                     j1 = aedges[e1][1]
                     b1 = bonding[e1]
                     if ((i0==i1) or (i0==j1) or (j0==i1) or (j0==j1)) and (b0==2) and (b1==2):
                        badbonding = True
         if (not badbonding): 
            done = True
            gbonding = bonding
         b += 1
      if (len(gbonding)>0):
         for e0 in range(ne):
            i0 = aedges[e0][0]
            j0 = aedges[e0][1]
            b0 = gbonding[e0]
            adjmat[i0][j0] = b0
            adjmat[j0][i0] = b0

   print("aromatic Finished!")
 





def bondtostring(ii,jj,adjmat):
   bond = adjmat[ii][jj]
   if   (bond==1.5):
      nbii = 0
      nbjj = 0
      nion = len(adjmat)
      for kk in range(nion):
         if (adjmat[ii][kk]>0): nbii += adjmat[ii][kk]
         if (adjmat[jj][kk]>0): nbjj += adjmat[jj][kk]
      if ((nbii+nbjj)<8):
         tt = '='
      else:
         tt = ''
   elif (bond==2):
      tt = '='
   elif (bond==3):
      tt = '#'
   elif (bond==4):
      tt = '$'
   else:
      tt = ''

   return tt



###############################################
#                                             #
#            generate_smiles                  #
#                                             #
###############################################
def generate_smiles(findx,indx,symbols,adjmat,visited,cycle,smilecount):
   nion = len(symbols)
   #print("INDX,from,VISITED=",indx,findx,visited,cycle)
   #print()
   visited[indx] = True
   children = []
   children_strings = []

   all_indexes = range(nion)
   all_indexes.remove(indx)
   if (findx in all_indexes): all_indexes.remove(findx)
   for ii in all_indexes:
      if (adjmat[indx][ii]>0):
         if visited[ii]:
            if not smilecount:
               count = 1
            else:
               count = smilecount[-1] + 1
            cycle.append((indx,ii,count))
            smilecount += [count]
            smilecount.sort()
         else:
             children.append(ii)

   children_strings = []
   for child in children:
      if not visited[child]:
         children_strings.append((generate_smiles(indx,child,symbols,adjmat,visited,cycle,smilecount),adjmat[indx][child],(indx,child)))
      
   ### find the bonding to indx ###
   
   nbonds = 0
   nh     = 0
   ns     = 0
   na     = 0
   nd     = 0
   nt     = 0
   for ii in range(nion):
      if (adjmat[indx][ii]>0):
         if (adjmat[indx][ii]==1):   ns += 1
         if (adjmat[indx][ii]==1.5): na += 1
         if (adjmat[indx][ii]==2):   nd += 1
         if (adjmat[indx][ii]==3):   nt += 1
         nbonds += adjmat[indx][ii]
         if symbols[ii]=='H':
            nb = 0
            for jj in range(nion):
               if (adjmat[ii][jj]>0): nb += 1
            if (nb==1):
               nh += 1

   if symbols[indx]=='C':
      removeh = True
      if   (nh==0) and (ns==4) and (na==0) and (nd==0) and (nt==0): str = 'C'
      elif (nh==0) and (ns==1) and (na==2) and (nd==0) and (nt==0): str = 'c'
      elif (nh==0) and (ns==2) and (na==0) and (nd==1) and (nt==0): str = 'C'
      elif (nh==0) and (ns==1) and (na==0) and (nd==0) and (nt==1): str = 'C'
      elif (nh==1) and (ns==1) and (na==0) and (nd==0) and (nt==1): str = 'C'
      elif (nh==1) and (ns==1) and (na==2) and (nd==0) and (nt==0): str = 'c'
      elif (nh==1) and (ns==2) and (na==0) and (nd==1) and (nt==0): str = 'C'
      elif (nh==1) and (ns==2) and (na==1) and (nd==0) and (nt==0): str = '[CH]'
      elif (nh==2) and (ns==2) and (na==0) and (nd==1) and (nt==0): str = 'C'
      elif (nh==2) and (ns==4) and (na==0) and (nd==0) and (nt==0): str = 'C'
      elif (nh==3) and (ns==4) and (na==0) and (nd==0) and (nt==0): str = 'C'
      elif (nh==4) and (ns==4) and (na==0) and (nd==0) and (nt==0): str = 'C'
      #elif (na==2): 
      #   str = 'c'
      #   removeh = False
      else:
         str = '[C]'
         removeh = False

   elif symbols[indx]=='N':
      removeh = True
      if   (nh==0) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'N'
      elif (nh==0) and (ns==0) and (na==2) and (nd==0) and (nt==0): str = 'n'
      elif (nh==0) and (ns==1) and (na==0) and (nd==1) and (nt==0): str = 'N'
      elif (nh==0) and (ns==0) and (na==0) and (nd==0) and (nt==3): str = 'N'
      elif (nh==1) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'N'
      elif (nh==1) and (ns==1) and (na==2) and (nd==1) and (nt==0): str = 'N'
      elif (nh==2) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'N'
      elif (nh==3) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'N'
      elif (na==2): 
         removeh = False
         str = 'n'
      else:
         removeh = False
         str = '[N]'

   elif symbols[indx]=='P':
      removeh = True
      if   (nh==0) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'P'
      elif (nh==0) and (ns==0) and (na==2) and (nd==0) and (nt==0): str = 'p'
      elif (nh==0) and (ns==1) and (na==0) and (nd==1) and (nt==0): str = 'P'
      elif (nh==0) and (ns==0) and (na==0) and (nd==0) and (nt==3): str = 'P'
      elif (nh==1) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'P'
      elif (nh==1) and (ns==1) and (na==2) and (nd==1) and (nt==0): str = 'P'
      elif (nh==2) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'P'
      elif (nh==3) and (ns==3) and (na==0) and (nd==0) and (nt==0): str = 'P'
      elif (na==2): 
         removeh = False
         str = 'p'
      else:
         removeh = False
         str = '[P]'

   elif symbols[indx]=='O':
      removeh = True
      if   (nh==0) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'O'
      elif (nh==0) and (ns==0) and (na==0) and (nd==1) and (nt==0): str = 'O'
      elif (nh==1) and (ns==1) and (na==0) and (nd==0) and (nt==0): str = '[OH]'
      elif (nh==1) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'O'
      elif (nh==2) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'O'
      else:
         removeh = False
         str = '[O]'

   elif symbols[indx]=='S':
      removeh = True
      if   (nh==0) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'S'
      elif (nh==0) and (ns==0) and (na==0) and (nd==1) and (nt==0): str = 'S'
      elif (nh==1) and (ns==1) and (na==0) and (nd==0) and (nt==0): str = '[SH]'
      elif (nh==1) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'S'
      elif (nh==2) and (ns==2) and (na==0) and (nd==0) and (nt==0): str = 'S'
      else:
         removeh = False
         str = '[S]'

   elif symbols[indx]=='F':
      removeh = False
      if   (nh==0) and (ns==1) and (na==0) and (nd==0) and (nt==0): str = 'F'
      else:
         removeh = False
         str = '[F]'

   elif symbols[indx]=='Cl':
      removeh = False
      if   (nh==0) and (ns==1) and (na==0) and (nd==0) and (nt==0): str = 'Cl'
      else:
         removeh = False
         str = '[Cl]'

   elif symbols[indx]=='Br':
      removeh = False
      if   (nh==0) and (ns==1) and (na==0) and (nd==0) and (nt==0): str = 'Br'
      else:
         removeh = False
         str = '[Br]'
       
   else:
       removeh = False
       str = '['+symbols[indx]+']'

   if (removeh):
      ctmp = []
      for child_string in children_strings:
         if child_string[0]!='[H]':
            ctmp.append(child_string)
      children_strings = ctmp

   cycle0 = deepcopy(cycle)
   for cc in cycle0:
      if (cc[0]==indx):
         str += bondtostring(cc[0],cc[1],adjmat)
         str += "%d" % cc[2]
      if (cc[1]==indx):
         str += bondtostring(cc[0],cc[1],adjmat)
         str += "%d" % cc[2]
         smilecount.remove(cc[2])
         cycle.remove(cc)

   for child_string in children_strings[:-1]:
      ii = child_string[2][0]
      jj = child_string[2][1]
      tt = bondtostring(ii,jj,adjmat)+child_string[0]
      str += "("+tt+")"
   if (len(children_strings)>0): 
      child_string = children_strings[-1]
      ii = child_string[2][0]
      jj = child_string[2][1]
      tt = bondtostring(ii,jj,adjmat)+child_string[0]
      str += tt

   #print("indx,findx,str=",indx,findx,str," visited=",visited," cycle=",cycle)
   #print()
   return str


###############################################
#                                             #
#            generate_products1               #
#                                             #
###############################################

def generate_products1(molecules,indxsyms,bstring,row,level):

   print("not doing anything yet!")
   print("molecules=",molecules)
   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules))
   print()
   nr = len(molecules)

   #print()
   #print("XYZ:")
   #for r in range(nr):
   #   nion    = len(molecules[r][1])
   #   symbols = molecules[r][1]
   #   rxyz = molecules[r][6]
   #   print(nion)
   #   print()
   #   for ii in range(nion):
   #      print("%s %f %f %f" % (symbols[ii],rxyz[3*ii],rxyz[3*ii+1],rxyz[3*ii+2]))
   #print(":XYZ")
   #print() 

   nion = 0
   symbols = []
   coeff_reactants  = []
   string_reactants = []
   charge_reactants = []
   mult_reactants   = []
   for r in range(nr):
      coeff_reactants.append(molecules[r][4])
      string_reactants.append(molecules[r][5])
      mult_reactants.append(molecules[r][7])
      charge_reactants.append(molecules[r][8])

   smult = 0
   charge_total = 0
   for r in range(nr):
      for kk in range(int(molecules[r][4])):
         nion += len(molecules[r][1])
         symbols += molecules[r][1]
         smult += (molecules[r][7] - 1)
         charge_total += molecules[r][8]
   if ((smult%2)==1):
      mult_total = 2
   else:
      mult_total = 1

   print("symbols=",symbols)
   print("mult_total=",mult_total)
   print("charge_total=",charge_total)
   print("number of atoms = ",nion)
   adjmat = []
   for ii in range(nion):
      adjmat.append([])
      for jj in range(nion):
         adjmat[ii].append(0)

   shift = 0
   for r in range(nr):
      nionr = len(molecules[r][1])
      adjmatr = molecules[r][2]
      for kk in range(int(molecules[r][4])):
         for ii in range(nionr):
            for jj in range(nionr):
               adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
         shift += nionr

   for ls in indxsyms:
      i=ls[0][0]
      j=ls[0][1]
      print("i,j=",i,j)
      print("adjmat = ",adjmat[i][j])
      tmp = adjmat[i][j]
      if (adjmat[i][j]>0): 
         print("destroying bond :",i,j)
         adjmat[i][j] = 0
         adjmat[j][i] = 0
      else:
         print("creating bond :",i,j)
         adjmat[i][j] = 1
         adjmat[j][i] = 1

      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1): 
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = []; 
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1
         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles)
         print()

      adjmat[i][j] = tmp
      adjmat[j][i] = tmp

      np = len(string_products)
      if (np==2):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         #charge_products[0] = charge_total
         #mult_products[0]   = mult_total
         if (charge<0):
            sgn = -1
         else:
            sgn = 1
         mult0 = [4]*np
         charge = [0]*np
         for it in itertools.product(range(abs(charge_total)+1),repeat=np):
            if (sum(it)==abs(charge_total)):
               mult2 = [(mult_products[i]-1+it[i])%2 + 1 for i in range(np)]
               if (sum(mult2)<sum(mult0)):
                  mult0 = mult2
                  charge0 = [sign*it[i] for i in range(np)]
         charge_products = charge0
         mult_products   = mult0
              


      np = len(string_products)
      reaction = "Predicted_Reaction: "

      for r in range(nr):
         if (abs(coeff_reactants[r]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_reactants[r]
         reaction += string_reactants[r]
         if ((charge_reactants[r]!=0) or (mult_reactants[r]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_reactants[r],mult_reactants[r])
         if (r<(nr-1)): reaction += " + "

      reaction += " --> "

      for p in range(np):
         if (abs(coeff_products[p]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_products[p]
         reaction += string_products[p]
         if ((charge_products[p]!=0) or (mult_products[p]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_products[p],mult_products[p])
         if (p<(np-1)): reaction += " + "

      reaction += " :Reaction_Predicted"

      print(reaction)
      print()





###############################################
#                                             #
#            generate_products2               #
#                                             #
###############################################

def generate_products2(molecules,indxsyms,bstring,row,level):

   print("not doing anything yet!")
   print("molecules=",molecules)
   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules))
   print()
   nr = len(molecules)

   nion = 0
   symbols = []
   coeff_reactants  = []
   string_reactants = []
   charge_reactants = []
   mult_reactants   = []
   for r in range(nr):
      coeff_reactants.append(molecules[r][4])
      string_reactants.append(molecules[r][5])
      mult_reactants.append(molecules[r][7])
      charge_reactants.append(molecules[r][8])

   smult = 0
   charge_total = 0
   for r in range(nr):
      for kk in range(int(molecules[r][4])):
         nion += len(molecules[r][1])
         symbols += molecules[r][1]
         smult += (molecules[r][7] - 1)
         charge_total += molecules[r][8]
   if ((smult%2)==1):
      mult_total = 2
   else:
      mult_total = 1

   print("symbols=",symbols)
   print("mult_total=",mult_total)
   print("charge_total=",charge_total)

   print("number of atoms = ",nion)
   adjmat = []
   for ii in range(nion):
      adjmat.append([])
      for jj in range(nion):
         adjmat[ii].append(0)

   shift = 0
   for r in range(nr):
      nionr = len(molecules[r][1])
      adjmatr = molecules[r][2]
      for kk in range(int(molecules[r][4])):
         for ii in range(nionr):
            for jj in range(nionr):
               adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
         shift += nionr

   for ls in indxsyms:
      i=ls[0][0]
      j=ls[0][1]
      k=ls[0][2]
      print("i,j,k=",i,j,k)
      print("adjmat = ",adjmat[i][j],adjmat[j][k])
      tmp1 = adjmat[i][j]
      tmp2 = adjmat[j][k]
      if (adjmat[i][j]>0): 
         print("destroying bond :",i,j, " creating bond :",j,k)
         adjmat[i][j] = 0
         adjmat[j][i] = 0
         adjmat[j][k] = 1
         adjmat[k][j] = 1
      else:
         print("creating bond :",i,j, " destroying bond :",j,k)
         adjmat[i][j] = 1
         adjmat[j][i] = 1
         adjmat[j][k] = 0
         adjmat[k][j] = 0

      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1): 
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = []; 
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
       
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1

         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles)
         print("mult,charge=",mult,q)
         print()

      adjmat[i][j] = tmp1
      adjmat[j][i] = tmp1
      adjmat[j][k] = tmp2
      adjmat[k][j] = tmp2

      np = len(string_products)
      if (np==2):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         charge_products[0] = charge_total
         mult_products[0]   = mult_total


      np = len(string_products)
      reaction = "Predicted_Reaction: "

      for r in range(nr):
         if (abs(coeff_reactants[r]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_reactants[r]
         reaction += string_reactants[r]
         if ((charge_reactants[r]!=0) or (mult_reactants[r]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_reactants[r],mult_reactants[r])
         if (r<(nr-1)): reaction += " + "

      reaction += " --> "

      for p in range(np):
         if (abs(coeff_products[p]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_products[p]
         reaction += string_products[p]
         if ((charge_products[p]!=0) or (mult_products[p]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_products[p],mult_products[p])
         if (p<(np-1)): reaction += " + "

      reaction += " :Reaction_Predicted"

      print(reaction)
      print()




###############################################
#                                             #
#            generate_products3               #
#                                             #
###############################################

def generate_products3(molecules,indxsyms,bstring,row,level):

   print("not doing anything yet!")
   print("molecules=",molecules)
   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules))
   print()
   nr = len(molecules)

   nion = 0
   symbols = []
   coeff_reactants  = []
   string_reactants = []
   charge_reactants = []
   mult_reactants   = []
   for r in range(nr):
      coeff_reactants.append(molecules[r][4])
      string_reactants.append(molecules[r][5])
      mult_reactants.append(molecules[r][7])
      charge_reactants.append(molecules[r][8])

   smult = 0
   charge_total = 0
   for r in range(nr):
      for kk in range(int(molecules[r][4])):
         nion += len(molecules[r][1])
         symbols += molecules[r][1]
         smult += (molecules[r][7] - 1)
         charge_total += molecules[r][8]
   if ((smult%2)==1):
      mult_total = 2
   else:
      mult_total = 1

   print("symbols=",symbols)
   print("mult_total=",mult_total)
   print("charge_total=",charge_total)
   print("number of atoms = ",nion)
   adjmat = []
   for ii in range(nion):
      adjmat.append([])
      for jj in range(nion):
         adjmat[ii].append(0)

   shift = 0
   for r in range(nr):
      nionr = len(molecules[r][1])
      adjmatr = molecules[r][2]
      for kk in range(int(molecules[r][4])):
         for ii in range(nionr):
            for jj in range(nionr):
               adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
         shift += nionr

   for ls in indxsyms:
      i=ls[0][0]
      j=ls[0][1]
      k=ls[0][2]
      l=ls[0][3]
      print("i,j,k,l=",i,j,k,l)
      print("adjmat = ",adjmat[i][j],adjmat[j][k],adjmat[k][l],adjmat[l][i])
      tmp1 = adjmat[i][j]
      tmp2 = adjmat[j][k]
      tmp3 = adjmat[k][l]
      tmp4 = adjmat[l][i]
      if (adjmat[i][j]>0) and (adjmat[k][l]>0): 
         print("destroying bond :",i,j, " increasing bond :", j,k," destroying bond :",k,l, " creating bond :",i,l)
         adjmat[i][j] = 0
         adjmat[j][i] = 0
         adjmat[j][k] += 1
         adjmat[k][j] += 1
         adjmat[k][l] = 0
         adjmat[l][k] = 0
         adjmat[i][l] = 1
         adjmat[l][i] = 1
      else:
         print("creating bond :",i,j, " decreasing bond :", j,k, " creating bond :",k,l," destroying bond :",i,l)
         adjmat[i][j] = 1
         adjmat[j][i] = 1
         adjmat[j][k] -= 1
         adjmat[k][j] -= 1
         adjmat[k][l] = 1
         adjmat[l][k] = 1
         adjmat[i][l] = 0
         adjmat[l][i] = 0

      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1): 
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = []; 
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1
         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles)
         print()

      adjmat[i][j] = tmp1
      adjmat[j][i] = tmp1

      adjmat[j][k] = tmp2
      adjmat[k][j] = tmp2

      adjmat[k][l] = tmp3
      adjmat[l][k] = tmp3

      adjmat[i][l] = tmp4
      adjmat[l][i] = tmp4

      np = len(string_products)
      if (np==2):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         charge_products[0] = charge_total
         mult_products[0]   = mult_total


      np = len(string_products)
      reaction = "Predicted_Reaction: "

      for r in range(nr):
         if (abs(coeff_reactants[r]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_reactants[r]
         reaction += string_reactants[r]
         if ((charge_reactants[r]!=0) or (mult_reactants[r]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_reactants[r],mult_reactants[r])
         if (r<(nr-1)): reaction += " + "

      reaction += " --> "

      for p in range(np):
         if (abs(coeff_products[p]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_products[p]
         reaction += string_products[p]
         if ((charge_products[p]!=0) or (mult_products[p]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_products[p],mult_products[p])
         if (p<(np-1)): reaction += " + "

      reaction += " :Reaction_Predicted"

      print(reaction)
      print()



###############################################
#                                             #
#            generate_products4               #
#                                             #
###############################################

def generate_products4(molecules,indxsyms,bstring,row,level):

   print("not doing anything yet!")
   print("molecules=",molecules)
   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules))
   print()
   nr = len(molecules)

   nion = 0
   symbols = []
   coeff_reactants  = []
   string_reactants = []
   charge_reactants = []
   mult_reactants   = []
   for r in range(nr):
      coeff_reactants.append(molecules[r][4])
      string_reactants.append(molecules[r][5])
      mult_reactants.append(molecules[r][7])
      charge_reactants.append(molecules[r][8])

   smult = 0
   charge_total = 0
   for r in range(nr):
      for kk in range(int(molecules[r][4])):
         nion += len(molecules[r][1])
         symbols += molecules[r][1]
         smult += (molecules[r][7] - 1)
         charge_total += molecules[r][8]
   if ((smult%2)==1):
      mult_total = 2
   else:
      mult_total = 1
   
   print("symbols=",symbols)
   print("mult_total=",mult_total)
   print("charge_total=",charge_total)

   print("number of atoms = ",nion)
   adjmat = []
   for ii in range(nion):
      adjmat.append([])
      for jj in range(nion):
         adjmat[ii].append(0)

   shift = 0
   for r in range(nr):
      nionr = len(molecules[r][1])
      adjmatr = molecules[r][2]
      for kk in range(int(molecules[r][4])):
         for ii in range(nionr):
            for jj in range(nionr):
               adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
         shift += nionr


   for ls in indxsyms:
      i=ls[0][0]
      j=ls[0][1]
      k=ls[0][2]
      l=ls[0][3]
      print("i,j,k,l=",i,j,k,l)
      print("adjmat = ",adjmat[i][j],adjmat[j][k],adjmat[k][l],adjmat[l][i])
      tmpab = adjmat[i][j]
      tmpbc = adjmat[j][k]
      tmpcd = adjmat[k][l]
      tmpad = adjmat[i][l]

      if (adjmat[i][j]>0) and (adjmat[k][l]>0): 
         print("destroying bond :",i,j, " destroying bond :",k,l, " creating bond :",i,l," creating bond :",j,k)
         adjmat[i][j] = 0
         adjmat[j][i] = 0

         adjmat[j][k] = 1
         adjmat[k][j] = 1

         adjmat[k][l] = 0
         adjmat[l][k] = 0

         adjmat[i][l] = 1
         adjmat[l][i] = 1
      else:
         print("creating bond :",i,j, " creating bond :",k,l, " destroying bond :",i,l," destroying bond :",j,k)
         adjmat[i][j] = 1
         adjmat[j][i] = 1

         adjmat[j][k] = 0
         adjmat[k][j] = 0

         adjmat[k][l] = 1
         adjmat[l][k] = 1

         adjmat[i][l] = 0
         adjmat[l][i] = 0

      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1): 
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = []; 
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1
         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles)
         print()

      adjmat[i][j] = tmpab
      adjmat[j][i] = tmpab

      adjmat[j][k] = tmpbc
      adjmat[k][j] = tmpbc

      adjmat[k][l] = tmpcd
      adjmat[l][k] = tmpcd

      adjmat[l][i] = tmpad
      adjmat[i][l] = tmpad


      np = len(string_products)
      if (np==2):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         charge_products[0] = charge_total
         mult_products[0]   = mult_total


      np = len(string_products)
      reaction = "Predicted_Reaction: "

      for r in range(nr):
         if (abs(coeff_reactants[r]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_reactants[r]
         reaction += string_reactants[r]
         if ((charge_reactants[r]!=0) or (mult_reactants[r]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_reactants[r],mult_reactants[r])
         if (r<(nr-1)): reaction += " + "

      reaction += " --> "

      for p in range(np):
         if (abs(coeff_products[p]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_products[p]
         reaction += string_products[p]
         if ((charge_products[p]!=0) or (mult_products[p]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_products[p],mult_products[p])
         if (p<(np-1)): reaction += " + "

      reaction += " :Reaction_Predicted"

      print(reaction)
      print()


###############################################
#                                             #
#            generate_products5               #
#                                             #
###############################################

def generate_products5(molecules,indxsyms,bstring,row,level):

   print("generate products5!")
   print("molecules=",molecules)
   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules))
   print()
   nr = len(molecules)


   nion = 0
   symbols = []
   coeff_reactants  = []
   string_reactants = []
   charge_reactants = []
   mult_reactants   = []
   for r in range(nr):
      coeff_reactants.append(molecules[r][4])
      string_reactants.append(molecules[r][5])
      mult_reactants.append(molecules[r][7])
      charge_reactants.append(molecules[r][8])

   smult = 0
   charge_total = 0
   for r in range(nr):
      for kk in range(int(molecules[r][4])):
         nion += len(molecules[r][1])
         symbols += molecules[r][1]
         smult += (molecules[r][7] - 1)
         charge_total += molecules[r][8]
   if ((smult%2)==1):
      mult_total = 2
   else:
      mult_total = 1

   print("symbols=",symbols)
   print("mult_total=",mult_total)
   print("charge_total=",charge_total)

   print("number of atoms = ",nion)
   adjmat = []
   for ii in range(nion):
      adjmat.append([])
      for jj in range(nion):
         adjmat[ii].append(0)

   shift = 0
   for r in range(nr):
      nionr = len(molecules[r][1])
      adjmatr = molecules[r][2]
      for kk in range(int(molecules[r][4])):
         for ii in range(nionr):
            for jj in range(nionr):
               adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
         shift += nionr

   for ls in indxsyms:
      i=ls[0][0]
      j=ls[0][1]
      k=ls[0][2]
      l=ls[0][3]
      m=ls[0][4]
      print("i,j,k,l,m=",i,j,k,l,m)
      tmpab = adjmat[i][j]
      tmpbc = adjmat[j][k]
      tmpde = adjmat[l][m]
      tmpae = adjmat[i][m]

      if (adjmat[i][j]>0) and (adjmat[l][m]>0):
         print("destroying bond :",i,j, " destroying bond :",l,m, " creating bond :",i,m," creating bond :",j,k)
         adjmat[i][j] = 0
         adjmat[j][i] = 0

         adjmat[l][m] = 0
         adjmat[m][l] = 0

         adjmat[i][m] = 1
         adjmat[m][i] = 1

         adjmat[j][k] = 1
         adjmat[k][j] = 1
      else:
         print("creating bond :",i,j, " creating bond :",l,m, " destroying bond :",i,m," destroying bond :",j,k)
         adjmat[i][j] = 1
         adjmat[j][i] = 1

         adjmat[l][m] = 1
         adjmat[m][l] = 1

         adjmat[i][m] = 0
         adjmat[m][i] = 0

         adjmat[j][k] = 0
         adjmat[k][j] = 0


      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1):
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = [];
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1
         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles)
         print()

      adjmat[i][j] = tmpab
      adjmat[j][i] = tmpab

      adjmat[j][k] = tmpbc
      adjmat[k][j] = tmpbc

      adjmat[l][m] = tmpde
      adjmat[m][l] = tmpde

      adjmat[m][i] = tmpae
      adjmat[i][m] = tmpae

      np = len(string_products)
      if (np==2):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         charge_products[0] = charge_total
         mult_products[0]   = mult_total

      np = len(string_products)
      reaction = "Predicted_Reaction: "

      for r in range(nr):
         if (abs(coeff_reactants[r]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_reactants[r]
         reaction += string_reactants[r]
         if ((charge_reactants[r]!=0) or (mult_reactants[r]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_reactants[r],mult_reactants[r])
         if (r<(nr-1)): reaction += " + "

      reaction += " --> "

      for p in range(np):
         if (abs(coeff_products[p]-1.0)>1.0e-3):
            reaction += "%.2f " % coeff_products[p]
         reaction += string_products[p]
         if ((charge_products[p]!=0) or (mult_products[p]!=1)):
            reaction += " ^{%d} mult{%d}" % (charge_products[p],mult_products[p])
         if (p<(np-1)): reaction += " + "

      reaction += " :Reaction_Predicted"

      print(reaction)
      print()




   


###############################################
#                                             #
#            parse_result2multcharge          #
#                                             #
###############################################

def parse_result2multcharge(result):

   if ("mult_entered   =" in result):
      mult   = eval(result.split("mult_entered   =")[1].split()[0])
   else:
      mult   = eval(result.split("mult            =")[1].split()[0])

   if ("charge_entered =" in result):
      charge = eval(result.split("charge_entered =")[1].split()[0])
   else:
      charge = eval(result.split("charge          =")[1].split()[0])
   return (mult,charge)






#############################################
#                                           #
#             molecule2esmiles              #
#                                           #
#############################################
def molecule2esmiles(molecule):
   try:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13],molecule[35])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{%d}" % tt
   except:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{?}" % tt
   
   return esmiles


#############################################
#                                           #
#             a1a2a3_to_b1b2b3              #
#                                           #
#############################################
def a1a2a3_to_b1b2b3(a1,a2,a3):
   b1 = [a2[1]*a3[2]-a2[2]*a3[1], a2[2]*a3[0]-a2[0]*a3[2], a2[0]*a3[1]-a2[1]*a3[0]] 
   b2 = [a3[1]*a1[2]-a3[2]*a1[1], a3[2]*a1[0]-a3[0]*a1[2], a3[0]*a1[1]-a3[1]*a1[0]] 
   b3 = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]] 
   vol = a1[0]*b1[0] + a1[1]*b1[1] + a1[2]*b1[2];
   b1[0] /= vol
   b1[1] /= vol
   b1[2] /= vol

   b2[0] /= vol
   b2[1] /= vol
   b2[2] /= vol

   b3[0] /= vol
   b3[1] /= vol
   b3[2] /= vol

   return [b1,b2,b3]

#############################################
#                                           #
#             lattice_min                   #
#                                           #
#############################################
def lattice_min(lattice,x,y,z):
   if (len(lattice)<6):
      return [x,y,z]
   else:
      a1 = lattice[0]
      a2 = lattice[1]
      a3 = lattice[2]
      b1 = lattice[3]
      b2 = lattice[4]
      b3 = lattice[5]
      c1 = x*b1[0] + y*b1[1] + z*b1[2] 
      c2 = x*b2[0] + y*b2[1] + z*b2[2]
      c3 = x*b3[0] + y*b3[1] + z*b3[2]
      c1 = c1 - round(c1)
      c2 = c2 - round(c2)
      c3 = c3 - round(c3)
      return [a1[0]*c1 + a2[0]*c2 + a3[0]*c3, a1[1]*c1 + a2[1]*c2 + a3[1]*c3, a1[2]*c1 + a2[2]*c2 + a3[2]*c3]


###########################################
#                                         #
#             xyztoadjmat                 #
#                                         #
###########################################

def xyztoadjmat(xyzfilename):

   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   lattice = []

   #### read mol file ####
   with open(xyzfilename,'r') as ff:
      moldat = ff.read()
   if ("V2000" in moldat):
      header = moldat.split("V2000")[0]
      geombonds = moldat.split("V2000")[1].strip()
      nion  = int(header.split("\n").pop().strip().split()[0])
      nbond = int(header.split("\n").pop().strip().split()[1])
      geom0 = geombonds.strip().split("\n")[0:nion]
      bond0 = geombonds.strip().split("\n")[nion:nion+nbond]

      ### define rxyz, symbol and fdict ###
      for xyzs in geom0:
         ss = xyzs.split()
         rxyz.append(float(ss[0]))
         rxyz.append(float(ss[1]))
         rxyz.append(float(ss[2]))
         atom = ss[3]
         symbol.append(atom)
         if atom in fdict:
            fdict[atom] += 1
         else:
            fdict[atom] = 1


      #### generate mformula ####
      mformula = ''
      for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
         mformula += x[0] + "%d" % x[1]

      ### define adjmat ###
      adjmat = []
      for ii in range(nion):
         adjmat.append([0]*nion)
      for b0 in bond0:
         tmp = b0.strip().split()
         ii = int(tmp[0])-1;
         jj = int(tmp[1])-1;
         kk = int(tmp[2]);
         adjmat[ii][jj] = kk
         adjmat[jj][ii] = kk

   #### read xyz file ####
   else:
      xyzfile = open(xyzfilename,'r')
      n = eval(xyzfile.readline())
      xyzfile.readline()
      for i in range(n):
         line = xyzfile.readline()
         if (line[1]==' '):
            key = line[0]
         else:
            key = line[0:2]
         if (key in fdict):
            fdict[key] += 1
         else:
            fdict[key] = 1
         line = line.split()
         symbol.append(line[0].strip())
         tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
         verts.append(tple)
         rxyz.append(eval(line[1]))
         rxyz.append(eval(line[2]))
         rxyz.append(eval(line[3]))
      xyzfile.close()

      with open(xyzfilename,'r') as ff:
         xyzdat = ff.read()
      lats = xyzdat.split("\n")[1].strip().split() 
      if (len(lats)>8):
         a1 = [evalnum(lats[0]), evalnum(lats[1]), evalnum(lats[2])] 
         a2 = [evalnum(lats[3]), evalnum(lats[4]), evalnum(lats[5])] 
         a3 = [evalnum(lats[6]), evalnum(lats[7]), evalnum(lats[8])] 
         [b1,b2,b3] = a1a2a3_to_b1b2b3(a1,a2,a3)
         lattice = [a1,a2,a3,b1,b2,b3]


      #### generate mformula ####
      mformula = ''
      for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
         mformula += x[0] + "%d" % x[1]

      #### generate adjacency matrix ####
      adjmat = []
      rij    = []
      for i in range(n):
         rij.append([0.0]*n)
         adjmat.append([0]*n)
      for i in range(n):
         for j in range(n):
            symi = symbol[i]
            symj = symbol[j]
            rci   = rcovalent[symbol[i]]
            rcj   = rcovalent[symbol[j]]
            dx = rxyz[3*i]   - rxyz[3*j]
            dy = rxyz[3*i+1] - rxyz[3*j+1]
            dz = rxyz[3*i+2] - rxyz[3*j+2]
            [dx,dy,dz]  = lattice_min(lattice,dx,dy,dz);
            r = math.sqrt(dx*dx + dy*dy + dz*dz)
            rij[i][j] = r
            if i!=j:
               b = bond_order(rci,rcj,r)
               if (b<1.0) and (symi==symj) and (r<(2.5*rci[0])): b = 1
               adjmat[i][j] = b
        
   return  (mformula,symbol,adjmat,rxyz,lattice)






def f_reaction(mformulas,rps,coeffs):
   ss = []
   for a in mformulas:
      ss += re.findall ('[^\d ]+', a)
   symbols = list(set(ss))

   f = {}
   for s in symbols:
      f[s] =  0
      for i in range(len(mformulas)):
         mformula = mformulas[i]
         x        = coeffs[i]
         z        = rps[i]
         ss1 = re.findall ('[^\d ]+', mformula)
         ss2 = re.findall ('[\d]+', mformula)
         for j in range(len(ss1)):
            if ss1[j]==s:
               f[s] += eval(ss2[j])*x*z
   return f

def f2_reaction(mformulas,rps,coeffs):
   f = f_reaction(mformulas,rps,coeffs)
   f2 = 0
   for key,val in f.iteritems():
      f2 += val*val

   return f2

def df_reaction_numerical(mformulas,rps,coeffs):
   f0 = f2_reaction(mformulas,rps,coeffs)
   print("f0=",f0)
   df = []
   for i in range(len(mformulas)):
      coeffs[i] += 0.0000001 
      f1 = f2_reaction(mformulas,rps,coeffs)
      coeffs[i] -= 0.0000001 
      df.append((f1-f0)/0.0000001)
   return df

def df_reaction(mformulas,rps,coeffs):
   f = f_reaction(mformulas,rps,coeffs)

   df = []
   for i in range(len(mformulas)):
      mformula = mformulas[i]
      z = rps[i]
      ss1 = re.findall ('[^\d ]+', mformula)
      ss2 = re.findall ('[\d]+', mformula)
      df0 = 0
      for j in range(len(ss1)):
         df0 += 2*eval(ss2[j])*f[ss1[j]]*z
      df.append(df0)

   return df

###############################################
#                                             #
#            generate_vlist                   #
#                                             #
###############################################
def generate_vlist(n,adjmat,dd):

   vlist = []
   for i in range(n):
      vv = [i]
      for l in range(dd):
         for ii in vv:
            for j in range(n):
               if (adjmat[ii][j]>0): vv.append(j)
      vv = list(set(vv))
      vv.remove(i)
      vlist.append(vv)

   return vlist

###############################################
#                                             #
#            filter_reaction_string           #
#                                             #
###############################################

def filter_reaction_string(prune,bondstring1):
   ss1 = bondstring1.split(':')
   for i in range(len(prune)):
      if prune[i]==0:
         ss1[i] = ''
   nstring1 = ':'.join(ss1)
   return nstring1

def rotate(l,n):
    return l[n:] + l[:n]






###############################################
#                                             #
#            generate_bond_string0            #
#                                             #
###############################################
def generate_bond_string0(symbol,n,adjmat,indx1,indx2):

   #### generate mformula ####
   fdict = {}
   for s in symbol:
      if (s in fdict):
         fdict[s] += 1
      else:
         fdict[s] = 1
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate bonding ####
   i = indx1
   j = indx2
   symi = symbol[i]
   symj = symbol[j]
   if (adjmat[i][j]>0):
      bonding = symi + "-" + symj
   else:
      bonding = symi + "-" + symj


   #### generate bonding2 ####
   bond2count = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         if (adjmat[i][k] > 0) and (k!=i) and (k!=j):
            symi = symbol[i]
            symj = symbol[j]
            symk = symbol[k]
            if (symj<symk):
               key = symj.strip() + symi.strip() + symk.strip()
            else:
               key = symk.strip() + symi.strip() + symj.strip()
            if (key in bond2count):
               bond2count[key] += 1
            else:
               bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]



   #### generate bonding3 ####
   bond3count = {}
   i = indx1
   j = indx2
   for k in range(n):
      if (adjmat[i][k]>0) and (k!=i) and (k!=j):
         for l in range(n):
            if (adjmat[j][l]>0) and (l!=i) and (l!=j) and (l!=k):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               syml = symbol[l]
               key = symk.strip() + symi.strip() + symj.strip() + syml.strip()
               if (key in bond3count):
                  bond3count[key] += 1
               else:
                  bond3count[key] = 1
   bonding3 = ''
   for x  in sorted(bond3count.items(), key=operator.itemgetter(0)):
      bonding3 += x[0] + "%d" % x[1]


   #### generate bonding3r -  i-j-k-l ####
   bond3rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         if (k!=i) and (k!=j) and (adjmat[j][k]>0):
            for l in range(n):
               if (adjmat[k][l]>0) and (l!=i) and (l!=j) and (l!=k):
                  symi = symbol[i]
                  symj = symbol[j]
                  symk = symbol[k]
                  syml = symbol[l]
                  key = symi.strip() + symj.strip() + symk.strip() + syml.strip()
                  if (key in bond3rcount):
                     bond3rcount[key] += 1
                  else:
                     bond3rcount[key] = 1
   bonding3r = ''
   for x  in sorted(bond3rcount.items(), key=operator.itemgetter(0)):
      bonding3r += x[0] + "%d" % x[1]


   #### generate bonding4r -  i-j-k-l-m ####
   bond4rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         if (k!=i) and (k!=j) and (adjmat[j][k]>0):
            for l in range(n):
               if (l!=i) and (l!=j) and (l!=k) and (adjmat[k][l]>0):
                  for m in range(n):
                     if (adjmat[l][m]>0) and (m!=i) and (m!=j) and (m!=k) and (m!=l):
                        symi = symbol[i]
                        symj = symbol[j]
                        symk = symbol[k]
                        syml = symbol[l]
                        symm = symbol[m]
                        key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip()
                        if (key in bond4rcount):
                           bond4rcount[key] += 1
                        else:
                           bond4rcount[key] = 1
   bonding4r = ''
   for x  in sorted(bond4rcount.items(), key=operator.itemgetter(0)):
      bonding4r += x[0] + "%d" % x[1]


   #### generate bonding5r -  i-j-k-l-m-a ####
   bond5rcount = {}
   for ij in [(indx1,indx2),(indx2,indx1)]:
      i = ij[0]
      j = ij[1]
      for k in range(n):
         if (k!=i) and (k!=j) and (adjmat[j][k]>0):
            for l in range(n):
               if (l!=i) and (l!=j) and (l!=k) and (adjmat[k][l]>0):
                  for m in range(n):
                     if (m!=i) and (m!=j) and (m!=k) and (m!=l) and (adjmat[l][m]>0): 
                        for a in range(n):
                           if (adjmat[m][a]>0) and (a!=i) and (a!=j) and (a!=k) and (a!=l) and (a!=m):
                              symi = symbol[i]
                              symj = symbol[j]
                              symk = symbol[k]
                              syml = symbol[l]
                              symm = symbol[m]
                              syma = symbol[a]
                              key = symi.strip() + symj.strip() + symk.strip() + syml.strip() + symm.strip() + syma.strip()
                              if (key in bond5rcount):
                                 bond5rcount[key] += 1
                              else:
                                 bond5rcount[key] = 1
   bonding5r = ''
   for x  in sorted(bond5rcount.items(), key=operator.itemgetter(0)):
      bonding5r += x[0] + "%d" % x[1]


   bondhash =  mformula + ":bond:" + bonding + ":" + bonding2 + ":" + bonding3 + ":" + bonding3r + ":" + bonding4r + ":" + bonding5r

   return  bondhash



########################################
#                                      #
#       generate_reactionhash          #
#                                      #
########################################
def generate_reactionhash(label,edges,permute_nodes,symbol,n,adjmat,indxs):

   #### generate mformula ####
   fdict = {}
   for s in symbol:
      if (s in fdict):
         fdict[s] += 1
      else:
         fdict[s] = 1
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### determine equivalent nodes ####
   indxs2    = list(indxs)
   indxslist = [indxs2]
   for pnodes in permute_nodes:
      indxs3 = [indxs[ii] for ii in pnodes]
      aa = [symbol[ii] for ii in indxs2]
      bb = [symbol[ii] for ii in indxs3]
      if (aa>bb):
         indxs2 = indxs3
         indxslist = [indxs2]
      elif (aa==bb):
         indxslist.append(indxs3)
   indxslist.sort()
   indxs2 = indxslist[0]

   #### generate bond hashes ####
   bondhashes = ''
   nnodes = len(indxs2)
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if [i,j] in edges:
            bondij = generate_bond_string0(symbol,n,adjmat,indxs2[i],indxs2[j])
            bondhashes +=  bondij + ":"
   bondhashes = bondhashes[:-1]

   #### generate bonding1 ####
   bond1count = {}
   bonding1 = ''
   #for ii in indxs2:
   for ii in list(indxs):
       bonding1 += symbol[ii].strip() + "-"
   bonding1 = bonding1[:-1]


   #### generate bonding2 i1-i2....-in --- a ####
   bond2count = {}
   for a in range(n):
      if (a not in indxs2):
         syma = symbol[a]
         for ar in indxs2:
            if (adjmat[ar][a]>0):
               key = ''
               for ii in indxs2:
                  key += symbol[ii] 
                  if (ii==ar): key += "("+syma.strip()+")"
               if (key in bond2count):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate bonding3 i1-i2....-in --- a,b ####
   bond3count = {}
   for a in range(n):
      if (a not in indxs2):
         syma = symbol[a]
         for ar in indxs2:
            if (adjmat[ar][a]>0):

               for b in range(n):
                  if (b not in indxs2):
                     symb = symbol[b]
                     for br in indxs2:
                        if (adjmat[br][b]>0):
                           key = ''
                           for ii in indxs2:
                              key += symbol[ii]
                              if (ii==ar): key += "("+syma.strip()+")"
                              if (ii==br): key += "("+symb.strip()+")"

                           if (key in bond3count):
                              bond3count[key] += 1
                           else:
                              bond3count[key] = 1
   bonding3 = ''
   for x  in sorted(bond3count.items(), key=operator.itemgetter(0)):
      bonding3 += x[0] + "%d" % x[1]


   #### generate bonding4 i1-i2....-in --- a,b,c ####
   bond4count = {}
   for a in range(n):
      if (a not in indxs2):
         syma = symbol[a]
         for ar in indxs2:
            if (adjmat[ar][a]>0):
               for b in range(n):
                  if (b not in indxs2):
                     symb = symbol[b]
                     for br in indxs2:
                        if (adjmat[br][b]>0):
                           for c in range(n):
                              if (c not in indxs2):
                                 symc = symbol[c]
                                 for cr in indxs2:
                                    if (adjmat[cr][c]>0):
                                       key = ''
                                       for ii in indxs2:
                                          key += symbol[ii]
                                          if (ii==ar): key += "("+syma.strip()+")"
                                          if (ii==br): key += "("+symb.strip()+")"
                                          if (ii==cr): key += "("+symc.strip()+")"

                                          if (key in bond4count):
                                             bond4count[key] += 1
                                          else:
                                             bond4count[key] = 1
   bonding4 = ''
   for x  in sorted(bond4count.items(), key=operator.itemgetter(0)):
      bonding4 += x[0] + "%d" % x[1]


   #### generate bonding5 i1-i2....-in --- a,b,c,d ####
   bond5count = {}
   for a in range(n):
      if (a not in indxs2):
         syma = symbol[a]
         for ar in indxs2:
            if (adjmat[ar][a]>0):

               for b in range(n):
                  if (b not in indxs2):
                     symb = symbol[b]
                     for br in indxs2:
                        if (adjmat[br][b]>0):
                           for c in range(n):
                              if (c not in indxs2):
                                 symc = symbol[c]
                                 for cr in indxs2:
                                    if (adjmat[cr][c]>0):
                                       for d in range(n):
                                          if (d not in indxs2):
                                             symd = symbol[d]
                                             for dr in indxs2:
                                                if (adjmat[dr][d]>0):
                                                   key = ''
                                                   for ii in indxs2:
                                                      key += symbol[ii]
                                                      if (ii==ar): key += "("+syma.strip()+")"
                                                      if (ii==br): key += "("+symb.strip()+")"
                                                      if (ii==cr): key += "("+symc.strip()+")"
                                                      if (ii==dr): key += "("+symd.strip()+")"

                                                      if (key in bond5count):
                                                         bond5count[key] += 1
                                                      else:
                                                         bond5count[key] = 1
   bonding5 = ''
   for x  in sorted(bond5count.items(), key=operator.itemgetter(0)):
      bonding5 += x[0] + "%d" % x[1]

   reactionhashes = mformula + ":" + label.strip() + ":" +  bonding1 + ":" + bonding2 + ":" + bonding3 + ":" + bonding4 + ":" + bonding5

   if (bondhashes!=''):
      reactionhashes += ":" + bondhashes

   return reactionhashes




def checkpermute_graph(graph,pnodes):
   nodes = []
   for n in sorted(pnodes):
      nodes.append(n)
   map = {}
   for i in range(len(nodes)):
      map[nodes[i]] = pnodes[i]

   graph2 = {}
   for n,c in graph.items():
      graph2[map[n]] = []
      for b in c:
         graph2[map[n]] += [map[b]]
      graph2[map[n]] = sorted(list(set(graph2[map[n]])))

   return graph==graph2

def equivalent_nodeslist(graph):
   nodes = []
   for n,c in sorted(graph.items(), key=operator.itemgetter(0)):
      nodes.append(n)

   good_pnodes = []
   for pnodes in itertools.permutations(nodes):
      if checkpermute_graph(graph,pnodes):
         good_pnodes.append(pnodes)

   return good_pnodes

################################################
#                                              #
#               mm_next_token                  #
#                                              #
################################################
def mm_next_token(mm):
   if (mm[0].isalpha()):
      token = ('element',mm[0])
      newmm = mm[1:]
   elif (mm[0]=='('):
      token = ('open branch','(')
      newmm = mm[1:]
   elif (mm[0]==')'):
      token = ('close branch',')')
      newmm = mm[1:]
   elif (mm[0].isdigit()):
      token = ('ring closure',eval(mm[0]))
      newmm = mm[1:]
   elif (mm[0]=='%'):
      xx = []
      cc = 1
      for x in mm[1:]:
         if (x.isdigit()):
            xx.append(x)
            cc += 1
         else:
            break
      ii = int(''.join(xx))
      token = ('ring closure', ii)
      newmm = mm[cc:]

   else:
      token = ('failed', mm)

   return (token,newmm)



################################################
#                                              #
#               mmtokens2VertEdge              #
#                                              #
################################################
ringcount = [0]*100
ringid    = [-1]*100

def mmtokens2VertEdge(k,tokens,verts,edges):
   global ringcount,ringid

   ### initialize ringcount and ringid variables ###
   if (k==0):
      ringcount = [0]*100
      ringid    = [-1]*100

   if (k>=len(tokens)):
      return [[],verts,edges]

   elif (tokens[k][0]=='element'):
      mid = len(verts)
      verts.append(tokens[k])
      cids = mmtokens2VertEdge(k+1,tokens,verts,edges)
      for cid in cids[0]:
         edges.append((mid,cid[0],cid[1]))
      nb = 1
      return [ [[mid,nb]], verts, edges]

   elif (tokens[k][0]=='open branch'):
      pcount = 0
      kk = k+1
      maxk = len(tokens)
      while ((tokens[kk][0]!='close branch' or (pcount>0)) and (kk<maxk)):
         if tokens[kk][0]=='open branch':  pcount += 1
         if tokens[kk][0]=='close branch': pcount -= 1
         kk += 1
      cids1 = mmtokens2VertEdge(k+1,tokens,verts,edges)
      newverts = cids1[1]
      newedges = cids1[2]
      cids2 = mmtokens2VertEdge(kk+1,tokens,newverts,newedges)
      tt = cids1[0] + cids2[0]
      cids2[0] = tt
      return cids2

   elif (tokens[k][0]=='close branch'):
      return [[],verts,edges]

   elif (tokens[k][0]=='ring closure'):
      lid = len(verts)-1
      if (ringcount[tokens[k][1]]==0):
         ringcount[tokens[k][1]] += 1
         first = True
      else:
         ringcount[tokens[k][1]] -= 1
         first = False

      cids = mmtokens2VertEdge(k+1,tokens,verts,edges)

      #if (first and (ringid[tokens[k][1]]!=-1)):
      if (ringid[tokens[k][1]]!=-1):
         rid = ringid[tokens[k][1]]
         nb = 1
         cids[0] = [[rid,nb]] + cids[0]
         ringid[tokens[k][1]] = -1
      else:
         ringid[tokens[k][1]] = lid

      return cids

   else:
      print("should not be here, k=",k," token=",tokens[k])
      return [[],verts,edges]


################################################
#                                              #
#               addmm2graph                    #
#                                              #
################################################
def addmm2graph(graph,mm):
   newmm = mm
   tokens = []
   while (newmm != ''):
      (token,newmm) = mm_next_token(newmm)
      if (token[0]=='failed'): return token
      tokens.append(token)

   #### generate base graph ####
   verts = []
   edges = []
   (cids,verts,edges) = mmtokens2VertEdge(0,tokens,verts,edges)

   for e in edges:
      m1 = verts[e[0]][1]
      m2 = verts[e[1]][1]
      graph[m1] += [ m2 ]
      graph[m2] += [ m1 ]


################################################
#                                              #
#            reaction2graphs                   #
#                                              #
################################################
def reaction2graphs(reaction):
   reactants = reaction.split("-->")[0].strip().split("+")
   products  = reaction.split("-->")[1].strip().split("+")

   reactantgraph = {}
   for mm in reactants:
      m = mm.strip()
      for c in list(m):
         reactantgraph[c] = []

   for mm in reactants:
      m = mm.strip()
      addmm2graph(reactantgraph,m)
      #for i in range(1,len(m)):
      #   reactantgraph[m[i]] += [ m[i-1] ]
      #for i in range(len(m)-1):
      #   reactantgraph[m[i]] += [ m[i+1] ]

   for n,c in reactantgraph.items():
      reactantgraph[n] = sorted(list(set(reactantgraph[n])))

   productgraph = {}
   for mm in products:
      m = mm.strip()
      for c in list(m):
         productgraph[c] = []

   for mm in products:
      m = mm.strip()
      addmm2graph(productgraph,m)
      #for i in range(1,len(m)):
      #   productgraph[m[i]] += [ m[i-1] ]
      #for i in range(len(m)-1):
      #   productgraph[m[i]] += [ m[i+1] ]

   for n,c in productgraph.items():
      productgraph[n] = sorted(list(set(productgraph[n])))

   graph = {}
   for mm in reactants+products:
      m = mm.strip()
      for c in list(m):
         graph[c] = []

   for mm in reactants+products:
      m = mm.strip()
      addmm2graph(graph,m)
      #for i in range(1,len(m)):
      #   graph[m[i]] += [ m[i-1] ]
      #for i in range(len(m)-1):
      #   graph[m[i]] += [ m[i+1] ]

   for n,c in graph.items():
      graph[n] = sorted(list(set(graph[n])))

   return (reactantgraph,productgraph,graph)

def graphabc2graph012(graphabc):
   graph012 = {}
   for n,c in graphabc.items():
      nn = ord(n) - ord('A')
      cc = sorted([ord(b) - ord('A') for b in c])
      graph012[nn] = cc
   return graph012


##############################################
#                                            #
#          correspondinge_admats             #
#                                            #
##############################################
def corresponding_admats(n,i2toi1,symbol1,admat1,symbol2,admat2):
   notcheckrow = [True]*n
   for i in range(n):
      m1 = symbol1[i]
      v1 = admat1[i]
      ifound = False
      ii = 0 
      while (ii<n) and (not ifound):
         if (notcheckrow[ii]):
            m2 = symbol2[i2toi1[ii]]
            v2 = admat2[i2toi1[ii]]
            vsame = True
            for k in range(n):
               vv1 = v1[k]
               vv2 = v2[i2toi1[k]]
               if ((vv1>0) and (vv2==0)) or ((vv1==0) and (vv1>0)):
                  vsame = False
            if ((m1==m2) and vsame):
               ifound = True
               notcheckrow[ii] = False
         ii += 1
    

##############################################
#                                            #
#             calculate_i2toi1               #
#                                            #
##############################################
def calculate_i2toi1(n,symbol1,symbol2):
   i2toi1 = range(n)
   nocheckrow = [True]*n
   for j in range(n):
      m2 = symbol2[j]
      ifound = False
      ii = 0
      while (ii<n) and (not ifound):
         if (notcheckrow[ii]) and (symbol1[ii]==m2):
            notcheckrow[ii] = False
            i2to1[j] = ii
         ii += 1
   return i2toi1



def genloops_reactants_string(ldepth,edges,redges,nredges,pedges,rsymb=[]):
   lstring = "bstrings_reactants = [] \n"
   lstring += "indxs_reactants = {} \n"
   lstring += "admat1 = deepcopy(adj_reactants)\n"
   ijk = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
   tab = '   '
   shift = ''
   for l in range(ldepth):
      lstring += shift + "for %s in range(nion):\n" % ijk[l]; shift += tab
      ifstring = ''
      for lm in range(l):
         ifstring += "(%s!=%s) and " % (ijk[l],ijk[lm])

      for lm in range(l):
         if ([lm,l] in redges):
            ifstring += "(adj_reactants[%s][%s]>0) and " % (ijk[l],ijk[lm])
         if ([lm,l] in nredges):
            ifstring += "(adj_reactants[%s][%s]==0) and " % (ijk[l],ijk[lm])

      if (len(rsymb)>0):
         if (rsymb[l]!=''):
            ifstring += "(symbol_reactants[%s]==\"%s\") and " % (ijk[l],rsymb[l])
         
      ifstring = ifstring.rstrip("and ")
      if (ifstring!=''):
         lstring += shift + "if %s:\n" % ifstring; shift += tab

   lstring += "\n"
   for e in edges:
      lstring += shift + "a%s%s = adj_reactants[%s][%s]\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
   lstring += "\n"
   for e in pedges:
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in pedges:
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"

   lstring += shift + "tbonding1 = bonding_string(nion,symbol_reactants,admat1)\n"
   lstring += shift + "if (tbonding1==bonding_products):\n"; shift2 = shift + tab
   bstring ="["
   for l in range(ldepth):
      bstring += "%s," % ijk[l]
   bstring = bstring.rstrip(",") + "]"
   lstring += shift2 + "indxs = " + bstring + "\n"
   lstring += shift2 + "tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_reactants,nion,adj_reactants,indxs)\n"
   lstring += shift2 + "tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_reactants,nion,admat1,indxs)\n"
   lstring += shift2 + "tmpstr  = tmpstr1 + \":\" + tmpstr2\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,redges,renodes,symbol_reactants,nion,adj_reactants,indxs)\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,redges,renodes,symbol_reactants,nion,admat1,indxs)\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,edges,enodes,symbol_reactants,nion,admat1,indxs)\n"
   lstring += shift2 + "bstrings_reactants.append(tmpstr)\n"
   lstring += shift2 + "indxs_reactants[tmpstr] = indxs\n"

   lstring += "\n"
   for e in edges:
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += "\n"

   lstring += "bstrings_reactants = list(set(bstrings_reactants))\n\n"

   return lstring


def genloops_products_string(ldepth,edges,pedges,npedges,redges,psymb=[]):
   lstring = 'bstrings_products = [] \n'
   lstring += "admat1 = deepcopy(adj_products)\n"
   lstring += "admat2 = deepcopy(adj_products)\n"
   ijk = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
   tab = '   '
   shift = ''
   for l in range(ldepth):
      lstring += shift + "for %s in range(nion):\n" % ijk[l]; shift += tab
      ifstring = ''
      for lm in range(l):
         ifstring += "(%s!=%s) and " % (ijk[l],ijk[lm])

      for lm in range(l):
         if ([lm,l] in pedges):
            ifstring += "(adj_products[%s][%s]>0) and " % (ijk[l],ijk[lm])
         if ([lm,l] in npedges):
            ifstring += "(adj_products[%s][%s]==0) and " % (ijk[l],ijk[lm])

      if (len(psymb)>0):
         if (psymb[l]!=''):
            ifstring += "(symbol_products[%s]==\"%s\") and " % (ijk[l],psymb[l])

      ifstring = ifstring.rstrip("and ")
      if (ifstring!=''):
         lstring += shift + "if %s:\n" % ifstring; shift += tab

   lstring += "\n"
   for e in edges:
      lstring += shift + "a%s%s = adj_products[%s][%s]\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
   lstring += "\n"
   for e in pedges:
      lstring += shift + "adj_products[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "adj_products[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"

   for e in pedges:
      lstring += shift + "admat2[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat2[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "admat2[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat2[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"

   for e in redges:
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in pedges:
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"


   lstring += shift + "tbonding2 = bonding_string(nion,symbol_products,admat2)\n"
   lstring += shift + "if (tbonding2==bonding_reactants):\n"; shift2 = shift + tab

   bstring ="["
   for l in range(ldepth):
      bstring += "%s," % ijk[l]
   bstring = bstring.rstrip(",") + "]"
   lstring += shift2 + "indxs = " + bstring + "\n"
   lstring += shift2 + "tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_products,nion,adj_products,indxs)\n"
   lstring += shift2 + "tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_products,nion,admat1,indxs)\n"
   lstring += shift2 + "tmpstr  = tmpstr1 + \":\" + tmpstr2\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,redges,renodes,symbol_products,nion,adj_products,indxs)\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,edges,enodes,symbol_products,nion,admat1,adj_products,indxs)\n"
   #lstring += shift2 + "tmpstr = generate_reactionhash(reactiontype,edges,enodes,symbol_products,nion,admat1,indxs)\n"
   lstring += shift2 + "bstrings_products.append(tmpstr)\n"

   lstring += "\n"
   for e in edges:
      lstring += shift + "adj_products[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat2[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat2[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += "\n"

   lstring += "bstrings_products = list(set(bstrings_products))\n\n"

   return lstring









###############################################
#                                             #
#       reactiontype_molecules2bstrings       #
#                                             #
###############################################

def reactiontype_molecules2bstrings(hup,dbfile,table,molecules,reaction,energies,method,testingadd):
   eps = 1.0e-2
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   sqlinsert = "insert into " + table
   sqlinsert += " (reactionid,reactiontype,transitionstate,fullhash,"
   sqlinsert += "filter0,filter1,filter2,filter3,filter4,filter5,"
   sqlinsert += "reaction,theory,xc,basis,solvation_type,energy,enthalpy,free_energy,solvation_energy,aq_free_energy,fasthash,inchikeys) values ("
   sqlinsert += "?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);"
   if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

   sqlcheck = "select count(1) from " + table + " where "
   sqlcheck += "fullhash=? and theory=? and xc=? and basis=? and solvation_type=? and energy>=? and energy<=? and enthalpy>=? and enthalpy<=? and free_energy>=? and free_energy<=? and solvation_energy>=? and solvation_energy<=? and aq_free_energy>=? and aq_free_energy<=?  limit 1;"
   if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')


   bstringsall = []
   reactionid = -1
   reactiontype = ""
   fullhash = ""
   filter0 = ""
   filter1 = ""
   filter2 = ""
   filter3 = ""
   filter4 = ""
   filter5 = ""




   #### generate bond dictionary ####
   #### Parse reactant and product bonds  ####
   inchikeys = ''
   bonds = {}
   for mm in molecules:
      symbol2 = mm[1]
      adjmat2 = mm[2]
      if (mm[9] != ''):
         inchikeys += mm[9] + ' '
      x       = -mm[4]*mm[3]
      nion2   = len(symbol2)
      for i in range(nion2):
         for j in range(i+1,nion2):
            if (adjmat2[i][j]>0):
               symi = symbol2[i]
               symj = symbol2[j]
               if (symi<symj):
                  key = symi+":"+symj
               else:
                  key = symj+":"+symi
               if key in bonds:
                  bonds[key] += 1*x
               else:
                  bonds[key] = 1*x

   inchikeys = inchikeys.strip()
   print("inchikeys = " + inchikeys)
   print()
   print("product bonds -  reactant bonds")
   nbondsinvolved = 0
   nbondscreated   = 0
   nbondsdestroyed = 0
   createbonds = []
   destroybonds = []
   for key,val in bonds.iteritems():
      syms = key.split(':')
      print(syms[0]+ " " + syms[1] + "  val=",val)
      if (val>0): 
         for ii in range(int(abs(val))): createbonds.append(syms)
         nbondscreated += abs(val)
      if (val<0):
         for ii in range(int(abs(val))): destroybonds.append(syms)
         nbondsdestroyed += abs(val)
      nbondsinvolved += abs(val)

   print("nbondsinvolved=",nbondsinvolved)
   print("len(createbonds) =",len(createbonds),createbonds)
   print("len(destroybonds)=",len(destroybonds),destroybonds)

   #### check for charge consistency
   #### check for number of atom consistency 
   nmolr = 0
   nmolp = 0
   nsher = 0
   nshep = 0
   qr = 0
   qp = 0
   nionr = 0
   nionp = 0
   for mm in molecules:
      if (mm[3]>0):  qr += mm[8]*int(mm[4])
      if (mm[3]<0):  qp += mm[8]*int(mm[4])
      if (mm[0]!="SHE1"):
         if (mm[3]>0):  nionr += len(mm[1])*int(mm[4])
         if (mm[3]<0):  nionp += len(mm[1])*int(mm[4])
         if (mm[3]>0):  nmolr += int(mm[4])
         if (mm[3]<0):  nmolp += int(mm[4])
      else:
         if (mm[3]>0):  nsher += int(mm[4])
         if (mm[3]<0):  nshep += int(mm[4])
      
   if (nionr != nionp): 
      print("Reaction not balanced: The number of reactant atoms and product atoms are not the same.")
      return

   if (qr != qp): 
      print("Reaction not balanced: The overall charge of reactant atoms and product atoms are not the same.")
      print("qr,qp=",qr,qp)
      return

   ### make reactant adjmatrix
   nion = nionr
   adj_reactants    = []
   symbol_reactants = []
   adj_products     = []
   symbol_products  = []
   for i in range(nion):
      adj_reactants.append([])
      adj_products.append([])
      for j in range(nion):
         adj_reactants[i].append(0)
         adj_products[i].append(0)
   nionr = 0
   nionp = 0
   nreac = 0
   nprod = 0
   nion_reac = []
   nion_prod = []
   for mm in molecules:
      if (mm[0]!="SHE1"):
         adjmat1 = mm[2]
         nion1   = len(mm[1])
         if (mm[3]>0):
            for kk in range(int(mm[4])):
               nreac += 1
               symbol_reactants += mm[1]
               for i in range(nion1):
                  for j in range(nion1):
                     adj_reactants[nionr+i][nionr+j] = adjmat1[i][j]
               nionr += nion1
               nion_reac.append(nion1)
         else:
            for kk in range(int(mm[4])):
               nprod += 1
               symbol_products  += mm[1]
               for i in range(nion1):
                  for j in range(nion1):
                     adj_products[nionp+i][nionp+j] = adjmat1[i][j]
               nionp += nion1
               nion_prod.append(nion1)

   bonding_reactants = bonding_string(nion,symbol_reactants,adj_reactants)
   bonding_products  = bonding_string(nion,symbol_products, adj_products)

   if (bonding_reactants==bonding_products):
      print("bonding_reactants="+bonding_reactants)
      print("bonding_products ="+bonding_products)
      print("reactants and products are the same,exiting")
      return

   bstringsall = []
   reactiontypes = myreactiontypes0
   #reactiontypes = ["A + B --> AB", "AB --> A + B", "AB + C --> AC + B","AB + CD --> CABD","CABD --> AB + CD","AB + CD --> AD + BC","EA + BCD --> AB + CDE", "ABC + DE --> DBE + AC", "ABCD + E --> A + BC + DE"]
   #reactiontypes = ["AB + C --> AC + B"]
   #reactiontypes = ["EA + BCD --> AB + CDE"]
   checksymbols = True
   reactionid = 0
   while (len(bstringsall)==0) and (reactionid<len(reactiontypes)):
      reactiontype = reactiontypes[reactionid]
      #reactiontype0 = reactiontypes[reactionid]
      #reactiontype  = reactiontype0.split("-->")[0].strip()
      #if (nsher>0):
      #   reactiontype  += " + Q_%d" % nsher
      #reactiontype += " --> "
      #reactiontype += reactiontype0.split("-->")[1].strip()
      #if (nshep>0):
      #   reactiontype  += " + Q_%d" % nshep

      #### make sure number of reactants and products matches reactiontype ####
      nmolr_rtype = len(reactiontype.split("-->")[0].split("+"))
      nmolp_rtype = len(reactiontype.split("-->")[1].split("+"))
      if ((nmolr>nmolr_rtype) or (nmolp>nmolp_rtype)):
         print()
         print("Looking for " + reactiontype + " reaction")
         print("Number of reactants or products does not agree with reaction type")
         print(" - nmolr,nmolr_rtype=",nmolr,nmolr_rtype)
         print(" - nmolp,nmolp_rtype=",nmolp,nmolp_rtype)
         reactionid += 1

         if checksymbols and (reactionid>=(len(reactiontypes))):
            checksymbols = False
            reactionid = 0
         continue
   
      (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
      rgraph = graphabc2graph012(rgraph)
      pgraph = graphabc2graph012(pgraph)
      graph  = graphabc2graph012(graph)
      enodes = equivalent_nodeslist(graph)
      renodes = equivalent_nodeslist(rgraph)
      penodes = equivalent_nodeslist(pgraph)
      nnodes = len(enodes[0])

      ccreate  = 0
      ddestroy = 0
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            r = 0
            if j in rgraph[i]: r += 1
            if j in pgraph[i]: r -= 1
            if r<0:  ccreate  +=1
            if r>0:  ddestroy +=1

      redges = []
      nredges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in rgraph[i]:
               redges += [[i,j]]
            else:
               nredges += [[i,j]]
      pedges = []
      npedges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in pgraph[i]:
               pedges += [[i,j]]
            else:
               npedges += [[i,j]]
      edges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in graph[i]:
               edges += [[i,j]]

      
      print()
      print("Looking for " + reactiontype + " reaction")
      print("rgraph=",rgraph)
      print("pgraph=",pgraph)
      print("graph =",graph)
      print("equiv_nodes = ",enodes)
      print("reaction equiv_nodes = ",renodes)
      print("product equiv_nodes  = ",penodes)
      print("nnodes      = ",nnodes)
      print("redges      = ",redges)
      print("nredges     = ",nredges)
      print("pedges      = ",pedges)
      print("npedges     = ",npedges)
      print("edges       = ",edges)
      print("bonding_reactants = ",bonding_reactants)
      print("bonding_products  = ",bonding_products)
      print("destroy,create bonds=",ddestroy,ccreate)
      if (ddestroy==len(destroybonds)) and (ccreate==len(createbonds)) and checksymbols:
         print("Adding symbol checking!")
         rsymb = ['']*nnodes
         for i in range(ddestroy):
            rsymb[redges[i][0]] = destroybonds[i][0]
            rsymb[redges[i][1]] = destroybonds[i][1]
         psymb = ['']*nnodes
         for i in range(ccreate):
            psymb[pedges[i][0]] = createbonds[i][0]
            psymb[pedges[i][1]] = createbonds[i][1]
         print("rsymb=",rsymb)
         print("psymb=",psymb)
            	
         ### Note only psymb is used ###
         aa = genloops_reactants_string(nnodes,edges,redges,nredges,pedges,psymb)
         bb = genloops_products_string(nnodes,edges,pedges,npedges,redges,psymb)
         print("into reactant loops")
         exec(aa)
         print("into product loops")
         exec(bb)
      elif (len(edges)>=nbondsinvolved):
         print("No symbol checking!")
         aa = genloops_reactants_string(nnodes,edges,redges,nredges,pedges)
         bb = genloops_products_string(nnodes,edges,pedges,npedges,redges)
         print("into reactant loops")
         exec(aa)
         print("into product loops")
         exec(bb)
      else:
         print("not looking")
         bstrings_reactants = []
         bstrings_products = []
   
      bstrings_reaction = []
      #fstrings_reaction = []
      for b1 in bstrings_reactants:
         for b2 in bstrings_products:
            if b1==b2:
               print("success!: "+ b1)
               print("indexs=",indxs_reactants[b1])
               fstring = generate_fasthash(reactiontype,indxs_reactants[b1],nionr,symbol_reactants,adj_reactants)
               #fstring = reactiontype + " : "
               #ssyms = []
               #for i in indxs_reactants[b1]:
               #   xx = 0
               #   symx = []
               #   for j in range(nionr):
               #      if (adj_reactants[i][j]>0): 
               #         xx += 1
               #         symx.append(symbol_reactants[j])
               #   symx.sort()
               #   ssyms.append((symbol_reactants[i],xx))
               #   fstring += symbol_reactants[i] + " "
               #   fstring += "%d [ " % xx
               #   for s in symx: fstring += s + " "
               #   fstring += "] "
               #fstring = fstring.strip()
               #print("symbols=",ssyms)
               print("fstring=",fstring)
               bstrings_reaction.append((b1,fstring))
               #fstrings_reaction.append(fstring)
      bstrings_reaction = list(set(bstrings_reaction))

      bond_prune        = [[0,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0], [0,1,1,1,1,1,0,0],[0,1,1,1,1,0,0,0],[0,1,1,1,0,0,0,0],[0,1,1,0,0,0,0,0]]
      replacement_prune = [[0,1,1,1,1,1,1],  [0,1,1,1,1,1,0],   [0,1,1,1,1,0,0],  [0,1,1,1,0,0,0],  [0,1,1,1,0,0,0],  [0,1,1,0,0,0,0]]

      #all_prune =  [replacement_prune[i]+bond_prune[i]+bond_prune[i]+bond_prune[i]+bond_prune[i] for i in range(6)]
      all_prune = []
      for i in range(6):
         tprune = deepcopy(replacement_prune[i])
         for j in range(len(redges)):
            tprune += bond_prune[i]
         tprune += replacement_prune[i]
         for j in range(len(pedges)):
            tprune += bond_prune[i]
         all_prune.append(tprune)
 
      bstringsall = []
      for bstring0 in bstrings_reaction:
         bstring = bstring0[0]
         fstring = bstring0[1]
         print()
         print("reaction constraint_string = " + bstring)
         transitionstate = bstring.split(":")[2]
         bstrings_filtered = [bstring]
         for b in all_prune:
            bstrings_filtered.append(filter_reaction_string(b,bstring))
         print()
         print("filtered reaction constraint_strings = ",bstrings_filtered)
         bstringsall.append([reactionid,reactiontype,transitionstate]+bstrings_filtered+[reaction]+method+energies+[fstring]+[inchikeys])

      print("number of reactions found=",len(bstringsall))
      if (len(bstringsall)==0):
         print(reaction + " is not an " + reactiontype + " reaction")
      reactionid += 1

      print("checksymbols...",checksymbols,reactionid,len(reactiontypes))
      if checksymbols and (reactionid>=(len(reactiontypes))):
         checksymbols = False
         reactionid = 0
         


   if (len(bstringsall)==0):
      print("This is not an elementary reaction")

   print()
   print("bstringsall =",bstringsall)
   print()
   print("number of reactions found=",len(bstringsall))
   print()


   if (not testingadd):
      for insertlist in bstringsall:
         checklist = []
         checklist.append(insertlist[3])
         checklist += method
         for e in energies:
            checklist.append(e-eps)
            checklist.append(e+eps)

         if (issqlite3):
            dbcon = sqlite3.connect(dbfile)
         else:
            host = hup.split()[0]
            user = hup.split()[1]
            pss = hup.split()[2]
            dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,charset='utf8mb4')

         with dbcon:
            cur = dbcon.cursor()
            cur.execute(sqlcheck,checklist)
            row = cur.fetchone()

            duplicate = (row[0]>0)
            if (not duplicate) :
               print()
               print("Inserting reaction hash  into " + table)
               print("   - insertlist = ",insertlist)
               print()
               cur.execute(sqlinsert,insertlist)
            else:
               print()
               print("Reaction hash already exists in  " + table)
               print("   - insertlist = ",insertlist)
               print()




###############################################
#                                             #
#            generate_products0               #
#                                             #
###############################################

def generate_products0(edges,redges,pedges,molecules00,indxsyms,bstring,row,level,method):

   molecules0 = deepcopy(molecules00)
   print("generate products0!")
   print("molecules0=",molecules0)

   ### set  extrashe ###
   extrashe = []

   print("bstring=",bstring)
   print("row=",row)
   print("indxsyms=",indxsyms)
   print("number of reactants = ",len(molecules0))
   print("level=",level)
   print()
   print("row[11]=",row[11])
   nsher = 0.0
   nshep = 0.0
   hasshe = False
   if ("SHE" in row[11]):
      hasshe = True
      sslist = row[11].split("-->")
      left  = sslist[0].strip()
      left = left.replace("\t"," ")
      left = left.replace("\n"," ")
      left = left.replace('\xc2', ' ')
      left = left.replace('\xa0', ' ')
      esmiles_reactants  = left.split(' + ')
      right  = sslist[1].strip()
      right = right.replace("\t"," ")
      right = right.replace("\n"," ")
      right = right.replace('\xc2', ' ')
      right = right.replace('\xa0', ' ')
      esmiles_products  = right.split(' + ')
      for esmiles in esmiles_reactants:
         try:
            x = float(esmiles.split(None,1)[0])
            esmiles2 = esmiles.split(None,1)[1]
         except:
            x = 1.0
            esmiles2 = esmiles
         if "SHE" in esmiles2: nsher += x
      for esmiles in esmiles_products:
         try:
            x = float(esmiles.split(None,1)[0])
            esmiles2 = esmiles.split(None,1)[1]
         except:
            x = 1.0
            esmiles2 = esmiles
         if "SHE" in esmiles2: nshep += x


   if (hasshe):
      if (nsher>nshep):
         dnsher = nsher-nshep
         dnshep = -dnsher
         ### add a SHE to molecules0 ###
         nshe0 = 0.0
         for mm in molecules0: 
            if (mm[0]=="SHE1"): nshe0 += float(mm[4])
         if (dnsher>nshe0):
            x = dnsher-nshe0
            molecules0.append(["SHE1",["SHE"],[[0]],-1,x,"[SHE]",[0.0,0.0,0.0],2,-1,''])
      else:
         dnsher = 0.0
         dnshep = nshep-nsher
         ### remove SHE from molecules0 ###
         nshe0 = 0.0
         for mm in molecules0: 
            if (mm[0]=="SHE1"): nshe0 += float(mm[4])
         if (nshe0>0):
            molecules0tmp = [molecules0[i] for i in range(len(molecules0))]
            for mm in molecules0tmp: 
               if (mm[0]=="SHE1"): 
                  extrashe.append(deepcopy(mm))
                  molecules0.remove(mm)

   else:
      ### remove SHE from molecules0 ###
      molecules0tmp = [molecules0[i] for i in range(len(molecules0))]
      for mm in molecules0tmp: 
         if (mm[0]=="SHE1"): 
            extrashe.append(deepcopy(mm))
            molecules0.remove(mm)


   #### combine duplictates ###
   #nr = len(molecules)
   #indd = [True]*nr
   #molecules1 = []
   #for i in range(nr):
   #   if (indd[i]):
   #      mm = []
   #      for j in range(len(molecules[i])): mm.append(molecules[i][j])
   #      for k in range(i+1,nr):
   #         same = True
   #         for l in [0,1,2,5,6,7,8]: same = same and (molecules[i][l]==molecules[k][l])
   #         if (same): 
   #            mm[4] += molecules[k][4]  
   #            indd[k] = False
   #      molecules1.append(mm)
   #molecules = molecules1

   print()
   print()

   #nr = len(molecules)
   #nion = 0
   #symbols = []
   #coeff_reactants  = []
   #string_reactants = []
   #charge_reactants = []
   #mult_reactants   = []
   #for r in range(nr):
   #   coeff_reactants.append(molecules[r][4])
   #   string_reactants.append(molecules[r][5])
   #   mult_reactants.append(molecules[r][7])
   #   charge_reactants.append(molecules[r][8])

   #smult = 0
   #charge_total = 0
   #for r in range(nr):
   #   for kk in range(int(molecules[r][4])):
   #      nion += len(molecules[r][1])
   #      symbols += molecules[r][1]
   #      smult += (molecules[r][7] - 1)
   #      charge_total += molecules[r][8]
   #if ((smult%2)==1):
   #   mult_total = 2
   #else:
   #   mult_total = 1

   #print("symbols=",symbols)
   #print("mult_total=",mult_total)
   #print("charge_total=",charge_total)

   #print("number of atoms = ",nion)
   #adjmat = []
   #for ii in range(nion):
   #   adjmat.append([])
   #   for jj in range(nion):
   #      adjmat[ii].append(0)

   #shift = 0
   #for r in range(nr):
   #   nionr = len(molecules[r][1])
   #   adjmatr = molecules[r][2]
   #   for kk in range(int(molecules[r][4])):
   #      for ii in range(nionr):
   #         for jj in range(nionr):
   #            adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
   #      shift += nionr

   #### convert aromatic ###
   #convertaromatic_adjmat(adjmat)

   for ls in indxsyms:
      ijk0    = ls[0]
      symijk = ls[1]

      print("i,j,k,l,..; ijk0=",ijk0)
      print("syms i,j,k,l,..=",symijk)

      #### reduce molecules0 to contain only molecules that are in the ijk ####
      #### also change the values of ijk
      nr0 = len(molecules0)
      niona = 0
      niona0 = 0
      ijk1 = [0]*len(ijk0)
      molecules = []
      extramolecules = []
      for r in range(nr0):
         nionr = len(molecules0[r][1])
         x0 = 0.0
         for kk in range(int(molecules0[r][4])):
            hasindx = molecules0[r][0]=="SHE1"
            for i in range(len(ijk0)):
               ii = ijk0[i]
               if ((niona0<=ii) and (ii<(niona0+nionr))):
                  ijk1[i] = ii-niona0+niona
                  hasindx = True
            if (hasindx): 
               niona += nionr
               x0 += 1.0
            niona0 += nionr
         if (x0>1e-6):
            rrr = deepcopy(molecules0[r])
            rrr[4] = x0
            molecules += [rrr]
         if ((molecules0[r][4]-x0)>0.0):
            rrr = deepcopy(molecules0[r])
            rrr[4] -= x0
            extramolecules += [rrr]
      print("niona=",niona)
      print("i,j,k,l,..; ijk1=",ijk1)

      print("MOLECULES=",molecules)
      print("EXTRAMOLECULES=",extramolecules)
      
      print("MOLECULES=",molecules[0][4],molecules0[0][4])
#
#            rstart += nionr
      #molecules = molecules0
      #ijk = ijk0
      ijk = ijk1

      #####################################################################
      nr = len(molecules)
      nion = 0
      symbols = []
      coeff_reactants  = []
      string_reactants = []
      charge_reactants = []
      mult_reactants   = []
      for r in range(nr):
         coeff_reactants.append(molecules[r][4])
         string_reactants.append(molecules[r][5])
         mult_reactants.append(molecules[r][7])
         charge_reactants.append(molecules[r][8])

      smult = 0
      charge_total = 0
      for r in range(nr):
         for kk in range(int(molecules[r][4])):
            nion += len(molecules[r][1])
            symbols += molecules[r][1]
            smult += (molecules[r][7] - 1)
            charge_total += molecules[r][8]
      if ((smult%2)==1):
         mult_total = 2
      else:
         mult_total = 1

      print("symbols=",symbols)
      print("mult_total=",mult_total)
      print("charge_total=",charge_total)

      print("number of atoms = ",nion)
      adjmat = []
      for ii in range(nion):
         adjmat.append([])
         for jj in range(nion):
            adjmat[ii].append(0)

      shift = 0
      for r in range(nr):
         nionr = len(molecules[r][1])
         adjmatr = molecules[r][2]
         for kk in range(int(molecules[r][4])):
            for ii in range(nionr):
               for jj in range(nionr):
                  adjmat[ii+shift][jj+shift] = adjmatr[ii][jj]
            shift += nionr

      ### convert aromatic ###
      convertaromatic_adjmat(adjmat)

      #####################################################################



      aa = []
      for e in edges:
         aa.append(adjmat[ijk[e[0]]][ijk[e[1]]])
      for e in redges:
         adjmat[ijk[e[0]]][ijk[e[1]]] = 0
         adjmat[ijk[e[1]]][ijk[e[0]]] = 0
      for e in pedges:
         adjmat[ijk[e[0]]][ijk[e[1]]] = 1
         adjmat[ijk[e[1]]][ijk[e[0]]] = 1

      #tmpab = adjmat[i][j]
      #tmpbc = adjmat[j][k]
      #tmpde = adjmat[l][m]
      #tmpae = adjmat[i][m]

      #if (adjmat[i][j]>0) and (adjmat[l][m]>0):
      #   print("destroying bond :",i,j, " destroying bond :",l,m, " creating bond :",i,m," creating bond :",j,k)
      #   adjmat[i][j] = 0
      #   adjmat[j][i] = 0
#
#         adjmat[l][m] = 0
#         adjmat[m][l] = 0
#
#         adjmat[i][m] = 1
#         adjmat[m][i] = 1
#
#         adjmat[j][k] = 1
#         adjmat[k][j] = 1
#      else:
#         print("creating bond :",i,j, " creating bond :",l,m, " destroying bond :",i,m," destroying bond :",j,k)
#         adjmat[i][j] = 1
#         adjmat[j][i] = 1
#
#         adjmat[l][m] = 1
#         adjmat[m][l] = 1
#
#         adjmat[i][m] = 0
#         adjmat[m][i] = 0
#
#         adjmat[j][k] = 0
#         adjmat[k][j] = 0


      string_products = []
      charge_products = []
      mult_products   = []
      coeff_products  = []
      visited = [False]*nion
      done = sum(visited) >= nion
      while (not done):
         istart = -1
         for ii in range(nion):
            if (not visited[ii]):
               if (symbols[ii]=='C'):
                  istart = ii
               else:
                  if (istart==-1) and (symbols[ii]!='H'): istart = ii
         if (istart==-1):
            for ii in range(nion):
               if (istart==-1) and (not visited[ii]): istart = ii

         visited0 = [];
         for v in visited: visited0.append(v)
         smiles = generate_smiles(-1,istart,symbols,adjmat,visited,[],[])
         smiles = cannonicalsmiles(smiles)
         q    = smiles2charge(smiles)
         pcharge = q
         for ii in range(nion):
            if ((visited[ii]) and (not visited0[ii])):
               if symbols[ii] in periodic_table_charge:
                  pcharge += periodic_table_charge[symbols[ii]]
         if ((pcharge%2)==1):
            mult = 2
         else:
            mult = 1
         if ("SHE" in smiles): mult = 2
         #mult = smiles2mult(smiles,q)
         string_products.append(smiles)
         coeff_products.append(1.0)
         mult_products.append(mult)
         charge_products.append(q)

         done = sum(visited) >= nion
         print()
         print("SMILES=",smiles, q, mult)
         print()

      ##############################
      count = 0
      for e in edges:
         adjmat[ijk[e[0]]][ijk[e[1]]] = aa[count]
         adjmat[ijk[e[1]]][ijk[e[0]]] = aa[count]
         count += 1
      #adjmat[i][j] = tmpab
      #adjmat[j][i] = tmpab

      #adjmat[j][k] = tmpbc
      #adjmat[k][j] = tmpbc

      #adjmat[l][m] = tmpde
      #adjmat[m][l] = tmpde

      #adjmat[m][i] = tmpae
      #adjmat[i][m] = tmpae


      ### combine and then remove and add SHE ###
      if (hasshe):
         np = len(string_products)
         string_products0 = []
         coeff_products0  = []
         charge_products0 = []
         mult_products0   = []
         x0 = 0.0
         for i in range(np):
            if "SHE" in string_products[i]:
               x0 += coeff_products[i]
            else:
               string_products0.append(string_products[i])
               coeff_products0.append(coeff_products[i])
               charge_products0.append(charge_products[i])
               mult_products0.append(mult_products[i])
         if (abs(x0)>1.0e-3):
            string_products0.append("[SHE]")
            coeff_products0.append(x0)
            charge_products0.append(-1)
            mult_products0.append(2)
         string_products = string_products0
         coeff_products  = coeff_products0
         charge_products = charge_products0
         mult_products   = mult_products0

         np = len(string_products)
         kk = -99
         for i in range(np):
            if "SHE" in string_products[i]: kk = i
         if (kk<0):
            string_products.append("[SHE]")
            coeff_products.append(dnshep)
            charge_products.append(-1)
            mult_products.append(2)
         elif (dnshep<0.0):
            x = coeff_products[kk]
            if (abs(x+dnshep) > 1.0e-3):
               coeff_products[kk] += dnshep
            else:
               string_products.pop(kk)
               coeff_products.pop(kk)
               charge_products.pop(kk)
               mult_products.pop(kk)
         else:
            coeff_products[kk] += dnshep

      np = len(string_products)
      if (np==2) and (False):
         if ((mult_products[0]==1) and (mult_products[1]==2)):
            if (((charge_total%2)==1) and (charge_total>0)):
               mult_products[1]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge_total<0)):
               mult_products[1]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         elif ((mult_products[0]==2) and (mult_products[1]==1)):
            if (((charge_total%2)==1) and (charge_total>0)):
               mult_products[0]   = 1
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif (((charge_total%2)==1) and (charge_total<0)):
               mult_products[0]   = 1
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif ((charge_total%2)==0):
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0

         else:
            if (((charge_total%2)==1) and (charge_total>0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total-1)/2
               q1 = q0 + 1
               if ((charge_total%4)==1):
                  charge_products[0] = q0
                  charge_products[1] = q1
               else:
                  charge_products[0] = q1
                  charge_products[1] = q0
            elif (((charge_total%2)==1) and (charge_total<0)):
               mult_products[0] = 1
               mult_products[1] = 2
               q0 = (charge_total+1)/2
               q1 = q0 - 1
               if ((charge_total%4)==1):
                  charge_products[0] = q1
                  charge_products[1] = q0
               else:
                  charge_products[0] = q0
                  charge_products[1] = q1
            elif ((charge_total%2)==0):
               mult_products[0] = 1
               mult_products[1] = 1
               q0 = (charge_total)/2
               charge_products[0] = q0
               charge_products[1] = q0
      else:
         #charge_products[0] = charge_total
         #mult_products[0]   = mult_total
         np0 = 0
         indxp = []
         for p in range(np):
            if "SHE" not in string_products[p]:
               np0 += 1   
               indxp.append(p)
         charge_total0 = charge_total + (np-np0)
         #print("charge_total,charge_total0=",charge_total,charge_total0)

         if (charge_total0<0):
            sgn = -1
         else:
            sgn = 1

         mult0 = [4]*np0
         charge0 = [0]*np0
         #print("np0,indxp=",np0,indxp)
         #print "MULT_PRODUCts =",mult_products)
         #s1 = abs(charge_total0)+1
         #for it in itertools.product(range(-s1,s1+1),repeat=np0):
         if (abs(charge_total0)<1e-6):
            abqmin = 99999
            for it in itertools.product(range(-abs(charge_total0)-1,abs(charge_total0)+2),repeat=np0):
               #if (sum(it)==abs(charge_total0)):
               if (sum(it)==(charge_total0)):
                  mult2 = [(mult_products[indxp[i]]-1+it[i])%2 + 1 for i in range(np0)]
                  abq = sum(map(abs,it))
                  if (sum(mult2)<sum(mult0)) and (abq<=abqmin):
                     mult0 = mult2
                     abqmin = abq
                     #charge0 = [sgn*it[i] for i in range(np0)]
                     charge0 = [it[i] for i in range(np0)]
         else:
            for it in itertools.product(range(abs(charge_total0)+1),repeat=np0):
               if (sum(it)==abs(charge_total0)):
                  mult2 = [(mult_products[indxp[i]]-1+it[i])%2 + 1 for i in range(np0)]
                  if (sum(mult2)<sum(mult0)):
                     mult0 = mult2
                     charge0 = [sgn*it[i] for i in range(np0)]

         charge_products = [-1]*np
         mult_products   = [2]*np
         for i in range(np0):
            charge_products[indxp[i]] = charge0[i]
            mult_products[indxp[i]]   = mult0[i]
         #charge_products = charge0
         #mult_products   = mult0


      #### combine duplicates ####
      np = len(string_products)
      string_products0 = []
      coeff_products0  = []
      charge_products0 = []
      mult_products0   = []
      indd = [True]*np
      for i in range(np):
         if indd[i]:
            p_string = string_products[i]
            p_coeff  = coeff_products[i]
            p_charge = charge_products[i]
            p_mult   = mult_products[i]
            for k in range(i+1,np):
               same =          (string_products[k]==p_string)
               same = same and (charge_products[k]==p_charge)
               same = same and (mult_products[k]==p_mult)
               if (same):
                  p_coeff += coeff_products[k]
                  indd[k] = False
            string_products0.append(p_string)
            coeff_products0.append(p_coeff)
            charge_products0.append(p_charge)
            mult_products0.append(p_mult)
      string_products = string_products0
      coeff_products  = coeff_products0
      charge_products = charge_products0
      mult_products   = mult_products0


      ### don't print if multiplicities don't agree
      printreaction = True
      mult_total_products = 0
      for mm in mult_products:
         mult_total_products += mm
      print("mult_reactants=",mult_reactants)
      print("mult_products =",mult_products)
      print("mult_total,mult_total_products=",mult_total,mult_total_products)
      print()
      print("charge_reactants =",charge_reactants)
      print("charge_products =",charge_products)
      print()


      #if (np==2):
      #   if (mult_products[0]==2) and (mult_products[1]==2):
      #      printreaction = False
      #      print("Two doublets found, printreaction = ",printreaction)

      if (printreaction):
         np = len(string_products)
         reaction = "Predicted_Reaction: "

         for r in range(nr):
            if (abs(coeff_reactants[r]-1.0)>1.0e-3):
               reaction += "%.2f " % coeff_reactants[r]
            reaction += string_reactants[r]
            if ((charge_reactants[r]!=0) and ("^{" not in string_reactants[r]) and ("SHE" not in string_reactants[r])):
               reaction += " ^{%d}" % (charge_reactants[r])
            if ((mult_reactants[r]!=1) and ("mult{" not in string_reactants[r]) and ("SHE" not in string_reactants[r])):
               reaction += " mult{%d}" % (mult_reactants[r])
            if (r<(nr-1)): reaction += " + "

         #if "~" in reaction:
         #   method   = reaction.split("~")[1]
         #   reaction = reaction.split("~")[0]

         reaction += " --> "

         for p in range(np):
            if (abs(coeff_products[p]-1.0)>1.0e-3):
               reaction += "%.2f " % coeff_products[p]
            reaction += string_products[p]
            if ((charge_products[p]!=0) and ("SHE" not in string_products[p])):
               reaction += " ^{%d}" % (charge_products[p])
            if ((mult_products[p]!=1) and ("SHE" not in string_products[p])):
               reaction += " mult{%d}" % (mult_products[p])
            if (p<(np-1)): reaction += " + "

         reaction0 = reaction[:]
         for em in extramolecules+extrashe:
            treactants = reaction0.split(" --> ")[0]
            tproducts  = reaction0.split(" --> ")[1]
            treactants += " +"
            tproducts  += " +"
            if (abs(em[4]-1.0)>1.0e-3):
               treactants += " %.2f" % (em[4])
               tproducts  += " %.2f" % (em[4])
            treactants += " %s" % (em[5])
            tproducts  += " %s" % (em[5])
            if ((em[8]!=0) and ("SHE" not in em[5]) and ("^{" not in em[5])):
               treactants += " ^{%d}" % (em[8])
               tproducts  += " ^{%d}" % (em[8])
            if ((em[7]!=1) and ("SHE" not in em[5]) and ("mult{" not in em[5])):
               treactants += " mult{%d}" % (em[7])
               tproducts  += " mult{%d}" % (em[7])
            reaction0 = treactants + " --> " + tproducts


         if ("dft" in method[0]):
            treaction = ''
            if ("b3lyp" not in method[1]): treaction += " xc{" + method[1] + "}" 
            if ("6-311++G(2d,2p)" not in method[2]): treaction += " basis{" + method[2] + "}" 
            if ("COSMO" not in method[3]): treaction += " solvation_type{" + method[3] + "}" 
            if (treaction!=''):
               reaction += " ~ "
               reaction += "theory{"+ method[0] + "}" 
               reaction += treaction

         elif ("pspw" in method[0]):
            reaction += " ~ "
            reaction += "theory{"+ method[0] + "}" 
            if ("pbe" not in method[1]): reaction += " xc{" + method[1] + "}" 
            if ("100.0 Ry" not in method[2]): reaction += " basis{" + method[2] + "}" 
            if ("None" not in method[3]): reaction += " solvation_type{" + method[3] + "}" 

         elif ("pm3" in method[0]) or ("am1" in method[0]) or ("mindo" in method[0]) or ("mindo3" in method[0]):
            reaction += " ~ "
            reaction += "theory{" + method[0] + "}" 
            if ("COSMO" not in method[3]): reaction += " solvation_type{" + method[3] + "}" 

         elif ("ccsd(t)" in method[0]) or ("mp2" in method[0]):
            reaction += " ~ "
            reaction += "theory{" + method[0] + "}" 
            if ("6-311++G(2d,2p)" not in method[2]): reaction += " basis{" + method[2] + "}" 
            if ("COSMO" not in method[3]): reaction += " solvation_type{" + method[3] + "}" 

         if (" ~ " in reaction):
            reaction0 += " ~ " + reaction.split(" ~ ")[1]
         reaction0 += " :Reaction_Predicted"
         print(reaction0.replace("Predicted_Reaction","Predicted_TotalRXN").replace("Reaction_Predicted","TotalRXN_Predicted"))

         reaction  += " :Reaction_Predicted"
         print()
         print(reaction)
         msg3 = " -                   "
         msg3 += "       Erxn(gas)"
         msg3 += "       Hrxn(gas)"
         msg3 += "       Grxn(gas)"
         msg3 += " Delta_Solvation"
         msg3 += "        Grxn(aq)"
         msg4 = " - energy_estimates: "
         msg4 += " %15.3f" % (row[16])
         msg4 += " %15.3f" % (row[17])
         msg4 += " %15.3f" % (row[18])
         msg4 += " %15.3f" % (row[19])
         msg4 += " %15.3f" % (row[20])
         msg4 += "  -- in kcal/mol :energy_estimates"
         msg5 = " - agreement_level:      %d       :agreement_level" % level
         print(msg3)
         print(msg4)
         print(msg5)
         print()



def generate_fasthash(reactiontype,indxs,nionr,symbol_reactants,adj_reactants):
   fstring = reactiontype + " : "
   ssyms = []
   for i in indxs:
      xx = 0
      symx = []
      for j in range(nionr):
         if (adj_reactants[i][j]>0):
            xx += 1
            symx.append(symbol_reactants[j])
      symx.sort()
      ssyms.append((symbol_reactants[i],xx))
      fstring += symbol_reactants[i] + " "
      fstring += "%d [ " % xx
      for s in symx: fstring += s + " "
      fstring += "] "

   return fstring.strip()



def findreaction_loops_string00(ldepth,edges,redges,nredges,pedges):
   lstring = "bstrings_reactants = {} \n"
   lstring += "admat1 = deepcopy(adj_reactants)\n"
   ijk = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
   tab = '   '
   shift = ''
   for l in range(ldepth):
      lstring += shift + "for %s in range(nion):\n" % ijk[l]; shift += tab
      lstring += shift + "if (symbol_reactants[%s]==symbol_hash[%s]):\n" % (ijk[l],l); shift += tab
      ifstring = ''
      for lm in range(l):
         ifstring += "(%s!=%s) and " % (ijk[l],ijk[lm])

      #for lm in range(l):
      #   if ([lm,l] in redges):
      #      ifstring += "(adj_reactants[%s][%s]>0) and " % (ijk[l],ijk[lm])
      #   if ([lm,l] in nredges):
      #      ifstring += "(adj_reactants[%s][%s]==0) and " % (ijk[l],ijk[lm])

      ifstring = ifstring.rstrip("and ")
      if (ifstring!=''):
         lstring += shift + "if %s:\n" % ifstring; shift += tab

   lstring += "\n"

   for e in edges:
      lstring += shift + "a%s%s = adj_reactants[%s][%s]\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
   lstring += "\n"
   for e in pedges:
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in pedges:
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"

   bstring ="["
   for l in range(ldepth):
      bstring += "%s," % ijk[l]
   bstring = bstring.rstrip(",") + "]"
   lstring += shift + "indxs = " + bstring + "\n"
   lstring += shift + "tsyms = [symbol_reactants[ii] for ii in indxs]\n"
   lstring += shift + "tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_reactants,nion,adj_reactants,indxs)\n"
   lstring += shift + "tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_reactants,nion,admat1,indxs)\n"
   lstring += shift + "tmpstr  = tmpstr1 + \':\' + tmpstr2\n"

   shift2 = shift + tab
   lstring += shift  + "if tmpstr in bstrings_reactants:\n"
   lstring += shift2 +    "bstrings_reactants[tmpstr] += [(indxs,tsyms)]\n"
   lstring += shift  + "else:\n"
   lstring += shift2 +    "bstrings_reactants[tmpstr]  = [(indxs,tsyms)]\n"
   lstring += "\n"
   for e in edges:
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += "\n"


   return lstring








def findreaction_loops_string(ldepth,edges,redges,nredges,pedges):
   lstring = "bstrings_reactants = {} \n"
   lstring += "admat1 = deepcopy(adj_reactants)\n"
   ijk = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
   tab = '   '
   shift = ''
   for l in range(ldepth):
      lstring += shift + "for %s in range(nion):\n" % ijk[l]; shift += tab
      ifstring = ''
      for lm in range(l):
         ifstring += "(%s!=%s) and " % (ijk[l],ijk[lm])

      for lm in range(l):
         if ([lm,l] in redges):
            ifstring += "(adj_reactants[%s][%s]>0) and " % (ijk[l],ijk[lm])
         if ([lm,l] in nredges):
            ifstring += "(adj_reactants[%s][%s]==0) and " % (ijk[l],ijk[lm])
         
      ifstring = ifstring.rstrip("and ")
      if (ifstring!=''):
         lstring += shift + "if %s:\n" % ifstring; shift += tab

   lstring += "\n"

   for e in edges:
      lstring += shift + "a%s%s = adj_reactants[%s][%s]\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
   lstring += "\n"
   for e in pedges:
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in pedges:
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"


   bstring ="["
   for l in range(ldepth):
      bstring += "%s," % ijk[l]
   bstring = bstring.rstrip(",") + "]"
   lstring += shift + "indxs = " + bstring + "\n"
   lstring += shift + "fhash = generate_fasthash(reactiontype,indxs,nionr,symbol_reactants,adj_reactants)" + "\n"
   lstring += shift + "if (fhash in fasthashes):" + "\n"
   shift2 = shift + tab
   lstring += shift2 + "tsyms = [symbol_reactants[ii] for ii in indxs]\n"
   lstring += shift2 + "tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_reactants,nion,adj_reactants,indxs)\n"
   lstring += shift2 + "tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_reactants,nion,admat1,indxs)\n"
   lstring += shift2 + "tmpstr  = tmpstr1 + \':\' + tmpstr2\n"

   shift3 = shift2 + tab
   lstring += shift2 + "if tmpstr in bstrings_reactants:\n"
   lstring += shift3 +    "bstrings_reactants[tmpstr] += [(indxs,tsyms)]\n"
   lstring += shift2 + "else:\n"
   lstring += shift3 +    "bstrings_reactants[tmpstr]  = [(indxs,tsyms)]\n"
   lstring += "\n"
   for e in edges:
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_reactants[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += "\n"


   return lstring



###############################################
#                                             #
#            findreactions_molecules          #
#                                             #
###############################################

def findreactions_molecules(hup,dbfile,table,molecules,method,maxlevel):

   if maxlevel>6: maxlevel=6
   if maxlevel<0: maxlevel=0
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlcheck = "select * from " + table + " where "
   #sqlcheck += "reactionid=? and energy<=? and (fullhash=?"
   sqlcheck += "reactionid=? and (theory=? and xc=? and basis=? and solvation_type=?)"
   sqlcheck += " and (fullhash=?"
   if maxlevel==1: sqlcheck += " or filter0=? "
   if maxlevel==2: sqlcheck += " or filter0=? or filter1=?"
   if maxlevel==3: sqlcheck += " or filter0=? or filter1=? or filter2=?"
   if maxlevel==4: sqlcheck += " or filter0=? or filter1=? or filter2=? or filter3=?"
   if maxlevel==5: sqlcheck += " or filter0=? or filter1=? or filter2=? or filter3=? or filter4=?"
   if maxlevel==6: sqlcheck += " or filter0=? or filter1=? or filter2=? or filter3=? or filter4=? or filter5=?"
   sqlcheck += ");"
   if (not issqlite3): sqlcheck = sqlcheck.replace('?','%s')

   sqlcheck2 = "select fasthash from " + table + " where "
   sqlcheck2 += "reactionid=? and (theory=? and xc=? and basis=? and solvation_type=?);"
   if (not issqlite3): sqlcheck2 = sqlcheck2.replace('?','%s')

   print("molecules=",molecules)
   print("method=",method)


   ### make reactant adjmatrix
   nion = 0
   nr = 0
   for mm in molecules:
      if (mm[3]>0):
         nion += len(mm[1])*int(mm[4])
         nr += int(mm[4])

   adj_reactants    = []
   symbol_reactants = []
   for i in range(nion):
      adj_reactants.append([])
      for j in range(nion):
         adj_reactants[i].append(0)
   nionr = 0
   for mm in molecules:
      adjmat1 = mm[2]
      nion1   = len(mm[1])
      if (mm[3]>0):
         for kk in range(int(mm[4])):
            symbol_reactants += mm[1]
            for i in range(nion1):
               for j in range(nion1):
                  adj_reactants[nionr+i][nionr+j] = adjmat1[i][j]
            nionr += nion1
   reactants1 = (nr==1)
   reactants2 = (nr==2)
   bonding_reactants = bonding_string(nion,symbol_reactants,adj_reactants)

   print("reactants1,reactants2=",reactants1,reactants2)
   print("adj_reactants=",reactants1,adj_reactants)


   reactiontypes = myreactiontypes0
   #reactiontypes = ["A + B --> AB", "AB --> A + B", "AB + C --> AC + B","AB + CD --> CABD","CABD --> AB + CD","AB + CD --> AD + BC","EA + BCD --> AB + CDE", "ABC + DE --> DBE + AC","ABCD + E --> A + BC + DE"]
   for reactionid in range(len(reactiontypes)):
      reactiontype = reactiontypes[reactionid]

      (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
      rgraph = graphabc2graph012(rgraph)
      pgraph = graphabc2graph012(pgraph)
      graph  = graphabc2graph012(graph)
      enodes = equivalent_nodeslist(graph)
      renodes = equivalent_nodeslist(rgraph)
      penodes = equivalent_nodeslist(pgraph)
      nnodes = len(enodes[0])

      redges = []
      nredges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in rgraph[i]:
               redges += [[i,j]]
            else:
               nredges += [[i,j]]
      pedges = []
      npedges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in pgraph[i]:
               pedges += [[i,j]]
            else:
               npedges += [[i,j]]
      edges = []
      for i in range(nnodes):
         for j in range(i+1,nnodes):
            if j in graph[i]:
               edges += [[i,j]]

      print()
      print("Looking for " + reactiontype + " reactions")
      print("rgraph=",rgraph)
      print("pgraph=",pgraph)
      print("graph =",graph)
      print("equiv_nodes = ",enodes)
      print("reactant equiv_nodes = ",renodes)
      print("product equiv_nodes = ",penodes)
      print("nnodes      = ",nnodes)
      print("redges      = ",redges)
      print("nredges     = ",nredges)
      print("pedges      = ",pedges)
      print("npedges     = ",npedges)
      print("edges       = ",edges)

      ### get fasthashes ###
      checklist2 = [reactionid]
      checklist2 += method
      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,charset='utf8mb4')
      with dbcon:
         cur = dbcon.cursor()
      cur.execute(sqlcheck2,checklist2)
      fasthashes0 = cur.fetchall()
      fasthashes  = [fasthashes0[i][0] for i in range(len(fasthashes0)) if fasthashes0[i]!=(None,) ]
      #print("fasthashes=",fasthashes)


      if (len(fasthashes)>0):
         print("bonding_reactants = ",bonding_reactants)
         aa = findreaction_loops_string(nnodes,edges,redges,nredges,pedges)
         print("into reactant loops")
         #print("aa=",aa)
         exec(aa)
      else:
         print("No fasthashes for ", reactiontype, " and method=",method)
         bstrings_reactants = {}
      print("number of bstrings_reactions = ",len(bstrings_reactants))

      bond_prune        = [[0,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0], [0,1,1,1,1,1,0,0],[0,1,1,1,1,0,0,0],[0,1,1,1,0,0,0,0],[0,1,1,0,0,0,0,0]]
      replacement_prune = [[0,1,1,1,1,1,1],  [0,1,1,1,1,1,0],   [0,1,1,1,1,0,0],  [0,1,1,1,0,0,0],  [0,1,1,1,0,0,0],  [0,1,1,0,0,0,0]]


      #all_prune =  [replacement_prune[i]+bond_prune[i]+bond_prune[i]+bond_prune[i]+bond_prune[i] for i in range(6)]
      all_prune = []
      for i in range(6):
         tprune = deepcopy(replacement_prune[i])
         for j in range(len(redges)):
            tprune += bond_prune[i]
         tprune += replacement_prune[i]
         for j in range(len(pedges)):
            tprune += bond_prune[i]
         all_prune.append(tprune)

      if (issqlite3):
         dbcon = sqlite3.connect(dbfile)
      else:
         host = hup.split()[0]
         user = hup.split()[1]
         pss = hup.split()[2]
         dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,charset='utf8mb4')
      with dbcon:
         cur = dbcon.cursor()
         for bstring,indxsym in bstrings_reactants.iteritems():
            checklist = [reactionid]
            checklist += method
            checklist.append(bstring)
            for ii in range(maxlevel):
               p = all_prune[ii]
               bstring_filter = filter_reaction_string(p,bstring)
               checklist.append(bstring_filter)

            #print("sqlcheck="+sqlcheck)
            #print("checklist=",checklist)
            cur.execute(sqlcheck,checklist)
            #row = cur.fetchone()
            #if (row != None):
            rows = cur.fetchall()
            for row in rows:
               level = 10
               if   checklist[6]==row[4]:
                  level = 0
               else:
                  for ii in range(maxlevel):
                     #if checklist[maxlevel+2-ii]==row[maxlevel+4-ii]: level = maxlevel-ii
                     if checklist[maxlevel+5-ii]==row[maxlevel+4-ii]: level = maxlevel-ii
               if (level<=maxlevel):
                  print("level=",level," addition bstring=",bstring," row=",row)
                  print("indexes = ", indxsym)
                  print()
                  generate_products0(edges,redges,pedges,molecules,indxsym,bstring,row,level,method)


   print("findreactions not finished!")






###############################################
#                                             #
#          xyz_indx_to_reactionhash           #
#                                             #
###############################################
def xyz_indx_to_reactiohash(xyzfile,indx,reactiontype):

   (mformula1,symbol_reactants,adj_reactants,rxyz,lattice) = xyztoadjmat(xyzfile)
   admat1 = deepcopy(adj_reactants)

   (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
   rgraph = graphabc2graph012(rgraph)
   pgraph = graphabc2graph012(pgraph)
   graph  = graphabc2graph012(graph)
   enodes = equivalent_nodeslist(graph)
   renodes = equivalent_nodeslist(rgraph)
   penodes = equivalent_nodeslist(pgraph)
   nnodes = len(enodes[0])

   redges = []
   nredges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in rgraph[i]:
            redges += [[i,j]]
         else:
            nredges += [[i,j]]
   pedges = []
   npedges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in pgraph[i]:
            pedges += [[i,j]]
         else:
            npedges += [[i,j]]
   edges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in graph[i]:
            edges += [[i,j]]


   for e in pedges:
      adj_reactants[indx[e[0]]][indx[e[1]]] = 0
      adj_reactants[indx[e[1]]][indx[e[0]]] = 0
   for e in redges:
      adj_reactants[indx[e[0]]][indx[e[1]]] = 1
      adj_reactants[indx[e[1]]][indx[e[0]]] = 1
   for e in redges:
      admat1[indx[e[0]]][indx[e[1]]] = 0
      admat1[indx[e[1]]][indx[e[0]]] = 0
   for e in pedges:
      admat1[indx[e[0]]][indx[e[1]]] = 1
      admat1[indx[e[1]]][indx[e[0]]] = 1

   nion = len(symbol_reactants)
   tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_reactants,nion,adj_reactants,indx)
   tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_reactants,nion,admat1,indx)
   tmpstr  = tmpstr1 + ':' + tmpstr2

   gamma = 0.0
   for r in redges:
      ii = indx[r[0]]
      jj = indx[r[1]]
      x = rxyz[3*ii]   - rxyz[3*jj]
      y = rxyz[3*ii+1] - rxyz[3*jj+1]
      z = rxyz[3*ii+2] - rxyz[3*jj+2]
      [x,y,z] = lattice_min(lattice,x,y,z);
      print("reaction ii,jj=",ii,jj,x,y,z)
      gamma += math.sqrt(x*x + y*y + z*z)
   for p in pedges:
      ii = indx[p[0]]
      jj = indx[p[1]]
      x = rxyz[3*ii]   - rxyz[3*jj]
      y = rxyz[3*ii+1] - rxyz[3*jj+1]
      z = rxyz[3*ii+2] - rxyz[3*jj+2]
      [x,y,z] = lattice_min(lattice,x,y,z);
      print("product ii,jj=",ii,jj,x,y,z)
      gamma -= math.sqrt(x*x + y*y + z*z)
   gamma = gamma/0.529177
   indxs = []
   for i in indx: indxs.append(symbol_reactants[i])
   idm2s = [(indx,indxs,gamma,redges,pedges,reactiontype)]


   return (tmpstr,idm2s)


###############################################
#                                             #
#            generate_bondings                #
#                                             #
###############################################

def generate_bondings(indx,reactiontype):

   (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
   rgraph = graphabc2graph012(rgraph)
   pgraph = graphabc2graph012(pgraph)
   graph  = graphabc2graph012(graph)
   enodes = equivalent_nodeslist(graph)
   renodes = equivalent_nodeslist(rgraph)
   penodes = equivalent_nodeslist(pgraph)
   nnodes = len(enodes[0])

   redges = []
   nredges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in rgraph[i]:
            redges += [[i,j]]
         else:
            nredges += [[i,j]]
   pedges = []
   npedges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in pgraph[i]:
            pedges += [[i,j]]
         else:
            npedges += [[i,j]]

   print("indx=",indx)
   print("redges=",redges)
   print("pedges=",pedges)
   #negative numbers bonds being created
   #positive numbers bonds being destroyed
   bondings = 'spring bondings K gamma'
   for r in redges:
      if r not in pedges:
         bondings += " 1.0 %d %d" % (indx[r[0]],indx[r[1]])
   for p in pedges:
      if p not in redges:
         bondings += " -1.0 %d %d" % (indx[p[0]],indx[p[1]])

   return bondings


###############################################
#                                             #
#            findreaction_indexes             #
#                                             #
###############################################

def findreaction_indexes(reactionhash,xyzfile):

   ### make reactant adjmatrix
   (mformula1,symbol_reactants,adj_reactants,rxyz,lattice) = xyztoadjmat(xyzfile)
   nion = len(symbol_reactants)
   symbol_hash = reactionhash.split(":")[2].split("-")

   reactiontype = reactionhash.split(":")[1]
   (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
   rgraph = graphabc2graph012(rgraph)
   pgraph = graphabc2graph012(pgraph)
   graph  = graphabc2graph012(graph)
   enodes = equivalent_nodeslist(graph)
   renodes = equivalent_nodeslist(rgraph)
   penodes = equivalent_nodeslist(pgraph)
   nnodes = len(enodes[0])

   redges = []
   nredges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in rgraph[i]:
            redges += [[i,j]]
         else:
            nredges += [[i,j]]
   pedges = []
   npedges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in pgraph[i]:
            pedges += [[i,j]]
         else:
            npedges += [[i,j]]
   edges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in graph[i]:
            edges += [[i,j]]

   print()
   print("Looking for " + reactiontype + " reactions")
   print("rgraph=",rgraph)
   print("pgraph=",pgraph)
   print("graph =",graph)
   print("equiv_nodes = ",enodes)
   print("reactant equiv_nodes = ",renodes)
   print("product equiv_nodes = ",penodes)
   print("nnodes      = ",nnodes)
   print("redges      = ",redges)
   print("nredges     = ",nredges)
   print("pedges      = ",pedges)
   print("npedges     = ",npedges)
   print("edges       = ",edges)

   aa = findreaction_loops_string00(nnodes,edges,redges,nredges,pedges)
   print("into reactant loops")
   #print(aa)
   exec(aa)
   print("number of bstrings_reactions = ",len(bstrings_reactants))

   indexes = []
   for bstring,indxsym in bstrings_reactants.iteritems():
      #print("bstring=",bstring)
      #print("indexes=",indxsym)
      if bstring==reactionhash:
         #print("indxsym=",indxsym)
         #indexes += indxsym
         idm2s = []
         for idm in indxsym:
            gamma = 0.0
            for r in redges:
               ii = idm[0][r[0]]
               jj = idm[0][r[1]]
               x = rxyz[3*ii]   - rxyz[3*jj]
               y = rxyz[3*ii+1] - rxyz[3*jj+1]
               z = rxyz[3*ii+2] - rxyz[3*jj+2]
               [x,y,z] = lattice_min(lattice,x,y,z);
               gamma += math.sqrt(x*x + y*y + z*z)
            for p in pedges:
               ii = idm[0][p[0]]
               jj = idm[0][p[1]]
               x = rxyz[3*ii]   - rxyz[3*jj]
               y = rxyz[3*ii+1] - rxyz[3*jj+1]
               z = rxyz[3*ii+2] - rxyz[3*jj+2]
               [x,y,z] = lattice_min(lattice,x,y,z);
               gamma -= math.sqrt(x*x + y*y + z*z)
            idm2s += [(idm[0],idm[1],gamma/0.529177,redges,pedges,reactiontype)]
         indexes += idm2s

   return indexes




###############################################
#                                             #
#            findproducts_loops_string        #
#                                             #
###############################################
def findproducts_loops_string(ldepth,edges,redges,pedges,npedges):
   lstring = "bstrings_products = {} \n"
   lstring += "admat1 = deepcopy(adj_products)\n"
   ijk = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
   tab = '   '
   shift = ''
   for l in range(ldepth):
      lstring += shift + "for %s in range(nion):\n" % ijk[l]; shift += tab
      ifstring = ''
      for lm in range(l):
         ifstring += "(%s!=%s) and " % (ijk[l],ijk[lm])

      for lm in range(l):
         if ([lm,l] in pedges):
            ifstring += "(adj_products[%s][%s]>0) and " % (ijk[l],ijk[lm])
         if ([lm,l] in npedges):
            ifstring += "(adj_products[%s][%s]==0) and " % (ijk[l],ijk[lm])
         
      ifstring = ifstring.rstrip("and ")
      if (ifstring!=''):
         lstring += shift + "if %s:\n" % ifstring; shift += tab

   lstring += "\n"

   for e in edges:
      lstring += shift + "a%s%s = adj_products[%s][%s]\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
   lstring += "\n"
   for e in pedges:
      lstring += shift + "adj_products[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "adj_products[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in redges:
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 0\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"
   for e in pedges:
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = 1\n" % (ijk[e[1]],ijk[e[0]])
      lstring += "\n"


   bstring ="["
   for l in range(ldepth):
      bstring += "%s," % ijk[l]
   bstring = bstring.rstrip(",") + "]"
   lstring += shift + "indxs = " + bstring + "\n"
   lstring += shift + "tsyms = [symbol_products[ii] for ii in indxs]\n"
   lstring += shift + "tmpstr1 = generate_reactionhash(reactiontype,redges,enodes,symbol_products,nion,adj_products,indxs)\n"
   lstring += shift + "tmpstr2 = generate_reactionhash(reactiontype,pedges,enodes,symbol_products,nion,admat1,indxs)\n"
   lstring += shift + "tmpstr  = tmpstr1 + \':\' + tmpstr2\n"

   shift2 = shift + tab
   lstring += shift  + "if tmpstr in bstrings_products:\n"
   lstring += shift2 +    "bstrings_products[tmpstr] += [(indxs,tsyms)]\n"
   lstring += shift  + "else:\n"
   lstring += shift2 +    "bstrings_products[tmpstr]  = [(indxs,tsyms)]\n"
   lstring += "\n"
   for e in edges:
      lstring += shift + "adj_products[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "adj_products[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[0]],ijk[e[1]],ijk[e[0]],ijk[e[1]])
      lstring += shift + "admat1[%s][%s] = a%s%s\n" % (ijk[e[1]],ijk[e[0]],ijk[e[0]],ijk[e[1]])
      lstring += "\n"


   return lstring



###############################################
#                                             #
#            findproducts_indexes             #
#                                             #
###############################################

def findproducts_indexes(reactionhash,xyzfile):

   ### make reactant adjmatrix
   (mformula1,symbol_products,adj_products,rxyz,lattice) = xyztoadjmat(xyzfile)
   nion = len(symbol_products)

   reactiontype = reactionhash.split(":")[1]
   (rgraph,pgraph,graph) = reaction2graphs(reactiontype)
   rgraph = graphabc2graph012(rgraph)
   pgraph = graphabc2graph012(pgraph)
   graph  = graphabc2graph012(graph)
   enodes = equivalent_nodeslist(graph)
   renodes = equivalent_nodeslist(rgraph)
   penodes = equivalent_nodeslist(pgraph)
   nnodes = len(enodes[0])

   redges = []
   nredges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in rgraph[i]:
            redges += [[i,j]]
         else:
            nredges += [[i,j]]
   pedges = []
   npedges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in pgraph[i]:
            pedges += [[i,j]]
         else:
            npedges += [[i,j]]
   edges = []
   for i in range(nnodes):
      for j in range(i+1,nnodes):
         if j in graph[i]:
            edges += [[i,j]]

   print()
   print("Looking for " + reactiontype + " reactions")
   print("rgraph=",rgraph)
   print("pgraph=",pgraph)
   print("graph =",graph)
   print("equiv_nodes = ",enodes)
   print("reactant equiv_nodes = ",renodes)
   print("product equiv_nodes = ",penodes)
   print("nnodes      = ",nnodes)
   print("redges      = ",redges)
   print("nredges     = ",nredges)
   print("pedges      = ",pedges)
   print("npedges     = ",npedges)
   print("edges       = ",edges)

   aa = findproducts_loops_string(nnodes,edges,redges,pedges,npedges)
   print("into product loops")
   #print(aa)
   exec(aa)
   print("number of bstrings_reactions = ",len(bstrings_products))

   indexes = []
   for bstring,indxsym in bstrings_products.iteritems():
      #print("bstring=",bstring)
      #print("indexes=",indxsym)
      if bstring==reactionhash:
         #print("indxsym=",indxsym)
         #indexes += indxsym
         idm2s = []
         for idm in indxsym:
            gamma = 0.0
            for r in redges:
               ii = idm[0][r[0]]
               jj = idm[0][r[1]]
               x = rxyz[3*ii]   - rxyz[3*jj]
               y = rxyz[3*ii+1] - rxyz[3*jj+1]
               z = rxyz[3*ii+2] - rxyz[3*jj+2]
               [x,y,z] = lattice_min(lattice,x,y,z);
               gamma += math.sqrt(x*x + y*y + z*z)
            for p in pedges:
               ii = idm[0][p[0]]
               jj = idm[0][p[1]]
               x = rxyz[3*ii]   - rxyz[3*jj]
               y = rxyz[3*ii+1] - rxyz[3*jj+1]
               z = rxyz[3*ii+2] - rxyz[3*jj+2]
               [x,y,z] = lattice_min(lattice,x,y,z);
               gamma -= math.sqrt(x*x + y*y + z*z)
            idm2s += [(idm[0],idm[1],gamma/0.529177)]
         indexes += idm2s

   return indexes





###############################################
#                                             #
#            reactionbalance_molecules        #
#                                             #
###############################################

def reactionbalance_molecules(molecules):
   rps       = []
   coeff     = []
   mformulas = []
   esmiles2all = []
   fullreaction = False
   for mm in molecules:
      mformulas.append(mm[0])
      rps.append(mm[3])
      coeff.append(mm[4])
      esmiles2all.append(mm[5])
      if (mm[3]<0): fullreaction = True

   bstr = ''
   n = len(esmiles2all)
   ii = 0
   for i in range(n):
      if (rps[i]>0):
         if (ii>0): bstr += " + "
         bstr += "%.3f %s" % (coeff[i],esmiles2all[i])
         ii += 1
   if (fullreaction):
      bstr += " --> "
      ii = 0
      for i in range(n):
         if (rps[i]<0):
            if (ii>0): bstr += " + "
            bstr += "%.3f %s" % (coeff[i],esmiles2all[i])
            ii += 1
   print()
   print("initial reaction = " + bstr)
   reaction = bstr





   f2 = f2_reaction(mformulas,rps,coeff)
   print("initial f2=",f2)
   if (f2<1.0e-6): print("The initial chemical reaction is balanced!")

   #### not a balanced reaction - balance it####
   coeff2 = [x/min(coeff) for x in coeff]
   coeff  = coeff2
   alpha = 0.01
   iter_max = 50000
   niter    = 0
   while ((f2>1.0e-12) and (niter<iter_max)):
      df=df_reaction(mformulas,rps,coeff)
      coeff2 = [coeff[i]-alpha*df[i] for i in range(len(coeff))]
      for i in range(len(coeff)):
         if (coeff2[i]<0):
            coeff2[i] *= -1
            rps[i]    *= -1
      coeff = [x/min(coeff2) for x in coeff2]
      f2old = f2
      f2=f2_reaction(mformulas,rps,coeff)
      if ((f2-f2old)>0.0): alpha *= 0.5
      niter += 1

   print("final coeff = ",coeff)
   print("final f2=",f2)

   coeff3 = [round(x) for x in coeff]
   f3 = f2_reaction(mformulas,rps,coeff3)
   print("final coeff3 = ",coeff3)
   print("final f3=",f3)
   if (f3<f2):
      f2 = f3
      coeff = coeff3

   #### try to remove small components and then rebalance ####
   alpha = 0.01
   f0 = 393939.0393
   if (max(coeff) > 50*min(coeff)) or (f2>1.0e-6):
      print("large coeffients found  = ",coeff)
      coeff0       = []
      esmiles2all0 = []
      mformulas0   = []
      rps0         = []
      mcoeff = max(max(coeff)/50.0,min(coeff)+0.01)
      for i in range(len(coeff)):
         if coeff[i]>mcoeff:
            coeff0.append(coeff[i])
            mformulas0.append(mformulas[i])
            rps0.append(rps[i])
            esmiles2all0.append(esmiles2all[i])

      f0=f2_reaction(mformulas0,rps0,coeff0)
      niter = 0
      while ((f0>1.0e-12) and (niter<iter_max)):
         df=df_reaction(mformulas0,rps0,coeff0)
         coeff2 = [coeff0[i]-alpha*df[i] for i in range(len(coeff0))]
         for i in range(len(coeff0)):
            if (coeff2[i]<0):
               coeff2[i] *= -1
               rps0[i]   *= -1
         coeff0 = [x/min(coeff2) for x in coeff2]
         f0old = f0
         f0=f2_reaction(mformulas0,rps0,coeff0)
         if ((f0-f0old)>0.0): alpha *= 0.5
         niter += 1
      print("final coeff0 = ",coeff0)
      print("final f0=",f0)

   #### balanced reaction ####
   if (f2<1e-6):
      bstr = ''
      n = len(esmiles2all)
      ii = 0
      for i in range(n):
         if (rps[i]>0):
            if (ii>0): bstr += " + "
            bstr += "%.3f %s" % (coeff[i],esmiles2all[i])
            ii += 1
      bstr += " --> "
      ii = 0
      for i in range(n):
         if (rps[i]<0):
            if (ii>0): bstr += " + "
            bstr += "%.3f %s" % (coeff[i],esmiles2all[i])
            ii += 1

      print()
      print("balanced reaction = " + bstr)
      reaction = bstr


   #### reduced balanced reaction ####
   if (f0<1e-6):
      bstr = ''
      n = len(esmiles2all0)
      ii = 0
      for i in range(n):
         if (rps0[i]>0):
            if (ii>0): bstr += " + "
            bstr += "%.3f %s" % (coeff0[i],esmiles2all0[i])
            ii += 1
      bstr += " --> "
      ii = 0
      for i in range(n):
         if (rps0[i]<0):
            if (ii>0): bstr += " + "
            bstr += "%.3f %s" % (coeff0[i],esmiles2all0[i])
            ii += 1

      print()
      print("reduced balanced reaction = " + bstr)
      reaction = bstr

   print()
   print()
   print("reaction: " + reaction + " :reaction")
   print()


def listreactions_molecules(hup,dbfile,table,inchikey=''):

   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlcheck = "select id,energy,enthalpy,free_energy,solvation_energy,aq_free_energy,reactiontype,reaction,inchikeys from " + table +" order by id desc;"

   #sqlcheck = "select id,date_time,mformula,esmiles from " + table + " order by id desc"

   
   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host=host,user=user,password=pss,database=dbfile,charset='utf8mb4')

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck)
      rows = cur.fetchall()
      print()
      if inchikey!='':
         print("Reactions Containing INCHIKEY = " + inchikey)
      else:
         print("Reactions Currently in Database:")
      print()
      print("Reactionid    Erxn(gas)    Hrxn(gas)    Grxn(gas)   delta_Solv     Grxn(aq) ReactionType             Reaction")
      for row in rows:
         #print("%10d %12.3f %12.3f %12.3f %12.3f %12.3f %-24s \"%s\"" % row)
         if (inchikey in row[8]) or (inchikey==''):
            ll = "%d" % row[0]
            sp = ''
            for i in range(10-len(ll)):  sp += ' '
            #rink = "<a target=\"_blank\" href=\'https://arrows.emsl.pnnl.gov/api/reaction/\"%s\"\'>%d</a>" % (row[7].replace('#','%23'),row[0])
            rink = "<a target=\"_blank\" href=\'%sreaction/\"%s\"\'>%d</a>" % (ARROWS_API_HOME,row[7].replace('#','%23'),row[0])
            print(sp + "%s %12.3f %12.3f %12.3f %12.3f %12.3f %-24s \"%s\"" % (rink,row[1],row[2],row[3],row[4],row[5],row[6],row[7]))








############################# main program ###################################
usage = \
"""
chemdb balance reaction program

  Usage: chemdb_balance_reaction -h hup_string -d database -t table  -l maxlevel -m myreaction_string -a -x -f  reaction_string

  -h hup_string="machine user password" or enter sqlite3 for sqlite3 db
  -d database = "name of database"
  -t table = "name of reactionhashes table"
  -a add reaction to reactionhash database
  -x testing add reaction
  -f find reactions
  -l maxlevel
  -b fragment
  -r generate reaction hash
  -c generate bondings
  -e generate indexes from reactionhash
  -u generate indexes from reactionhash (products)
  -g list reactions
  -m add user reaction type
  --arrows_api url location 
  --help prints this message

"""


eoln = "\n"
#Database defaults
hup    = hup0
#dbfile = "TNT_Project"
dbfile = dbfile0
table  = "reactionhashes2"

tt      = time.localtime()

maxlevel = 3
xyztohash = False
genbondings = False
findindx    = False
findindx2   = False
findreactions   = False
addreaction     = False
fragmentmolecule = False
balancereaction = True
testingadd = False
listreactions = False
inchikey = ''
opts, args = getopt.getopt(sys.argv[1:], "h:d:t:l:k:m:eaxfbchgru",['help','arrows_api='])
for o, a in opts:
  if o=='-h':
     hup = a
  if o=='-d':
     dbfile = a
  if o=='-t':
     table = a
  if o=='-l':
     maxlevel = evalnum(a)
  if o=='-m':
     myreactiontypes0.append(a)
  if o=='-r':
     xyztohash = True
  if o=='-e':
     findindx = True
  if o=='-u':
     findindx2 = True
  if o=='-c':
     genbondings = True
  if o=='-f':
     findreactions   = True
     balancereaction = False
  if o=='-b':
     fragmentmolecule = True
     balancereaction = False
  if o=='-a':
     addreaction     = True
     balancereaction = False
  if o=='-x':
     addreaction     = True
     testingadd      = True
     balancereaction = False
  if o=='-g':
     listreactions   = True
     testingadd      = False
     balancereaction = False
     inchikey = ''
  if o=='-k':
     listreactions   = True
     testingadd      = False
     balancereaction = False
     inchikey = a
  if o == "--arrows_api":
     ARROWS_API_HOME = a

  if o in ("--help"):
    print(usage)
    exit()

if (listreactions):
   listreactions_molecules(hup,dbfile,table,inchikey)
   exit()

print()
print("chemdb_balance_reaction mysql - version 9.0f = arrows_api url=",ARROWS_API_HOME)
print()

if (len(args)<1): 
   print(usage)
   exit()
print(args[0])

if (genbondings):
   indx = [evalnum(f) for f in args[0].split()]
   reactiontype = args[1]
   pp = generate_bondings(indx,reactiontype)
   print(pp)
   exit()

if (findindx):
   xyzfile      = args[0]
   reactionhash = args[1]
   indxs = findreaction_indexes(reactionhash,xyzfile)
   print("reaction indexes=",indxs)
   indxsp1 = []
   for iii in indxs:
      indxsp1 += [[[f+1 for f in iii[0]],iii[1],iii[2],[[f+1 for f in g] for g in iii[3]],[[f+1 for f in g] for g in iii[4]],iii[5]]]
   print("reaction regular indexes=",indxsp1)
   exit()

if (findindx2):
   xyzfile      = args[0]
   reactionhash = args[1]
   indxs = findproducts_indexes(reactionhash,xyzfile)
   print("products indexes=",indxs)
   indxsp1 = []
   for iii in indxs:
      indxsp1 += [[[f+1 for f in iii[0]],iii[1],iii[2]]] 
   print("products regular indexes=",indxsp1)
   exit()

if (xyztohash):
   xyzfile = args[0]
   indx = [evalnum(f)-1 for f in args[1].split()]
   reactiontype = args[2]
   print("indxes =",indx)
   print("reaction type =",reactiontype)
   print()
   (rhash,indxs) = xyz_indx_to_reactiohash(xyzfile,indx,reactiontype)
   print("rhash =" + rhash)
   print("reaction indexes =",indxs)
   indxsp1 = []
   for iii in indxs:
      indxsp1 += [[[f+1 for f in iii[0]],iii[1],iii[2],[[f+1 for f in g] for g in iii[3]],[[f+1 for f in g] for g in iii[4]],iii[5]]]
   print("reaction regular indexes=",indxsp1)
   exit()

### load the reaction input file into rstring ###
if (os.path.isfile(args[0])):
   with open(args[0],'r') as rfile:
      reaction_string = rfile.read()
else:
   reaction_string = args[0]

if (addreaction):
   ss = reaction_string.split()
   energies = []
   energies.append(eval(ss[0]))
   energies.append(eval(ss[1]))
   energies.append(eval(ss[2]))
   energies.append(eval(ss[3]))
   energies.append(eval(ss[4]))
   reaction = " ".join(ss[5:])
   print("energies = ", energies)
else:
   reaction = reaction_string

print("reaction = ", reaction)


#### determine method ####
theory = "dft"
xc     = "b3lyp"
basis  = "6-311++G(2d,2p)"
solvation_type  = "COSMO"

if "theory{" in reaction:         theory         = reaction.split("theory{")[1].split("}")[0].strip()
if "pspw" in theory:
   xc = "pbe"
   basis = "100.0 Ry"
   solvation_type = "None"

if "xc{" in reaction:             xc             = reaction.split("xc{")[1].split("}")[0].strip()
if "basis{" in reaction:          basis          = removespace_basis(reaction.split("basis{")[1].split("}")[0].strip())
if "solvation_type{" in reaction: solvation_type = reaction.split("solvation_type{")[1].split("}")[0].strip()
if "maxlevel{" in reaction:       maxlevel       = evalnum(reaction.split("maxlevel{")[1].split("}")[0].strip())

if (theory=="ccsd(t)") or (theory=="mp2"):
   xc = "unknown"

if (theory=="pm3") or (theory=="am1") or (theory=="mindo") or (theory=="mindo3"):
   xc = "unknown"
   basis = "semiempirical"

print("maxlevel=",maxlevel)
print("theory=",theory)
print("xc=",xc)
print("basis=",basis)
print("solvation_type=",solvation_type)
method = [theory,xc,basis,solvation_type]
print("method = ", method)
if "~" in reaction:
   reaction = reaction.split("~")[0].strip()




######################
### parse reaction ###
######################
sslist = reaction.split("-->")
left  = sslist[0].strip()
left = left.replace("\t"," ")
left = left.replace("\n"," ")
   #left = left.decode('ascii', 'replace')
left = left.replace('\xc2', ' ')
left = left.replace('\xa0', ' ')
esmiles_reactants  = left.split(' + ')
number_reactants = len(esmiles_reactants)

if (len(sslist)>1) and (not findreactions):
   right = sslist[1].strip()
   right= right.replace("\t"," ")
   right= right.replace("\n"," ")
   right= right.replace('\xc2', ' ')
   right= right.replace('\xa0', ' ')
   esmiles_products   = right.split(' + ')
   number_products  = len(esmiles_products)
else:
   esmiles_products = []
   number_products  = 0

print()
print("esmiles_reactants=",esmiles_reactants)
print("esmiles_products =",esmiles_products)
print("numbers=",number_reactants,number_products)

molecules          = []
rps = []
rsmiles = []
smiles_reactants   = []
esmiles2_reactants = []
mformula_reactants = []
coeff_reactants    = []
for esmiles in esmiles_reactants:
   try:
      x = float(esmiles.split(None,1)[0])
      coeff_reactants.append(x)
      esmiles2 = esmiles.split(None,1)[1]
   except:
      x = 1.0
      coeff_reactants.append(1.0)
      esmiles2 = esmiles
   if "SHE" in esmiles2: esmiles2 = "[SHE]"
   esmiles2_reactants.append(esmiles2)

   if "SHE" in esmiles2:
      mult   = 2
      charge    = -1
      mformula1 = "SHE1"
      symbol1 =  ["SHE"]
      adjmat1 = [[0]]
      rxyz = [0.0,0.0,0.0]
      for i in range(int(x)):
         rsmiles.append("[SHE]")
      inchikey = ''
   else:
      cmd    = esmiles2xyz + '\"' + esmiles2 + '\" ' + wrkdir+"/"+tmpxyz1
      result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
      if "inchikey =" in result: 
         inchikey = result.split("inchikey =")[1].split("\n")[0].strip()
      else:
         inchikey = ''
      (mult,charge) = parse_result2multcharge(result)
      if ("^{" in esmiles2):    charge = eval(esmiles2.split("^{")[1].split('}')[0])
      if ("mult{" in esmiles2): mult   = eval(esmiles2.split("mult{")[1].split('}')[0])
      (mformula1,symbol1,adjmat1,rxyz,lattice) = xyztoadjmat(wrkdir+"/"+tmpxyz1)
      for i in range(int(x)):
         rsmiles.append(result.split("csmiles  =")[1].split("\n")[0].strip())
   molecules.append([mformula1,symbol1,adjmat1,1,x,esmiles2,rxyz,mult,charge,inchikey])
   mformula_reactants.append(mformula1)
   rps.append(1)


psmiles = []
smiles_products   = []
esmiles2_products = []
mformula_products = []
coeff_products    = []
for esmiles in esmiles_products:
   try:
      x = float(esmiles.split(None,1)[0])
      coeff_products.append(x)
      esmiles2 = esmiles.split(None,1)[1]
   except:
      x = 1.0
      coeff_products.append(1.0)
      esmiles2 = esmiles
   if "SHE" in esmiles2: esmiles2 = "[SHE]"
   esmiles2_products.append(esmiles2)

   if "SHE" in esmiles2:
      mult   = 2
      charge    = -1
      mformula1 = "SHE1"
      symbol1 =  ["SHE"]
      adjmat1 = [[0]]
      rxyz = [0.0,0.0,0.0]
      for i in range(int(x)):
         psmiles.append("[SHE]")
      inchikey = ''
   else:
      cmd    = esmiles2xyz + '\"' + esmiles2 + '\" ' + wrkdir+"/"+tmpxyz1
      result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
      if "inchikey =" in result: 
         inchikey = result.split("inchikey =")[1].split("\n")[0].strip()
      else:
         inchikey = ''
      (mult,charge) = parse_result2multcharge(result)
      if ("^{" in esmiles2):    charge = eval(esmiles2.split("^{")[1].split('}')[0])
      if ("mult{" in esmiles2): mult   = eval(esmiles2.split("mult{")[1].split('}')[0])
      (mformula1,symbol1,adjmat1,rxyz,lattice) = xyztoadjmat(wrkdir+"/"+tmpxyz1)
      for i in range(int(x)):
         psmiles.append(result.split("csmiles  =")[1].split("\n")[0].strip())
   molecules.append([mformula1,symbol1,adjmat1,-1,x,esmiles2,rxyz,mult,charge,inchikey])
   mformula_products.append(mformula1)
   rps.append(-1)
   #print("product symbol,adjmat=",symbol1,adjmat1)

esmiles2all = esmiles2_reactants + esmiles2_products

print()
print("mformula_reactants=",mformula_reactants,coeff_reactants)
print("mformula_products =",mformula_products, coeff_products)
print("rps=",rps)
print("combined reactant smiles=",'.'.join(rsmiles))
print("combined product  smiles=",'.'.join(psmiles))

if (addreaction):
   bstrings = reactiontype_molecules2bstrings(hup,dbfile,table,molecules,reaction,energies,method,testingadd)

if (findreactions):
   findreactions_molecules(hup,dbfile,table,molecules,method,maxlevel)

#if (fragmentmolecule):
#   fragment_molecules(hup,dbfile,table,molecules,maxlevel)

#if (balancereaction):
#   reactionbalance_molecules(molecules)


### remove temporary wrkdir files ###
try:
   os.unlink(wrkdir + "/"+tmpsmi1)
except:
   print("chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpsmi1)

try:
   os.unlink(wrkdir + "/"+tmpsmi2)
except:
   print("chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpsmi2)

try:
   os.unlink(wrkdir + "/"+tmpxyz1)
except:
   print("chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpxyz1)

try:
   os.unlink(wrkdir + "/"+tmperxn)
except:
   print("chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmperxn)

try:
   os.unlink(wrkdir + "/"+tmpnwout)
except:
   print("chemdb_fetch_reactions5 Failed to remove " + wrkdir + "/"+ tmpnwout)

