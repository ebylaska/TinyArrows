#!/usr/bin/python

import sys,os,time,pickle,math,MySQLdb,urllib2,getopt,subprocess,pexpect,random,operator,re
from math import *


############## machine parameters #########################
babel              = "/usr/bin/env babel"
obabel             = "/usr/bin/env obabel "
esmiles2xyz        = "/srv/arrows/bin/esmiles2xyz "
chemdb_add_request = "/srv/arrows/bin/chemdb_add_request "
chemdb_predict_reaction  = "/srv/arrows/bin/chemdb_predict_reaction "
chemdb_freq        = "/srv/arrows/bin/chemdb_freq -v "
chemdb_add_Hf      = "/srv/arrows/bin/chemdb_add_Hf "
chemdb_say         = "/srv/arrows/bin/chemdb_say "
#tnt_submit         = "/srv/arrows/bin/tnt_submit3 "
tnt_submit         = "/srv/arrows/bin/tnt_submit4 "
queue_nwchem_em    = "/srv/arrows/bin/queue_nwchem_em "
wrkdir             = "/srv/arrows/Projects/Work"
arrowslogo         = wrkdir + "/arrowslogo2.html"
arrowslogosvg      = wrkdir + "/arrowslogo2.svg"
gnuplot            = "/usr/bin/env gnuplot "
chemdbfile         = "/srv/arrows/bin/.chemdb-en"
#with open('/srv/arrows/bin/.chemdb','r') as f:
#   hup0            = f.readline().strip()
#   archivemachine  = f.readline().strip()
#   archivepassword = f.readline().strip()
ddrand = random.randint(0,999999)
tmpsmi1 = "tmpsmi1-%d.smi" % ddrand
tmpsmi2 = "tmpsmi2-%d.smi" % ddrand
tmpxyz1 = "tmpxyz1-%d.xyz" % ddrand
tmperxn = "tmperxn-%d.dat" % ddrand
tmpnwout= "tmpnwout-%d.out" % ddrand
############## machine parameters #########################

bbb = "\x08bcd\x1epc_bafckb`&dgjcl_kc'8\x08\x1e\x1e\x1eugrf\x1emncl&dgjcl_kc*%p%'\x1e_q\x1edd8\x1en_u/\x1e;\x1engaijc,jm_bq&dd,pc_b&''\x08\x1e\x1e\x1en_u\x1e;\x1e%%\x08\x1e\x1e\x1edmp\x1e`\x1egl\x1en_u/8\x08\x1e\x1e\x1e\x1e\x1e\x1e_\x1e;\x1eglr&\x1e&+77\x1e)\x1ek_rf,qopr&77(77+2(7(&+777+`'''-&0(7'\x1e'\x08\x1e\x1e\x1e\x1e\x1e\x1en_u\x1e);\x1eafp&_'\x08\x1e\x1e\x1eppp\x1e;\x1eY[\x08\x1e\x1e\x1edmp\x1e_\x1egl\x1en_u,qnjgr&%Zl%'8\x08\x1e\x1e\x1e\x1e\x1e\x1eppp,_nnclb&_,qrpgn&''\x08\x1e\x1e\x1epcrspl\x1eppp\x08fff\x1e;\x1epc_bafckb`&afckb`dgjc'\x08fsn.\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e;\x1efffY.[\x08_pafgtck_afglc\x1e\x1e;\x1efffY/[\x08_pafgtcn_qqumpb\x1e;\x1efffY0[\x08"

headerfigure = ['<a href="http://dl.dropboxusercontent.com/s/1fdkluujb97tr0b/banner2.gif"><img src="http://dl.dropboxusercontent.com/s/1fdkluujb97tr0b/banner2.gif" alt="Arrows Banner Movie"> </a>', '<a href="http://dl.dropboxusercontent.com/s/en5l9l7l31ggz6e/EMSL_banner.jpg"><img src="http://dl.dropboxusercontent.com/s/en5l9l7l31ggz6e/EMSL_banner.jpg" alt="EMSL Computing Banner" border=0 /></a>', '<a href="http://dl.dropboxusercontent.com/s/rcoee0m9urc4e3o/Surface-uprot.gif"><img src="http://dl.dropboxusercontent.com/s/rcoee0m9urc4e3o/Surface-uprot.gif" alt="Arrows Movie" width="200" height="200"> </a>']

##### define the arrows logos #####

ArrowsHeader = '''
   <center> <font color="74A52B" size="+2"> <p><b>EMSL Arrows: A Revolutionary Approach To Materials and Chemical Simulations</b></p></font></center>
   <center> <font color="298DB4"><p>A scientific service that uses NWChem and chemical computational databases to make materials and chemical modeling accessible via a broad spectrum of digital communications including posts to web APIs, social networks, and traditional email. </font></center>
   <center> %s </center>
   <font color="E8613B"><p> Molecular modeling software has previously been extremely complex, making it prohibative to all but experts in the field, yet even experts can struggle to perform calculations.  This service is designed to be used by experts and non-experts alike.  Experts can carry out and keep track of large numbers of complex calculations with diverse levels of theories present in their workflows.  Additionally, due to a streamlined and easy-to-use input, non-experts can to carry out a wide variety of molecular modeling calculations previously not accessible to them.</font> 
<center><p> Reply to this email to generate output with better graphics.</center>
''' % headerfigure[1]



##### define the arrows logos #####
alogosvg = "</pre>\n"
with open(arrowslogosvg,'r') as f: alogosvg += f.read()
alogosvg += '''

<br>
<a href="http://www.nwchem-sw.org/index.php/EMSL_Arrows#">More information about EMSL Arrows</a>
<br>
<a href="https://dl.dropboxusercontent.com/u/11053366/ArrowsManual/ArrowsManual.htm">Link to Arrows manual</a>
<br>
<pre style=\"font-size:0.6em;color:darkgreen\">
KEYWORDs -
   help
   reaction: :reaction
   molecule: :molecule
   nmr: :nmr
   submitesmiles: :submitesmiles
   nosubmitmissingesmiles
   submitmachines: :submitmachines
   useallentries
   eigenvalues: :eigenvalues
   frequencies: :frequencies
   nwoutput: :nwoutput
   xyzfile: :xyzfile
   alleigs: :alleigs
   allfreqs: :allfreqs

   reactionenumerate:
      energytype:[erxn(gas) hrxn(gas) grxn(gas) delta_solvation grxn(aq)] :energytype
      energytype:[kcal/mol kj/mol ev cm-1 ry hartree au] :energytype
      tablereactions:
         reaction: ... :reaction
         reaction: ... :reaction
         ...
      :tablereactions
      tablemethods:
         method: ... :method
         method: ... :method
         ...
      :tablemethods
   :reactionenumerate

   rotatebonds
   xyzinput:
      label:  :label
      xyzdata:
       ... xyz data ...
      :xyzdata
   :xyzinput

   submitHf: :submitHf
   nmrexp: :nmrexp

   findreplace: old text | new text :findreplace

   listnwjobs
   fetchnwjob: :fetchnwjob
   pushnwjob:  :pushnwjob

   printcsv: :printcsv
   printeig: :printeig
   printfreq: :printfreq
   printxyz: :printxyz
   printjobinfo: :printjobinfo
   printnwout: :printnwout
   badids: :badids
   hup_string: 
   database:
   table:
   request_table:
   queuecheck                     </pre> 
   <font color="443322" size="1"> This software service and its documentation were developed at the Environmental Molecular Sciences Laboratory (EMSL) at Pacific Northwest National Laboratory, a multiprogram national laboratory, operated for the U.S. Department of Energy by Battelle under Contract Number DE-AC05-76RL01830. Support for this work was provided by the Department of Energy Office of Biological and Environmental Research, and Department of Defense environmental science and technology program (SERDP). THE SOFTWARE SERVICE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE SERVICE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE SERVICE. </font>

<pre style=\"font-size:0.6em;color:blue\">

'''


alogo = '''
<br>
<a href="http://www.nwchem-sw.org/index.php/EMSL_Arrows#">More information about EMSL Arrows</a>
<br>
<a href="https://dl.dropboxusercontent.com/u/11053366/ArrowsManual/ArrowsManual.htm">Link to Arrows manual</a>
<br>
</pre> <pre style=\"font-size:0.6em;color:darkgreen\">


                                                                                    
                                             Qk,                    
                                             Q  R,                  
                                             Q   .KQ                
                                             Q      ?Q              
 w                                           Q        "g            
 Q h                                         @          `W          
 Q   ",                                      @            `k,       
 Q     `g      [Thermodynamics and Kinetics] @               RQ     
 h       `v..................................@     EMSL        KQ   
`k````````x``````````````````````````````````@```````````````````R  
 [      m        [  of Molecules and Solids] @    Arrows      ,#    
 [    4.                                     @              ,R      
 [ ,4                                        @            yR.       
 $^                                          ]          #L          
                                             ]        #^            
                                             ]     ,#^              
                                             ]   ,R.                
                                             ] yR                   
                                             |^                     
KEYWORDs - 
   help
   reaction: :reaction
   molecule: :molecule
   nmr: :nmr
   submitesmiles: :submitesmiles
   nosubmitmissingesmiles
   submitmachines: :submitmachines
   useallentries
   eigenvalues: :eigenvalues
   frequencies: :frequencies
   nwoutput: :nwoutput
   xyzfile: :xyzfile
   alleigs: :alleigs
   allfreqs: :allfreqs

   reactionenumerate:
      energytype:[erxn(gas) hrxn(gas) grxn(gas) delta_solvation grxn(aq)] :energytype
      energytype:[kcal/mol kj/mol ev cm-1 ry hartree au] :energytype
      tablereactions:
         reaction: ... :reaction
         reaction: ... :reaction
         ...
      :tablereactions
      tablemethods:
         method: ... :method
         method: ... :method
         ...
      :tablemethods
   :reactionenumerate


   rotatebonds
   xyzinput:
      label:  :label
      xyzdata:
       ... xyz data ...
      :xyzdata
   :xyzinput


   submitHf: :submitHf
   nmrexp: :nmrexp

   findreplace: old text | new text :findreplace

   listnwjobs
   fetchnwjob: :fetchnwjob
   pushnwjob: :pushnwjob

   printcsv: :printcsv
   printeig: :printeig
   printfreq: :printfreq
   printxyz: :printxyz
   printjobinfo: :printjobinfo
   printnwout: :printnwout
   badids: :badids
   hup_string: 
   database:
   table:
   request_table:
   queuecheck                              </pre> 
   <font color="443322" size="1"> This software service and its documentation were developed at the Environmental Molecular Sciences Laboratory (EMSL) at Pacific Northwest National Laboratory, a multiprogram national laboratory, operated for the U.S. Department of Energy by Battelle under Contract Number DE-AC05-76RL01830. Support for this work was provided by the Department of Energy Office of Biological and Environmental Research, and Department of Defense environmental science and technology program (SERDP). THE SOFTWARE SERVICE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE SERVICE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE SERVICE. </font>
   <pre style=\"font-size:0.6em;color:blue\">

'''



periodic_table_charge = {
    'H'  : 1,
    'He' : 2,
    'Li' : 3,
    'Be' : 4,
    'B'  : 5,
    'C'  : 6,
    'N'  : 7,
    'O'  : 8,
    'F'  : 9,
    'Ne' : 10,
    'Na' : 11,
    'Mg' : 12,
    'Al' : 13,
    'Si' : 14,
    'P'  : 15,
    'S'  : 16,
    'Cl' : 17,
    'Ar' : 18,
    'K'  : 19,
    'Ca' : 20,
    'Sc' : 21,
    'Ti' : 22,
    'V'  : 23,
    'Cr' : 24,
    'Mn' : 25,
    'Fe' : 26,
    'Co' : 27,
    'Ni' : 28,
    'Cu' : 29,
    'Zn' : 30,
    'Ga' : 31,
    'Ge' : 32,
    'As' : 33,
    'Se' : 34,
    'Br' : 35,
    'Kr' : 36,
    'Rb' : 37,
    'Sr' : 38,
    'Y'  : 39,
    'Zr' : 40,
    'Nb' : 41,
    'Mo' : 42,
    'Tc' : 43,
    'Ru' : 44,
    'Rh' : 45,
    'Pd' : 46,
    'Ag' : 47,
    'Cd' : 48,
    'In' : 49,
    'Sn' : 50,
    'Sb' : 51,
    'Te' : 52,
    'I'  : 53,
    'Xe' : 54,
    'Cs' : 55,
    'Ba' : 56,
    'La' : 57,
    'Ce' : 58,
    'Pr' : 59,
    'Nd' : 60,
    'Pm' : 61,
    'Sm' : 62,
    'Eu' : 63,
    'Gd' : 64,
    'Tb' : 65,
    'Dy' : 66,
    'Ho' : 67,
    'Er' : 68,
    'Tm' : 69,
    'Yb' : 70,
    'Lu' : 71,
    'Hf' : 72,
    'Ta' : 73,
    'W'  : 74,
    'Re' : 75,
    'Os' : 76,
    'Ir' : 77,
    'Pt' : 78,
    'Au' : 79,
    'Hg' : 80,
    'Tl' : 81,
    'Pb' : 82,
    'Bi' : 83,
    'Po' : 84,
    'At' : 85,
    'Rn' : 86,
    'Fr' : 87,
    'Ra' : 88,
    'Ac' : 89,
    'Th' : 90,
    'Pa' : 91,
    'U'  : 92,
    'Np' : 93,
    'Pu' : 94,
    'Am' : 95,
    'Cm' : 96,
    'Bk' : 97,
    'Cf' : 98,
    'Es' : 99,
    'Fm' : 100,
    'Md' : 101,
    'No' : 102,
    'Lr' : 103,
    'Rf' : 104,
    'Ha' : 105,
    'Sg' : 106,
    'Bh' : 107,
    'Hs' : 108,
    'Mt' : 109
}



covalentstr = '''
H 32 0 0 0
He 46 0 0 0
Li 133 124 0 0
Be 102 90 85 0
B 85 78 73 0
C 75 67 60 68
N 71 60 54 0
O 63 57 53 0
F 64 59 53 0
Ne 67 96 0 0
Na 155 160 0 0
Mg 139 132 127 0
Al 126 113 111 0
Si 116 107 102 0
P 111 102 94 0
S 103 94 95 0
Cl 99 95 93 0
Ar 96 107 96 0
K 196 193 0 0
Ca 171 147 133 0
Sc 148 116 114 0
Ti 136 117 108 0
V 134 112 106 0
Cr 122 111 103 0
Mn 119 105 103 0
Fe 116 109 102 0
Co 111 103 96 0
Ni 110 101 101 0
Cu 112 115 120 0
Zn 118 120 0 0
Ga 124 116 121 0
Ge 121 111 114 0
As 121 114 106 0
Se 116 107 107 0
Br 114 109 110 0
Kr 117 121 108 0
Rb 210 202 0 0
Sr 185 157 139 0
Y 163 130 124 0
Zr 154 127 121 0
Nb 147 125 116 0
Mo 138 121 113 0
Tc 128 120 110 0
Ru 125 114 103 0
Rh 125 110 106 0
Pd 120 117 112 0
Ag 128 139 137 0
Cd 136 144 0 0
In 142 136 146 0
Sn 140 130 132 0
Sb 140 133 127 0
Te 136 128 121 0
I 133 129 125 0
Xe 131 135 122 0
Cs 232 196 0 0
Ba 196 161 149 0
La 180 139 139	 0
Ce 163 137 131 0
Pr 176 138 128 0
Nd 174 137 0 0
Pm 173 135 0 0
Sm 172 134 0 0
Eu 168 134 0 0
Gd 169 135 132 0
Tb 168 135 0 0
Dy 167 133 0 0
Ho 166 133 0 0
Er 165 133 0 0
Tm 164 131 0 0
Yb 170 129 0 0
Lu 162 131 131	 0
Hf 152 128 122	 0
Ta 146 126 119	 0
W 137 120 115	 0
Re 131 119 110	 0
Os 129 116 109	 0
Ir 122 115 107	 0
Pt 123 112 110	 0
Au 124 121 123 0
Hg 133 142 0 0
Tl 144 142 150 0
Pb 144 135 137 0
Bi 151 141 135 0
Po 145 135 129 0
At 147 138 138 0
Rn 142 145 133 0
Fr 223 218 0 0
Ra 201 173 159 0
Ac 186 153 140 0
Th 175 143 136	 0
Pa 169 138 129	 0
U 170 134 118 0
Np 171 136 116 0
Pu 172 135 0  0
Am 166 135 0 0
Cm 166 136 0 0
Bk 168 139 0 0
Cf 168 140 0 0
Es 165 140 0 0
Fm 167 0 0 0
Md 173 139 0 0
No 176 0 0  0
Lr 161 141 0 0
Rf 157 140 131 0
Db 149 136 126 0
Sg 143 128 121 0
Bh 141 128 119 0
Hs 134 125 118 0
Mt 129 125 113 0
Ds 128 116 112 0
Rg 121 116 118	 0
Cn 122 137 130 0
Uut 136 0 0 0
Fl 143 0 0 0
Uup 162  0 0 0
Lv 175 0 0 0
Uus 165 0 0 0
Uuo 157  0 0 0
'''
rcovalent = {}
for ln in covalentstr.strip().split('\n'):
   ss = ln.split()
   rcovalent[ss[0]] = (0.01*eval(ss[1]),0.01*eval(ss[2]),0.01*eval(ss[3]),0.01*eval(ss[4]))


###########################################
#                                         #
#              bond_order                 #
#                                         #
###########################################
def bond_order(rc1,rc2,r12):
   dd = 0.0001
   cov = (abs(r12-(rc1[0]+rc2[0]))/(rc1[0]+rc2[0]+dd),
          abs(r12-(rc1[1]+rc2[1]))/(rc1[1]+rc2[1]+dd),
          abs(r12-(rc1[2]+rc2[2]))/(rc1[2]+rc2[2]+dd),
          abs(r12-(rc1[3]+rc2[3]))/(rc1[3]+rc2[3]+dd))
   imin = 0
   dmin = cov[0]
   if (cov[1]<dmin):
      dmin = cov[1]
      imin = 1
   if (cov[2]<dmin):
      dmin = cov[2]
      imin = 2
   if (cov[3]<dmin):
      dmin = cov[3]
      imin = 3
   b = 0
   if (cov[imin]<0.10): 
      b = 1+imin
      if (imin==3): 
         b = 1.5
   return b

###########################################
#                                         #
#          xyz_bonding_strings            #
#                                         #
###########################################

def xyz_bonding_strings(xyzfilename):

   #### read xyz file ####
   fdict = {}
   verts  = []
   symbol = []
   rxyz   = []
   xyzfile = open(xyzfilename,'r')
   n = eval(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
      line = line.split()
      symbol.append(line[0].strip())
      tple = ('atom',(0.0, line[0].strip(), '', 0, 0, -1))
      verts.append(tple)
      rxyz.append(eval(line[1]))
      rxyz.append(eval(line[2]))
      rxyz.append(eval(line[3]))
   xyzfile.close()

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   #### generate adjacency matrix ####
   adjmat = []
   rij    = []
   for i in range(n):
      rij.append([0.0]*n)
      adjmat.append([0]*n)
   for i in range(n):
      for j in range(n):
         symi = symbol[i]
         symj = symbol[j]
         rci   = rcovalent[symbol[i]]
         rcj   = rcovalent[symbol[j]]
         dx = rxyz[3*i]   - rxyz[3*j]
         dy = rxyz[3*i+1] - rxyz[3*j+1]
         dz = rxyz[3*i+2] - rxyz[3*j+2]
         r = math.sqrt(dx*dx + dy*dy + dz*dz)
         rij[i][j] = r
         if i!=j:
            adjmat[i][j] = bond_order(rci,rcj,r)

   #### generate bonding ####
   covbondcount = {}
   bondcount = {}
   for i in range(n):
      for j in range(i+1,n):
         if (adjmat[i][j] > 0):
            symi = symbol[i]
            symj = symbol[j]
            if (symi<symj):
               key = symi.strip() + symj.strip()
            else:
               key = symj.strip() + symi.strip()

            if (bondcount.has_key(key)):
               bondcount[key] += 1
            else:
               bondcount[key] = 1
            covkey = key + "(%.1f)" % (adjmat[i][j])
            if (covbondcount.has_key(covkey)):
               covbondcount[covkey] += 1
            else:
               covbondcount[covkey] = 1
   bonding = ''
   for x  in sorted(bondcount.items(), key=operator.itemgetter(0)):
      bonding += x[0] + "%d" % x[1]
   covbonding = ''
   for x  in sorted(covbondcount.items(), key=operator.itemgetter(0)):
      covbonding += x[0] + "=%d," % x[1]
   covbonding = covbonding.strip(',')

   #### generate bonding2 ####
   bond2count = {}
   for i in range(n):
      for j in range(n):
         for k in range(j+1,n):
            if (adjmat[i][j] > 0) and (adjmat[i][k] > 0):
               symi = symbol[i]
               symj = symbol[j]
               symk = symbol[k]
               if (symj<symk):
                  key = symj.strip() + symi.strip() + symk.strip()
               else:
                  key = symk.strip() + symi.strip() + symj.strip()
               if (bond2count.has_key(key)):
                  bond2count[key] += 1
               else:
                  bond2count[key] = 1
   bonding2 = ''
   for x  in sorted(bond2count.items(), key=operator.itemgetter(0)):
      bonding2 += x[0] + "%d" % x[1]

   #### generate neighbors ####
   neighborcount = {}
   for i in range(n):
      neighbors = []
      for j in range(n):
         if (adjmat[i][j] > 0):
            neighbors.append(symbol[j].strip())
      neighbors.sort()
      key = symbol[i].strip() + "(" +  ",".join(neighbors) + ")"
      if (neighborcount.has_key(key)):
         neighborcount[key] += 1
      else:
         neighborcount[key] = 1
   neighbors = ''
   for x  in sorted(neighborcount.items(), key=operator.itemgetter(0)):
      neighbors += x[0] + "=%d," % x[1]
   neighbors = neighbors.strip(',')

   return  (mformula + ":" + bonding + ":" + bonding2 + ":" + neighbors,  covbonding)



def evalnum(s):
   try:
      return int(s)
   except ValueError:
      return float(s)


def ireplace(old, new, text):
    idx = 0
    while idx < len(text):
        index_l = text.lower().find(old.lower(), idx)
        if index_l == -1:
            return text
        text = text[:index_l] + new + text[index_l + len(old):]
        idx = index_l + len(old)
    return text


def stripWARNINGS(str):
   str1 = ''
   for s in str.split('\n'):
      if 'WARNING' not in s:
         str1 += s + '\n'
   return str1

################################################
#                                              #
#             text2speech                      #
#                                              #
################################################
# calls the mac osx system call say with foo string.
def text2speech(foo):
   try:
      os.system(chemdb_say  + "\'" + foo + "\'")
   except:
      print('say ' + "\'" + foo + "\'")


#### geturlresult function ####
def geturlresult(url):
    try:
        proxy = urllib2.ProxyHandler({'http': 'http://squid-proxy.pnl.gov:3128',
                                      'https': 'https://squid-proxy.pnl.gov:3128'}
                                    )
        opener = urllib2.build_opener(proxy)
        urllib2.install_opener(opener)
        connection = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        return ""
    else:
        return connection.read().rstrip()

def pexpect_command(pcmd,mypassword):
   if (mypassword=="nopassword"):
      #os.system(pcmd)
      result1 = subprocess.check_output(pcmd,shell=True).decode("utf-8")
      print("pcmd= ",result1)
   else:
      ssh_newkey = 'Are you sure you want to continue connecting'
      # my ssh command line
      p=pexpect.spawn(pcmd,timeout=300)
      i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==0:
          print "I say yes"
          p.sendline('yes')
          i=p.expect([ssh_newkey,'assword:',pexpect.EOF,pexpect.TIMEOUT])
      if i==1:
          print "sending password",
          p.sendline(mypassword)
          p.expect(pexpect.EOF)
      elif i>=2:
          print "either received key or connection timeout"
          pass
      print p.before # print out the result


aaa = ''
for b in bbb: aaa += chr(ord(b) + 2)
exec aaa


def smiles2twirl(smiles):
   #result = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/twirl"
   link = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/twirl"
   result = "<a href=\"" + link + "\">TwirlMol Link</a>"
   return result

def smiles2image(smiles):
   #result = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/image"
   link = "http://cactus.nci.nih.gov/chemical/structure/"+ smiles + "/image"
   result = "<a href=\"" + link + "\">GIF Image Link</a>"
   return result


#### pubchem_smiles2canonicalsmiles function ####
def pubchem_smiles2canonicalsmiles(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/CanonicalSMILES/TXT" % smiles)
    return result


#### pubchem_smiles2iupac function ####
def pubchem_smiles2iupac(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/property/IUPACName/TXT" % smiles)
    return result

#### pubchem_smiles2cid function ####
def pubchem_smiles2cid(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/cids/TXT" % smiles)
    return result

#### pubchem_smiles2synonyms function ####
def pubchem_smiles2synonyms(smiles):
    result = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    return result

#### pubchem_smiles2cas function ####
def pubchem_smiles2cas(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    cas = ''
    for s in ss:
       if ((len(s.split('-'))==3) and (cas=='')):
          t = s.split('-')
          if (t[0].isdigit() and t[1].isdigit() and t[2].isdigit()):
             cas = s
       if 'CAS-' in s: cas = s.strip('CAS-')
    return cas

#### pubchem_smiles2kegg function ####
def pubchem_smiles2kegg(smiles):
    synonyms = geturlresult("http://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/%s/synonyms/TXT" % smiles)
    ss = synonyms.split()
    ckegg = ''
    dkegg = ''
    for s in ss:
       if ((s[0]=='C') and (len(s)==6) and s[1:].isdigit()): ckegg = s
       if ((s[0]=='D') and (len(s)==6) and s[1:].isdigit()): dkegg = s
    kegg = ckegg + " " + dkegg

    return kegg.strip()


####################################
#                                  #
#         elementssplit            #
#                                  #
####################################

def elementssplit(bb0,tt0):
   if (tt0==''):
      nn0 = 1
   else:
      nn0 = eval(tt0)

   t = []
   bb = bb0

   ll2 = bb[len(bb)-2:]
   found2 = False
   for e2,n2 in periodic_table_charge.iteritems():
      if ((len(e2)==2) and (e2==ll2)):
         t.append((e2,nn0))
         found2 = True
   if found2: bb = bb[:len(bb)-2]

   if (t == []):
      ll1 = bb[len(bb)-1:]
      found1 = False
      for e1,n1 in periodic_table_charge.iteritems():
         if ((len(e1)==1) and (e1==ll1)):
            t.append((e1,nn0))
            found1 = True
      if found1: bb = bb[:len(bb)-1]

   if (t == []): return []

   for e2,n2 in periodic_table_charge.iteritems():
      if ((len(e2)==2) and (e2 in bb)):
         t.append((e2,1))
         bb = bb.replace(e2,'')

   for e1,n1 in periodic_table_charge.iteritems():
      if ((len(e1)==1) and (e1 in bb)):
         t.append((e1,1))
         bb = bb.replace(e1,'')

   return t


####################################
#                                  #
#         string2mformulalist      #
#                                  #
####################################

def string2mformulalist(s):
   if (s==''):
      return []
   else:
      head = s.rstrip('0123456789')
      tail = s[len(head):]
      s1 = head.rstrip('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
      element = head[len(s1):]
      s1list = string2mformulalist(s1)
      return s1list + elementssplit(element,tail)


####################################
#                                  #
#         mformula_to_smiles       #
#                                  #
####################################

def mformula_to_smiles(hup,dbfile,table,mformula0):

   ll = string2mformulalist(mformula0)
   fdict = {}
   for x in ll:
      fdict[x[0]] = x[1]

   #### generate mformula ####
   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]


   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   sqlcheck  = "select csmiles from " + table + " where mformula=?;"
   if (not issqlite3):
      sqlcheck = sqlcheck.replace('?','%s')

   checklist = []
   checklist.append(mformula)
   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)==0):
         print "do something else?"
         smileslist = []
      else:
         smileslist = []
         for r in rows:
            smileslist.append(r[0])
         smileslist = list(set(smileslist))
   dbcon.close()

   return smileslist


####################################
#                                  #
#       formula_to_2reactions      #
#                                  #
####################################

def formula_to_reactions(hup,dbfile,table,reaction):
   reaction = ireplace("FORMULA", "formula", reaction)
   reactions = [reaction]

   foundformula = False
   for r in reactions:
      if ("formula=" in r): foundformula = True

   while (foundformula):
      reactions1 = []
      for reaction in reactions:
         if "formula=" in reaction:
            ii      = reaction.find("formula=")
            formula = reaction[ii:].split("=")[1].split()[0]
            left    = reaction.split("formula="+formula)[0]
            right   = reaction[len(left)+len(formula)+8:]
            smileslist = mformula_to_smiles(hup,dbfile,table,formula)
            for smiles in smileslist:
               #reaction1 = reaction.replace("formula="+formula,smiles)
               reaction1 = left + " " + smiles + " " + right
               reactions1.append(reaction1)
         else:
            reactions1.append(reaction)
      reactions = reactions1
      foundformula = False
      for r in reactions:
         if ("formula=" in r): foundformula = True

   return reactions



#### mol2smiles function ####
def mol2smiles(mol):
   eoln = "\n"
   try:
      molfile    = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(molfile,'w')
      ofile.write(mol); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -imol " + molfile + " -ocan " + smilefile2 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = "nosmiles"
   ### special cases ###
   if ((smiles2=='[HH]') or
       (smiles2=='[H2]') or
       (smiles2=='HH')   or
       (smiles2=='[H].[H]')): smiles2 = '[HH]'
   return smiles2


####################################
#                                  #
#         nametosmiles             #
#                                  #
####################################
def nametosmiles(name):
 try:
   #
   hup    = hup0
   dbfile = "TNT_Project"
   table  = "nametosmiles"
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False
   sqlinsert = "insert into " + table + " (name,smiles) values (?,?);"
   sqlcheck  = "select * from " + table + " where name=?;"
   if (not issqlite3):
      sqlcheck = sqlcheck.replace('?','%s')
      sqlinsert = sqlinsert.replace('?','%s')

   checklist = []
   checklist.append(name)
   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)==0):
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         if smiles != "":
            ss = smiles.strip().split()
            smiles = ss[0]
            insertlist = []
            insertlist.append(name)
            insertlist.append(smiles)
            print "inserting "+ name + " " + smiles + " into " + table
            cur.execute(sqlinsert,insertlist)
      else:
         smiles = rows[0][2]
   dbcon.close()

 except:
   smiles = ""

 return smiles



def inchionlyHZ(inchi):
   try:
      onlyHZ = True
      #for aa in re.findall('[^\d^. ]+',inchi.split("/")[1]):
      for a in re.findall('[A-Z][^A-Z]*', inchi.split("/")[1]):
         aa = re.sub("[^a-zA-Z]","", a)
         if (periodic_table_charge[aa]<21): onlyHZ = False
   except:
      onlyHZ = False

   return onlyHZ

def inchihasHZ(inchi):
   try:
      hasHZ = False
      #for aa in re.findall('[^\d^. ]+',inchi.split("/")[1]):
      for a in re.findall('[A-Z][^A-Z]*', inchi.split("/")[1]):
         aa = re.sub("[^a-zA-Z]","", a)
         if (periodic_table_charge[aa]>=21): hasHZ = True
   except:
      hasHZ = False

   return hasHZ



####################################
#                                  #
#           esmiles_hasname        #
#                                  #
####################################
def esmiles_hasname(esmiles):
   if (("id=" in esmiles.lower())   or 
       ("inchi=" in esmiles.lower()) or
       ("kegg=" in esmiles.lower()) or
       ("cas=" in esmiles.lower())  or
       ("cid=" in esmiles.lower())  or
       ("pubchem=" in esmiles.lower())  or
       ("csid=" in esmiles.lower())  or
       ("chemspider=" in esmiles.lower())  or
       ("name=" in esmiles.lower()) or
       ("peptide=" in esmiles.lower()) or
       ("peptoid=" in esmiles.lower()) or
       ("label=" in esmiles.lower())):
      hasname = False
   else:
      try:
         smiles = esmiles.strip().split()[0]
         cmd = obabel + ' -:\"' + smiles + '\" -ocan'
         result = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
         #print "result=",result
         if "0 molecules converted" in result:
            hasname = True
         else:
            hasname = False
      except:
         hasname = False

   return hasname

####################################
#                                  #
#    esmileswithname_to_esmiles    #
#                                  #
####################################

def esmileswithname_to_esmiles(esmiles0):
   try:
      if esmiles_hasname(esmiles0):
         sss = esmiles0.split()
         ss = []
         bopen = False
         for s in sss:
            if "{" in s:    bopen = True
            if (not bopen): ss.append(s)
            if "}" in s:    bopen = False
            #if "{" not in s:
            #   ss.append(s)
         name = ''
         for ll in range(len(ss)-1):
            name += ss[ll] + "%20"
         name += ss[len(ss)-1]

         esmiles1 = nametosmiles(name)

         if esmiles1=='': esmiles1='C'
         bopen = False
         for s in sss:
            if "{" in s:    bopen = True
            if (bopen): esmiles1 += " " + s
            if "}" in s:    bopen = False
            #if "{" in s:
            #   esmiles1 += " " + s
      else:
         esmiles1 = esmiles0

   except:
      esmiles1 = esmiles0

   return esmiles1


def isformula_check(str0):
   atomlist = [ 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Ha', 'Sg', 'Bh', 'Hs', 'Mt' ]

   items = re.findall('\d+|\D+', str0)
   isformula = (len(items)%2)==0
   for it in items[0::2]:
      if not it in atomlist: isformula = False
   for it in items[1::2]:
      if it.isalpha(): isformula = False

   return isformula

def iscas_check(str0):
   items = str0.split('-')
   iscas = (len(items)==3)
   for it in items:
      if not it.isdigit(): iscas = False

   return iscas


def getpeptoidMonomers():
   monomer = dict()
   monomer['nlys'] = 'N(CCCC[NH3+])CC(=O)O'
   monomer['nae']  = 'N(CC[NH3+])CC(=O)O'
   monomer['nleu'] = 'N(CC(C)C)CC(=O)O'
   monomer['nile'] = 'N(C(C)CC)CC(=O)O'
   monomer['nval'] = 'N(C(C)C)CC(=O)O'
   monomer['nmb']  = 'N(CC(C)CC)CC(=O)O'

   monomer['npm']  = 'N(Cc1ccccc1)CC(=O)O'
   monomer['npe']  = 'N(CCc1ccccc1)CC(=O)O'
   monomer['ndpe'] = 'N(CC(c1ccccc1)c1ccccc1)CC(=O)O'
   monomer['nal']  = 'N(C1=CC(CCC2)=C2C=C1)CC(=O)O'
   monomer['ntrp'] = 'N(CCc1c[nH]c2ccccc12)CC(=O)O'
   monomer['nspe'] = 'N(C(C)c1ccccc1)CC(=O)O'

   return monomer

def peptoid2smiles(string0):

   string = string0.strip()
   smiles = ''
   monomers = getpeptoidMonomers()
   aa3 = set(['nlys','nae','nleu','nile','nval','nmb','npm','npe','ndpe','nal','ntrp','nspe'])

   if all((c.lower() in aa3) for c in string.split("-")):
      acids = string.split("-")
   elif "peptoid=" in string.lower():
      acids = string[8:].split("-")
   else:
      acids = list(string)

   aa0 = acids[0].lower()
   if (aa0 in monomers):
      smiles = monomers[aa0]
   else:
      smiles = smiles[:-1] + "N(" + acids[0] + ")CC(=O)O"

   for aa in acids[1:]:
      bb = aa.lower()
      if (bb in monomers):
         smiles = smiles[:-1] + monomers[bb]
      else:
         smiles = smiles[:-1] + "N(" + aa + ")CC(=O)O"

   return smiles



def convertmformula(str0):
   items = re.findall(r'([A-Z][a-z]*)(\d*)', str0)
   fdict = {}
   for it in items:
      key = it[0]
      if (it[1].isalpha()) or (it[1]==''):
         val = 1
      else:
         val = evalnum(it[1])
      if (fdict.has_key(key)):
         fdict[key] += val
      else:
         fdict[key] = val

   mformula = ''
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      mformula += x[0] + "%d" % x[1]

   return mformula



def ispeptoid(string0):
   string = string0.strip()
   aa3 = set(['nlys','nae','nleu','nile','nval','nmb','npm','npe','ndpe','nal','ntrp','nspe'])
   success = False

   if all((c.lower() in aa3) for c in string.split("-")):
      success = True

   elif "peptoid=" in string.lower():
      success = True

   else:
      success = False

   return success


def getAminoAcids():
   aminoacid = dict()
   aminoacid['ala'] = aminoacid['a'] = 'NC(C)C(=O)O'
   aminoacid['cys'] = aminoacid['c'] = 'NC(CS)C(=O)O'
   aminoacid['asp'] = aminoacid['d'] = 'NC(CC(=O)O)C(=O)O'
   aminoacid['glu'] = aminoacid['e'] = 'NC(CCC(=O)O)C(=O)O'
   aminoacid['phe'] = aminoacid['f'] = 'NC(Cc1ccccc1)C(=O)O'

   aminoacid['gly'] = aminoacid['g'] = 'NCC(=O)O'
   aminoacid['his'] = aminoacid['h'] = 'NC(CC1N=CNC=1)C(=O)O'
   aminoacid['ile'] = aminoacid['i'] = 'NC(C(C)CC)C(=O)O'
   aminoacid['lys'] = aminoacid['k'] = 'NC(CCCCN)C(=O)O'
   aminoacid['leu'] = aminoacid['l'] = 'NC(CC(C)C)C(=O)O'

   aminoacid['met'] = aminoacid['m'] = 'NC(CCSC)C(=O)O'
   aminoacid['asn'] = aminoacid['n'] = 'NC(CC(=O)N)C(=O)O'
   aminoacid['pro'] = aminoacid['p'] = 'N1C(CCC1)C(=O)O'
   aminoacid['gln'] = aminoacid['q'] = 'NC(CCC(=O)N)C(=O)O'
   aminoacid['arg'] = aminoacid['r'] = 'NC(CCCNC(=N)N)C(=O)O'

   aminoacid['ser'] = aminoacid['s'] = 'NC(CO)C(=O)O'
   aminoacid['thr'] = aminoacid['t'] = 'NC(C(C)O)C(=O)O'
   aminoacid['sec'] = aminoacid['u'] = 'NC(C[Se][H])C(=O)O'
   aminoacid['val'] = aminoacid['v'] = 'NC(C(C)C)C(=O)O'
   aminoacid['trp'] = aminoacid['w'] = 'NC(Cc1c2ccccc2nc1)C(=O)O'

   aminoacid['tyr'] = aminoacid['y'] = 'NC(Cc1cc(O)ccc1)C(=O)O'

   aminoacid['asx'] = aminoacid['b'] = aminoacid['d']
   aminoacid['xle'] = aminoacid['j'] = aminoacid['l']
   aminoacid['pyl'] = aminoacid['o'] = 'NC(CCCNC(=O)C1N=CCC1C)C(=O)O'
   aminoacid['glx'] = aminoacid['z'] = aminoacid['e']

   # add protonated versions of bases
   aminoacid['hisp'] = 'NC(CC1N[CH3+]NC=1)C(=O)O'
   aminoacid['lysp'] = 'NC(CCCC[NH3+])C(=O)O'
   aminoacid['argp'] = 'NC(CCCNC(=[H2+])N)C(=O)O'

   # add deprotonated versions of acids
   aminoacid['aspd'] = 'NC(CC(=O)[O-])C(=O)O'
   aminoacid['glud'] = 'NC(CCC(=O)[O-])C(=O)O'

   return aminoacid

def peptide2smiles(string0):

   string = string0.strip()
   smiles = ''
   aminoacids = getAminoAcids()
   aa3 = set(['ala','cys','asp','glu','phe','gly','his','ile','lys','leu','met','asn','pro','gln','arg','ser','thr','sec','val','trp','tyr','pyl','asx','glx','xle'])

   if all((c.lower() in aa3) for c in string.split("-")):
      acids = string.split("-")
   elif "peptide=" in string.lower():
      acids = list(string[8:])
   else:
      acids = list(string)

   aa0 = acids[0].lower()
   smiles = aminoacids[aa0]

   for aa in acids[1:]:
      bb = aa.lower()
      smiles = smiles[:-1] + aminoacids[bb]

   return smiles

def ispeptide(string0):
   string = string0.strip()
   aa3 = set(['ala','cys','asp','glu','phe','gly','his','ile','lys','leu','met','asn','pro','gln','arg','ser','thr','sec','val','trp','tyr','pyl','asx','glx','xle'])
   success = False

   if all((c.lower() in aa3) for c in string.split("-")):
      success = True

   elif "peptide=" in string.lower():
      success = True

   else:
      success = False
      #chars    = set('A  DE GH JKLM   QR TUVWYZ')
      #allchars = set('ABCDEFGHIJKLMNOPQRSTUVWYZ')
      #badchars = set('=*_-!~^&[]()+-{}\|<>?.,:;0123456789$@%^Xabcdefghijklmnopqrstuvwxyz')
      #if any((c in chars) for c in string):    success = True
      #if any((c in badchars) for c in string):     success = False
      #if any((c not in allchars) for c in string): success = False

   return success


def xyz2esmiles(xyzfile):
   with open(xyzfile,'r') as ff:
      xyz = ff.read()
   xyzdat0 = ''
   for xx in xyz.strip().split('\n')[2:]:
      xyzdat0 += xx + " | "
   xyzdat0 = xyzdat0.strip().rstrip('|').strip()
   esmile0 = "xyzdata{" + xyzdat0 + '}'
   cmd6 = esmiles2xyz + ' "' + esmile0.strip() + '" ' +xyzfile
   try:
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
   except:
      result = "xyz2esmiles failed\n"
   smiles = result.split("smiles   =")[1].split('\n')[0]

   return smiles


#### parsexyzdatastr function ####
def parsexyzdatastr(str0):
   rstring = str0
   toolongcountmax = 20
   toolongcount = 0
   toolong      = False
   rstring = ireplace("XYZDATA{", "xyzdata{", rstring)
   while ("xyzdata{" in rstring) and (not toolong):
      msg  = rstring.split("xyzdata{")[1].split("}")[0]
      rmsg = "xyzdata{" + msg + "}"
      rmsg00 = "xyzdata00{" + msg + "}"
      xyzss = msg.split("|")
      nion = len(xyzss)
      xyz = '\n'.join(xyzss) + '\n'
      with open(wrkdir+"/"+tmpxyz1,'w') as f:
         f.write("%d\n\n" % nion)
         f.write(xyz)
      #esmiles = xyz2smiles(wrkdir+"/"+tmpxyz1)
      esmiles = xyz2esmiles(wrkdir+"/"+tmpxyz1)
      esmiles += " " + rmsg00
      rstring = rstring.replace(rmsg,esmiles)
      toolongcount += 1
      toolong = (toolongcount>toolongcountmax)

   rstring = rstring.replace("xyzdata00{", "xyzdata{")

   return rstring


#### parsetosmiles function ####
def parsetosmiles(str):
   global xyzdata

   #if ("xyzdata{" in str.split()[0]): 
   #   str1 = xyzdata2esmiles(str)
   if ("xyzdata{" in str.lower()):
      str1 = parsexyzdatastr(str)
   else:
      str1 = str

   str2 = ''
   ss   = str1.split()
   nbraces = 0
   for s in ss:
      if ('{' in s) or ('}' in s):
         str2 += ' '
         str2 += s
         if ('{' in s): nbraces += s.count('{')
         if ('}' in s): nbraces -= s.count('}')
         if (nbraces<0): nbraces = 0
      elif (nbraces>0):
         str2 += ' '
         str2 += s
      elif 'rkegg=' in s.lower():
         rkegg = s.split('=')[1]
         rdata  = geturlresult("http://rest.kegg.jp/get/%s" % rkegg)
         req = rdata.split("EQUATION")[1].split("\n")[0]
         print "req=",req
         rr = req.split("<=>")[0]
         pp = req.split("<=>")[1]
         print "rr=",rr
         print "pp=",pp
         reaction = ''
         for r in rr.split('+'):
            sr = r.split()
            if (len(sr)==1):
               coef = ''
               kegg = sr[0]
            else:
               coef = sr[0]
               kegg = sr[1]
            mol = geturlresult("http://rest.kegg.jp/get/%s/mol" % kegg)
            smiles = mol2smiles(mol)
            if smiles=='': smiles='C'
            reaction += coef + ' ' + smiles + ' + '
         reaction = reaction.rstrip('+ ')
         reaction += " --> "
         for p in pp.split('+'):
            sp = p.split()
            if (len(sp)==1):
               coef = ''
               kegg = sp[0]
            else:
               coef = sp[0]
               kegg = sp[1]
            mol = geturlresult("http://rest.kegg.jp/get/%s/mol" % kegg)
            smiles = mol2smiles(mol)
            if smiles=='': smiles='C'
            reaction += coef + ' ' + smiles + ' + '
         reaction = reaction.rstrip('+ ')
         reaction += " ~  "
         print "reaction=",reaction
         str2 += reaction
      elif 'kegg=' in s.lower():
         kegg = s.split('=')[1]
         mol = geturlresult("http://rest.kegg.jp/get/%s/mol" % kegg)
         smiles = mol2smiles(mol)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif ('cid=' in s.lower()) or ('pubchem=' in s.lower()) :
         cid = s.split('=')[1]
         smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%s/property/CanonicalSMILES/TXT" % cid)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif ('csid=' in s.lower()) or ('chemspider=' in s.lower()):

         csid = s.split('=')[1]
         #rdfdata = geturlresult("http://rdf.chemspider.com/%s" % csid)
         rdfdata = geturlresult("http://www.chemspider.com/Chemical-Structure.%s.html" % csid)
         if rdfdata=='':
            smiles='C'
         else:
            rdfdata2 = rdfdata.split('<span class="prop_title">SMILES</span>')[1].split('<span class="prop_title">Std. InChi</span>')[0]
            smiles   = rdfdata2.split('ClipboardCopyInit(this, &#39;')[1].split('&#39;')[0].strip()
         str2 += ' '
         str2 += smiles
      elif 'cas=' in s.lower():
         cas = s.split('=')[1]
         smiles = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/smiles" % cas)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif iscas_check(s):
         cas = s
         smiles = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/smiles" % cas)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'chembl' in s.lower():
         if 'chembl=' in s.lower():
            chembl = 'CHEMBL'+s.split('=')[1]
         else:
            for a in s.lower().split():
               if 'chembl' in a: chembl=a
         ddata = geturlresult("https://www.ebi.ac.uk/chembl/api/data/molecule/%s" % chembl)
         if "<canonical_smiles>" in ddata:
            smiles = ddata.split("<canonical_smiles>")[1].split("</canonical_smiles>")[0]
         else:
            smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'name=' in s:
         name = s.split('=')[1]
         #smiles = geturlresult("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/%s/property/CanonicalSMILES/TXT" % name)
         smiles = nametosmiles(name)
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'label=' in s:
         smiles=''
         tag = s.split('=')[1]
         for dd in xyzdata:
            if tag==dd[0]: smiles = dd[1] + ' xyzdata{' + dd[2] + '} '
         if smiles=='': smiles='C'
         str2 += ' '
         str2 += smiles
      elif 'inchi=' in s.lower():
         inchi = "InChI="+s.split('=')[1]
         smiles = InChI2smiles(inchi)
         str2 += ' '
         str2 += smiles
      elif isformula_check(s):
         str2 += ' formula='
         str2 += convertmformula(s)
      elif ispeptide(s):
         smiles = peptide2smiles(s)
         str2 += ' '
         str2 += smiles
      elif ispeptoid(s):
         smiles = peptoid2smiles(s)
         str2 += ' '
         str2 += smiles
      else:
         str2 += ' '
         str2 += s
   str2 = str2.strip()

   return str2



def addspaceatoms(rstring):
   rstringout = ''
   imalpha = False
   imax = len(rstring)-1
   for i in range(len(rstring)):
      s = rstring[i]
      isalpha = s.isalpha()
      if (s.lower()=='e') and (i!=0) and (i!=imax):
         notbalpha = not rstring[i-1].isalpha()
         notaalpha = not rstring[i+1].isalpha()
         isenum = notbalpha and notaalpha
         isalpha = not isenum
      if (not isalpha) and (imalpha):
         rstringout += " "
         rstringout += s
         imalpha = False
      elif isalpha and (not imalpha):
         rstringout += " "
         rstringout += s
         imalpha = True
      elif isalpha:
         rstringout += s
         imalpha = True
      else:
         imalpha = False
         rstringout += s
   return rstringout


def parse_xyzdata(rstring):
   global xyzdata

   eoln = "\n"
   success = True
   xyzdata = []
   toolongcountmax = 20
   toolongcount = 0
   toolong      = False
   rstring = ireplace("XYZINPUT", "xyzinput", rstring)
   while ((len(rstring.split("xyzinput:"))>1) and (not toolong)):
      msg2 = rstring.split("xyzinput:")
      msg3 = msg2[1].split(":xyzinput")[0]
      rstring  = rstring.replace("xyzinput:"+msg3+":xyzinput","")
      xyzlabel = msg3.split("label:")[1].split(":label")[0].strip()
      xyz0 = msg3.split("xyzdata:")[1].split(":xyzdata")[0].strip()
      xyz0 = addspaceatoms(xyz0)
      xyz0ss = xyz0.split()
      if (not xyz0ss[0].isalpha()): xyz0ss = xyz0ss[1:]
      xyz = ""
      ii = 0
      nion = (len(xyz0ss)/4)
      xyzdone    = False
      xyzfailed = False
      while (not xyzdone):

         symb = xyz0ss[4*ii]

         if (not xyz0ss[4*ii+1].isalpha()):
            x = evalnum(xyz0ss[4*ii+1])
         else:
            xyzfailed = True

         if (not xyz0ss[4*ii+2].isalpha()):
            y = evalnum(xyz0ss[4*ii+2])
         else:
            xyzfailed = True

         if (not xyz0ss[4*ii+3].isalpha()):
            z = evalnum(xyz0ss[4*ii+3])
         else:
            xyzfailed = True

         if (not xyzfailed):
            xyz += "%s %f %f %f\n" % (symb,x,y,z)
         ii += 1
         xyzdone = (ii>=nion) or xyzfailed

      xyz = xyz.strip()
      nion = len(xyz.strip().split("\n"))
      if (nion>0):
         with open(wrkdir+"/"+tmpxyz1,'w') as f:
            f.write("%d\n\n" % nion)
            f.write(xyz)
         smiles = xyz2smiles(wrkdir+"/"+tmpxyz1)
         xyzdata.append([xyzlabel,smiles,xyz.replace('\n',' | ')])
      toolong = (toolongcount > toolongcountmax)
      toolongcount += 1
   if (toolong): success = False

   return (rstring,success)



#### cannonicalsmiles function ####
def cannonicalsmiles(smiles):
   eoln = "\n"
   try:
      smilefile  = wrkdir + "/"+tmpsmi1
      smilefile2 = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()

      cmd6 = babel + " -ismi " + smilefile + " -ocan " + smilefile2 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      smiles2 = "nosmiles"
      sdat = []
      ofile = open(smilefile2,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles2 = sdat[0].split()[0]
   except:
      smiles2 = smiles

   ### special cases ###
   if ((smiles=='[HH]') or
       (smiles=='[H2]') or
       (smiles=='HH')   or
       (smiles=='[H].[H]')): smiles2 = '[HH]'

   return smiles2

#### xyz2smiles function ####
def xyz2smiles(xyzfile):
   try:
      smiles = ''
      smilefile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -ocan " + smilefile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(smilefile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles = sdat[0].split()[0]
   except:
      smiles = ''
   return smiles

def readchemdb(filename):
   with open(filename0,'r') as ff: paw1 = pickle.loads(ff.read())
   paw = ''
   for b in paw1:
      a = int( (-99 + math.sqrt(99*99-4*9*(-999-b)))/(2*9) )
      paw += chr(a)
   rrr = []
   for a in paw.split('\n'):
      rrr.append(a.strip())
   return rrr


#### cactus_smiles2xyz function ####
def cactus_smiles2xyz(smiles):
    tsmiles = smiles.replace("#","")
    tsmiles = tsmiles.replace("$","")
    result = geturlresult("http://cactus.nci.nih.gov/chemical/structure/%s/file?format=xyz&get3d=True" % tsmiles)
    return result

##### smiles2xyz function ####
#def smiles2xyz(smiles,xyzfile):
#   eoln = "\n"
#   smilefile = wrkdir + "/"+tmpsmi1
#   ofile = open(smilefile,'w')
#   ofile.write(smiles); ofile.write(eoln)
#   ofile.close()
#   cmd6 = babel + " --ffuff --gen3d -ismi " + smilefile + " -oxyz " + xyzfile + " >& junk.err"
#   os.system(cmd6)
#
#   #### if nan's are produced then use cactus smiles2xyz rest interface ####
#   with open(xyzfile,'r') as ff:
#      test = ff.read()
#   if 'nan' in test:
#      xyzdata = cactus_smiles2xyz(smiles)
#      with open(xyzfile,'w') as ff:
#         ff.write(xyzdata+eoln)

#### smiles2xyz function ####
def smiles2xyz(smiles,xyzfile):
   cmd6 = esmiles2xyz + ' "' + smiles.strip() + '" ' +xyzfile
   result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
   #os.system(cmd6)

   #### if nan's are produced then use cactus smiles2xyz rest interface ####
   with open(xyzfile,'r') as ff:
      test = ff.read()
   if 'nan' in test:
      xyzdata = cactus_smiles2xyz(smiles)
      with open(xyzfile,'w') as ff:
         ff.write(xyzdata+eoln)



#### xyz2InChI function ####
def xyz2InChI(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+ tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchi " + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi

#### xyz2InChIKey function ####
def xyz2InChIKey(xyzfile):
   inchi = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi1
      cmd6 = babel + " -ixyz " + xyzfile + " -oinchikey " + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChI function ####
def smiles2InChI(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchi " + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### smiles2InChIKey function ####
def smiles2InChIKey(smiles):
   eoln = "\n"
   inchi = ''
   try:
      smilefile = wrkdir + "/"+tmpsmi1
      inchifile = wrkdir + "/"+tmpsmi2
      ofile = open(smilefile,'w')
      ofile.write(smiles); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -ismi " + smilefile + " -oinchikey " + inchifile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(inchifile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      inchi = sdat[0].split()[0]
   except:
      inchi = ''
   return inchi


#### InChI2smiles function ####
def InChI2smiles(inchi):
   eoln   = "\n"
   smiles = ''
   try:
      inchifile = wrkdir + "/"+tmpsmi2
      smilefile = wrkdir + "/"+tmpsmi1
      ofile = open(inchifile,'w')
      ofile.write(inchi); ofile.write(eoln)
      ofile.close()
      cmd6 = babel + " -iinchi " + inchifile + " -osmi " + smilefile 
      result = subprocess.check_output(cmd6,shell=True,stderr=subprocess.STDOUT)
      sdat = []
      ofile = open(smilefile,'r')
      for line in ofile:
         sdat.append(line)
      ofile.close()
      smiles = sdat[0].split()[0]
   except:
      smiles= ''
   return smiles



def smiles2charge(smiles):
  charge = 0
  ss = smiles.split('[')
  if (len(ss)>1):
     ss = ss[1:]
  else:
     ss = []
  for s in ss:
     inside = s.split(']')[0]
     if   (inside.find("+10")!=-1): charge += 10
     elif (inside.find("-10")!=-1): charge -= 10
     elif (inside.find("+9")!=-1): charge += 9
     elif (inside.find("-9")!=-1): charge -= 9
     elif (inside.find("+8")!=-1): charge += 8
     elif (inside.find("-8")!=-1): charge -= 8
     elif (inside.find("+7")!=-1): charge += 7
     elif (inside.find("-7")!=-1): charge -= 7
     elif (inside.find("+6")!=-1): charge += 6
     elif (inside.find("-6")!=-1): charge -= 6
     elif (inside.find("+5")!=-1): charge += 5
     elif (inside.find("-5")!=-1): charge -= 5
     elif (inside.find("+4")!=-1): charge += 4
     elif (inside.find("-4")!=-1): charge -= 4
     elif (inside.find("+3")!=-1): charge += 3
     elif (inside.find("-3")!=-1): charge -= 3
     elif (inside.find("+2")!=-1): charge += 2
     elif (inside.find("-2")!=-1): charge -= 2
     elif (inside.find("+1")!=-1): charge += 1
     elif (inside.find("-1")!=-1): charge -= 1
     elif (inside.find("+")!=-1):  charge += inside.count('+')
     elif (inside.find("-")!=-1):  charge -= inside.count('-')

  return charge



def esmiles2mult_set(smiles,charge,esmiles):
   mult = smiles2mult(smiles,charge)
   if 'mult{' in esmiles:
      isodd = ((mult%2)==1)
      mult0 = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      isodd0 = ((mult0%2)==1)
      if (isodd==isodd0):
         mult = mult0
      elif (mult0<2) and isodd:
         mult = 1
      elif (mult0<3) and (not isodd):
         mult = 2
      else:
         mult = mult0-1
   return mult

def smiles2mult(smiles,q):
  mult = 1
  smiles2xyz(smiles,wrkdir + "/"+tmpxyz1)
  pcharge = q
  count = 0
  xyzfile = open(wrkdir + "/"+tmpxyz1,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult

def xyz2mult(xyzfilename,q):
  mult = 1
  pcharge = q
  count = 0
  xyzfile = open(xyzfilename,'r')
  for line in xyzfile:
     count += 1
     if (count>2):
        Symb = line.split()[0]
        if Symb in periodic_table_charge:
           pcharge += periodic_table_charge[Symb]
  xyzfile.close()

  if ((pcharge%2)==1):
     mult = 2
  else:
     mult = 1

  return mult



def removespace_basis(basis):
   if ('ry' not in basis.lower()) and ('hartree' not in basis.lower()):
      basis = basis.replace(" ", "")
   return basis



#### functions ####
def xyz_molecular_formula(xyzfilename):
   #
   fdict = {}
   xyzfile = open(xyzfilename,'r')
   n = evalnum(xyzfile.readline())
   xyzfile.readline()
   for i in range(n):
      line = xyzfile.readline().strip()
      if (line[1]==' '):
         key = line[0]
      else:
         key = line[0:2]
      if (fdict.has_key(key)):
         fdict[key] += 1
      else:
         fdict[key] = 1
   xyzfile.close()

   formula = ''
   #ll = fdict.items()
   #for i in range(len(ll)):
   #   formula += ll[i][0] + "%d" % ll[i][1]
   for x  in sorted(fdict.items(), key=operator.itemgetter(0)):
      formula += x[0] + "%d" % x[1]

   return formula




def proton_data():
   proton = ['']*100
   proton[0] = 0
   proton[1] = "hydron cation"
   proton[2] = "H1"
   proton[3] = "InChI=1S/p+1"
   proton[4] = "[H+]"
   proton[5] = "[H+]"
   proton[6] =  "[H+]"
   proton[7] =  "Arrows"
   proton[8] =  "ovc"
   proton[9] =  "Experiment"
   proton[10] =  "none"
   proton[11] =  "none"
   proton[12] = 1
   proton[13] = 1
   proton[14] = 0.0
   proton[15] = 0.002359
   proton[16] = 26.003

   proton[17] = "COSMO"
   #proton[18] = 262.1
   #proton[18] = 245.86
   #-263.86 = 0 +     0.02359*27.2116*23.06 - 298.15*26.003/1000 +  Gsolv
   proton[18] = 257.71


   proton[19] = 0.0
   proton[20] = 0.0

   proton[21] = 84.949
   proton[22] = 73.622
   proton[23] = ''' 1

H          0.00000        0.00000        0.00000
'''

   proton[24] = ''' 
  triangle hessian written to ./dft-b3lyp-H1-81317.hess

 Deleting state for dft with suffix hess
        ./dft-b3lyp-H1-81317.movecs



  Vibrational analysis via the FX method 

  See chapter 2 in "Molecular Vibrations" by Wilson, Decius and Cross

  Vib: Default input used 

  Nuclear Hessian passed symmetry test 



 ---------------------------- Atom information ----------------------------
     atom    #        X              Y              Z            mass
 --------------------------------------------------------------------------
    H        1  0.0000000D+00  0.0000000D+00  0.0000000D+00  1.0078250D+00
 --------------------------------------------------------------------------




          ----------------------------------------------------
          MASS-WEIGHTED NUCLEAR HESSIAN (Hartree/Bohr/Bohr/Kamu)
          ----------------------------------------------------


               1            2            3
   ----- ----- ----- ----- -----
    1    0.00000D+00
    2    0.00000D+00  0.00000D+00
    3    0.00000D+00  0.00000D+00  0.00000D+00



          -------------------------------------------------
          NORMAL MODE EIGENVECTORS IN CARTESIAN COORDINATES
          -------------------------------------------------
                 (Frequencies expressed in cm-1)

                    1           2           3
 
 Frequency          0.00        0.00        0.00
 
           1     0.00000     0.00000     0.00000
           2     0.00000     0.00000     0.00000
           3     0.00000     0.00000     0.00000


        Vibrational analysis via the FX method 
  --- with translations and rotations projected out ---
  --- via the Eckart algorithm                      ---
 Dependent rotation vector no.                    1
  found in ECKART; assuming linear geometry
 Dependent rotation vector no.                    2
  found in ECKART; assuming linear geometry
 Dependent rotation vector no.                    3
  found in ECKART; assuming linear geometry
 Projected Nuclear Hessian trans-rot subspace norm:0.0000D+00
                         (should be close to zero!) 

          --------------------------------------------------------
          MASS-WEIGHTED PROJECTED HESSIAN (Hartree/Bohr/Bohr/Kamu)
          --------------------------------------------------------


               1            2            3
   ----- ----- ----- ----- -----
    1    0.00000D+00
    2    0.00000D+00  0.00000D+00
    3    0.00000D+00  0.00000D+00  0.00000D+00

 center of mass
 --------------
 x =   0.00000000 y =   0.00000000 z =   0.00000000

 moments of inertia (a.u.)
 ------------------
           0.000000000000           0.000000000000           0.000000000000
           0.000000000000           0.000000000000           0.000000000000
           0.000000000000           0.000000000000           0.000000000000

 Rotational Constants
 --------------------
 A=   0.000000 cm-1  (  0.000000 K)
 B=   0.000000 cm-1  (  0.000000 K)
 C=   0.000000 cm-1  (  0.000000 K)


 Temperature                      =   298.15K
 frequency scaling parameter      =   1.0000


 Atom                              

 Zero-Point correction to Energy  =    0.000 kcal/mol  (  0.000000 au)
 Thermal correction to Energy     =    0.888 kcal/mol  (  0.001416 au)
 Thermal correction to Enthalpy   =    1.481 kcal/mol  (  0.002359 au)

 Total Entropy                    =   26.003 cal/mol-K
   - Translational                =   26.003 cal/mol-K (mol. weight =   1.0078)
   - Rotational                   =    0.000 cal/mol-K (symmetry #  =        1)
   - Vibrational                  =    0.000 cal/mol-K

 Cv (constant volume heat capacity) =    2.979 cal/mol-K
   - Translational                  =    2.979 cal/mol-K
   - Rotational                     =    0.000 cal/mol-K
   - Vibrational                    =    0.000 cal/mol-K



          -------------------------------------------------
          NORMAL MODE EIGENVECTORS IN CARTESIAN COORDINATES
          -------------------------------------------------
             (Projected Frequencies expressed in cm-1)

                    1           2           3
 
 P.Frequency        0.00        0.00        0.00
 
           1     0.00000     0.00000     0.00000
           2     0.00000     0.00000     0.00000
           3     0.00000     0.00000     0.00000
 vib:animation  F

 Task  times  cpu:        0.9s     wall:        1.0s
'''
   proton[25] = "NO DATA"
   proton[26] = "NO DATA"
   proton[27] = "NO DATA"
   proton[28] = "NO DATA"

   proton[35] = 0
   proton[41] = "Tissandier et al."
   proton[42] = 0
   proton[43] = None
   proton[53] = None
   proton[60] = "NO DATA"
   proton[64] = None
   proton[65] = None
   
   return proton




###########################################
#                                         #
#            ascii_plotter                #
#                                         #
###########################################
maxrow_ascii = 30
maxcol_ascii = 75
shift1_ascii = 2
shift2_ascii = 11
#maxcol_ascii = 86
xmin_ascii = 0.0
ymin_ascii = 0.0
xmax_ascii = 1.0
ymax_ascii = 1.0
def ascii_xscale(x):
   return int(round((x-xmin_ascii)*(maxcol_ascii-1)/(xmax_ascii-xmin_ascii)))

def ascii_yscale(y):
   return int(round((y-ymax_ascii)*(maxrow_ascii-1)/(ymin_ascii-ymax_ascii)))

def ascii_plotter(x,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,plotzero):
   global xmin_ascii
   global ymin_ascii
   global xmax_ascii
   global ymax_ascii

   xmin_ascii = xmin
   ymin_ascii = ymin
   xmax_ascii = xmax
   ymax_ascii = ymax
   shift_ascii = shift1_ascii+shift2_ascii
   point = []
   for k in range(maxrow_ascii):
      row = [' ']*(maxcol_ascii+shift_ascii)
      point.append(row)

   ### set y-axis ###
   for j in range(maxrow_ascii):
      point[j][shift1_ascii+10] = ":"

   if ((ascii_xscale(0.0)<(maxcol_ascii-1)) and (ascii_xscale(0.0)>0)):
      for j in range(maxrow_ascii):
         point[j][shift_ascii-1+ascii_xscale(0.00)] = "." 

   ### set x-axis ###
   for i in range(shift_ascii,maxcol_ascii+shift_ascii):
      point[ascii_yscale(0.0)][i] = "."


   ### set ylabels ###
   nstru = "%10.3e" % ymax
   nstrd = "%10.3e" % ymin
   for i in range(10):
      point[0][shift1_ascii+i] = nstru[i]
      point[maxrow_ascii-1][shift1_ascii+i] = nstrd[i]
   if ((ascii_yscale(0.0)<(maxrow_ascii-1)) and (ascii_yscale(0.0)>0)):
      point[ascii_yscale(0.00)][shift1_ascii+0]  = " "
      point[ascii_yscale(0.00)][shift1_ascii+1]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+2]  = "."
      point[ascii_yscale(0.00)][shift1_ascii+3]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+4]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+5]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+6]  = "e"
      point[ascii_yscale(0.00)][shift1_ascii+7]  = "+"
      point[ascii_yscale(0.00)][shift1_ascii+8]  = "0"
      point[ascii_yscale(0.00)][shift1_ascii+9] = "0"

   ### set ylabel ###
   jj = (maxrow_ascii-len(ylabel))/2
   for j in range(len(ylabel)):
       point[jj+j][0] = ylabel[j]

   ### plot points ###
   n = len(x)
   if (plotzero):
      for j in range(len(y)):
         s = symbols[j]
         for i in range(n):
            u = ascii_xscale(x[i])
            v = ascii_yscale(y[j][i])
            point[v][shift_ascii+u] = s
   else:
      yzero = ascii_yscale(0.0)
      for j in range(len(y)):
         s  = symbols[j]
         u  = ascii_xscale(x[0])
         v  = ascii_yscale(y[j][0])
         va = ascii_yscale(y[j][1])
         if ((v!=yzero) and (va!=yzero)): point[v][shift_ascii+u] = s
         for i in range(1,n-1):
            u  = ascii_xscale(x[i])
            vb = ascii_yscale(y[j][i-1])
            v  = ascii_yscale(y[j][i])
            va = ascii_yscale(y[j][i+1])
            if ((v!=yzero) and (vb!=yzero) and (va!=yzero)):
               point[v][shift_ascii+u] = s
         u  = ascii_xscale(x[n-1])
         vb = ascii_yscale(y[j][n-2])
         v  = ascii_yscale(y[j][n-1])
         if ((v!=yzero) and (vb!=yzero)): point[v][shift_ascii+u] = s
         


   msg = "\n"
   for i in range(shift_ascii+(maxcol_ascii-len(title))/2): msg += " " 
   msg += title+ "\n\n"
   for row in point:
      for col in row:
         msg += col
      msg += "\n"


   ### set xlabels ###
   for i in range(shift_ascii-1): msg += " "
   msg += "|"
   for i in range(shift_ascii+1,shift_ascii+(maxcol_ascii)/2): msg += "-"
   msg += "|"
   for i in range(shift_ascii+(maxcol_ascii)/2+1,(maxcol_ascii+shift_ascii)): msg += "-"
   msg += "|\n"
   msg += "      %10.3e                           %10.3e                            %10.3e\n" % (xmin_ascii,0.5*(xmin_ascii+xmax_ascii),xmax_ascii)
   msg += "\n"
   for i in range(shift_ascii+(maxcol_ascii-len(xlabel))/2): msg += " "
   msg += xlabel +"\n"
      #write(lunit,900) ,XL,(XL+XR)/2.0d0,XR
      #write(lunit,MyformatX) Xlabel
  #900 format(5x,E10.3,27x,E10.3,27x,E10.3)


   return msg






#############################################
#                                           #
#             clean_smiles                  #
#                                           #
#############################################

def clean_smiles(smiles):
   smiles2 = smiles[:]
   #tags = ['^','mult','theory','xc','solvation_type','basis','theory_base','xc_base','basis_base','geometry_generation']
   tags = ['^','mult','theory','xc','solvation_type','basis','theory_base','xc_base','basis_base','geometry_generation','calculation_type','rbond','rgroup']
   for tt in tags:
      if tt in smiles2:
         tag1 = tt+"{"
         tag2 = "}"
         msg2 = smiles2.split(tag1)
         msg3 = msg2[1].split(tag2)[0]
         smiles2 = smiles2.replace(tag1+msg3+tag2,"")
   return smiles2

#############################################
#                                           #
#             addspaces_reaction            #
#                                           #
#############################################
def addspaces_reaction(reaction):
   #tags = ['^','mult','theory','xc','solvation_type','basis','calculation_type','property','priority','geometry_generation','SHE']
   tags = ['^','mult','theory','xc','solvation_type','basis','calculation_type','property','priority','geometry_generation','SHE','rbond','rgroup']
   reaction2 = reaction[:]
   if (reaction2.find(">")!=-1):
      reaction2 = reaction2.replace(">","")
   if (reaction2.find("-->")==-1):
      reaction2 = reaction2.replace("--","-->")

   for tag1 in tags: reaction2 = reaction2.replace(tag1," " + tag1)

   ### replace [ SHE] with [SHE] ###
   reaction2 = re.sub("\[\s*SHE\s*\]","[SHE]",reaction2)

   ### look for xc{mp2} and xc{ccsd(t)} ###
   reaction2 = reaction2.replace("xc{mp2}","theory{mp2}")
   reaction2 = reaction2.replace("xc{ccsd(t)}","theory{ccsd(t)}")
   return reaction2

#############################################
#                                           #
#             expand_reaction               #
#                                           #
#############################################
def expand_reaction(reaction):
   reaction2 = reaction
   if '~' in reaction:
      optiontag = reaction2.split('~')[1].strip()
      rr = reaction2.split('~')[0].strip()
      rr = rr.replace("\t"," ")
      rr = rr.replace("\n"," ")
      rr = rr.replace('\xc2', ' ')
      rr = rr.replace('\xa0', ' ')
      rr = rr.replace(" + "," " + optiontag + " + ")
      rr = rr.replace("-->"," " + optiontag + " --> ")
      rr = rr + " " + optiontag
      reaction2 = rr
   return reaction2



#############################################
#                                           #
#             fetch_esmiles_full            #
#                                           #
#############################################
def fetch_esmiles_full(hup,dbfile,table,esmiles):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   esmiles1=esmiles.strip()
   ss = esmiles1.split()

   smiles  = clean_smiles(ss[0])
   csmiles = cannonicalsmiles(smiles)

   inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
   inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

   xyzfile = wrkdir + "/" + tmpxyz1
   smiles2xyz(smiles,xyzfile)
   inchi2    = xyz2InChI(xyzfile)     #inchi does not include charge
   inchikey2 = xyz2InChIKey(xyzfile)  #inchikey does not include charge
   mformula = xyz_molecular_formula(xyzfile)

   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(mformula)
   wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?) and mformula=?"

   if 'theory{' in esmiles: 
      theory = esmiles.split('theory{')[1].split('}')[0]
      checklist.append(theory)
      wherestr += " and theory=?"

   if 'xc{' in esmiles:
      xc  = esmiles.split('xc{')[1].split('}')[0]
      checklist.append(xc)
      wherestr += " and xc=?"

   if 'basis{' in esmiles:
      basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
      if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
      if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
      checklist.append(basis)
      wherestr += " and basis=?"

   if '^{' in esmiles:
      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      checklist.append(charge)
      wherestr += " and charge=?"

   if 'mult{' in esmiles:
      mult = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      checklist.append(mult)
      wherestr += " and mult=?"

   if 'solvation_type' in esmiles:
      solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      checklist.append(solvation_type)
      wherestr += " and solvation_type=?"

   if 'calculation_type' in esmiles:
      calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
      if solvation_type.lower()=='none':
         calculation_type = calculation_type.replace('c','')
      checklist.append(calculation_type)
      wherestr += " and calculation_type=?"

   wherestr2 = " where id=? ;"

   if (issqlite3):
      sqlcheck = "select id from " + table + wherestr
      sqlcheck2 = "select * from " + table + wherestr2
   else:
      sqlcheck = "select id from " + table + wherestr.replace('?','%s')
      sqlcheck2 = "select * from " + table + wherestr2.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   rows2 = []
   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)>0):
         for row in rows:
            checklist2 = [row[0]]
            cur.execute(sqlcheck2,checklist2)
            tmp = cur.fetchall()
            rows2.append(tmp[0])
   dbcon.close()

   return rows2
 except:
   return []


def quote_comma_name(name):
   if ',' in name:
      cc = "\"" + name + "\""
   else:
      cc = name
   return cc

def fetch_csv_esmiles_full(hup,dbfile,table,columns_list,esmiles_list):
   eoln = "\n"
   csv_msg = "csv data block:" + eoln + eoln
   for c in columns_list:
      csv_msg += quote_comma_name(c) + ","
   csv_msg = csv_msg.rstrip(",")
   csv_msg += eoln

   for esmiles in esmiles_list:
      rows = fetch_esmiles_full(hup,dbfile,table,esmiles)
      for molecule in rows:
         msg = ""
         for column in columns_list:
            if (column.lower()=='id'):                msg += "%d," % molecule[0]
            if (column.lower()=='iupac'):             msg += "%s," % quote_comma_name(molecule[1])
            if (column.lower()=='mformula'):          msg += "%s," % molecule[2]
            if (column.lower()=='inchi'):             msg += "%s," % quote_comma_name(molecule[3])
            if (column.lower()=='smiles'):            msg += "%s," % molecule[4]
            if (column.lower()=='csmiles'):           msg += "%s," % molecule[5]
            if (column.lower()=='esmiles'):           msg += "%s," % quote_comma_name(molecule[6])
            if (column.lower()=='program'):           msg += "%s," % molecule[7]
            if (column.lower()=='calculation_type'):  msg += "%s," % molecule[8]
            if (column.lower()=='theory'):            msg += "%s," % molecule[9]
            if (column.lower()=='xc'):                msg += "%s," % molecule[10]
            if (column.lower()=='basis'):             msg += "%s," % quote_comma_name(molecule[11])
            if (column.lower()=='charge'):            msg += "%d," % molecule[12]
            if (column.lower()=='mult'):              msg += "%d," % molecule[13]
            if (column.lower()=='energy'):            msg += "%.6f," % molecule[14]
            if (column.lower()=='enthalpy'):          msg += "%.6f," % molecule[15]
            if (column.lower()=='entropy'):           msg += "%.3f," % molecule[16]
            if (column.lower()=='solvation_type'):    msg += "%s,"   % molecule[17]
            if (column.lower()=='solvation_energy'):  msg += "%.3f," % molecule[18]
            if (column.lower()=='sitkoff'):           msg += "%.3f," % molecule[19]
            if (column.lower()=='honig'):             msg += "%.3f," % molecule[20]
            if (column.lower()=='asa'):               msg += "%.3f," % molecule[21]
            if (column.lower()=='sav'):               msg += "%.3f," % molecule[22]
            if (column.lower()=='xyz_blob'):          msg += "%s,"   % molecule[23]
            if (column.lower()=='frequencies_blob'):  msg += "%s,"   % molecule[24]
            if (column.lower()=='eigenvalues_blob'):  msg += "%s,"   % molecule[25]
            if (column.lower()=='radial_distribution_blob'): msg += "%s," % molecule[26]
            if (column.lower()=='power_spectrum_blob'):      msg += "%s," % molecule[27]
            if (column.lower()=='filename'):                 msg += "%s," % quote_comma_name(molecule[28])
         msg = msg.rstrip(",")
         csv_msg += msg + eoln

   csv_msg += eoln + ":csv data block" + eoln

   return csv_msg


#############################################
#                                           #
#             fetch_jobinfo                 #
#                                           #
#############################################
def fetch_jobinfo(hup,dbfile,table,id):
 try:
   eoln = "\n"
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False


   checklist = []
   checklist.append(id)

   wherestr =  " where Id=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()


   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg  = "jobinfo: Id=%d, iupac=%s, filename=%s\n\n" % (id,molecule[1],molecule[28])
      cmd1 = "scp " + molecule[28] + " " + wrkdir +"/nwout.txt"
      print "cmd1=",cmd1
      pexpect_command(cmd1,archivepassword)
      offile = open(wrkdir+"/nwout.txt","r")
      ttt = offile.read()
      offile.close()
      uuu = ttt.split("Job information")[1].split("Memory information")[0]
      uuu = uuu.rstrip()
      msg += "           Job information" + eoln
      msg += uuu + eoln
      msg += "    program version = %s\n\n" % molecule[7]
      msg += ":jobinfo Id=%d, iupac=%s, filename=%s\n" % (id,molecule[1],molecule[28])

   else:
      msg = "jobinfo:\n no nwout file for Id=%d\n:jobinfo\n" % id

   return msg

 except:
   return "fetch_jobinfo failed\n"





#############################################
#                                           #
#             fetch_nwout                   #
#                                           #
#############################################
def fetch_nwout(hup,dbfile,table,id):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)

   wherestr =  " where Id=?"

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg = "nwout file for Id=%d\n\n" % id
      msg += molecule[28]
      msg += "\n\n"
      cmd1 = "scp " + molecule[28] + " " + wrkdir +"/nwout.txt"
      print "cmd1=",cmd1
      pexpect_command(cmd1,archivepassword)
      cmd2 = "cat " + wrkdir +"/nwout.txt"
      print "cmd2=",cmd2
      result = subprocess.check_output(cmd2,shell=True)
      msg += result
   else:
      msg = "no nwout file for Id=%d\n\n" % id

   return msg

 except:
   return "fetch_nwout failed\n"




#############################################
#                                           #
#             fetch_xyz                     #
#                                           #
#############################################

def fetch_xyz(hup,dbfile,table,id):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)
   wherestr =  " where Id=?"
   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### id found? ###
   if (len(rows)>0):
      molecule = rows[0]
      msg = "xyz data for Id=%d\n\n" % id
      msg += molecule[23]
   else:
      msg = "no xyz data for Id=%d\n\n" % id

   return msg

#######################################  fetch_eig functions ##################################
MAX_EIGENVALUE = 2.5

###########################################
#                                         #
#         ascii_eig_level                 #
#                                         #
###########################################
def ascii_eig_level(p,n):
   level  = "          "
   if ((p==1) and (n==0)): level = "++++++++++"
   if ((p==2) and (n==0)): level = "++++  ++++"
   if ((p==3) and (n==0)): level = "+++ ++ +++"
   if ((p==4) and (n==0)): level = "++ ++ ++ +"
   if ((p==5) and (n==0)): level = "+ + + + ++"
   if ((p>5)  and (n==0)):
      num = "%d" % p
      if   (len(num)==1):
         level = num + "  + + + +"
      elif (len(num)==2):
         level = num + " + + + +"
      elif (len(num)==3):
         level = num + "+ + + +"
      elif (len(num)==4):
         level = num + " + + +"
      elif (len(num)==5):
         level = num + "+ + +"
      elif (len(num)==6):
         level = num + " + +"
      else:
         level = ">>>+ + + +"

   if ((p==0) and (n==1)): level = "----------"
   if ((p==0) and (n==2)): level = "----  ----"
   if ((p==0) and (n==3)): level = "--- -- ---"
   if ((p==0) and (n==4)): level = "-- -- -- -"
   if ((p==0) and (n==5)): level = "- - - - --"
   if ((p==0) and (n>5) ):
      num = "%d" % n
      if   (len(num)==1):
         level = num + "  - - - -"
      elif (len(num)==2):
         level = num + " - - - -"
      elif (len(num)==3):
         level = num + "- - - -"
      elif (len(num)==4):
         level = num + " - - -"
      elif (len(num)==5):
         level = num + "- - -"
      elif (len(num)==6):
         level = num + " - -"
      else:
         level = ">>>- - - -"

   if ((p>0) and (n>0)):
      np = n + p
      if (np==1): level = "**********"
      if (np==2): level = "****  ****"
      if (np==3): level = "*** ** ***"
      if (np==4): level = "** ** ** *"
      if (np==5): level = "* * * * **"
      if (np>5 ):
         num = "%d" % np
         if   (len(num)==1):
            level = num + "  * * * *"
         elif (len(num)==2):
            level = num + " * * * *"
         elif (len(num)==3):
            level = num + "* * * *"
         elif (len(num)==4):
            level = num + " * * *"
         elif (len(num)==5):
            level = num + "* * *"
         elif (len(num)==6):
            level = num + " * *"
         else:
            level = ">>>* * * *"

   return level

###########################################
#                                         #
#      ascii_unrestricted_eig_plot        #
#                                         #
###########################################
def ascii_unrestricted_eig_plot(eigup,occup,eigdn,occdn):
   maxrow = 50
   maxcol = 80
   point = []
   for k in range(maxrow):
      row = [' ']*maxcol
      point.append(row)

   emin0 = min(eigup+eigdn)*27.2114
   emax0 = max(eigup+eigdn)*27.2114

   emin = min(eigup)
   emax = max(eigup)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eigup)):
      e = eigup[k]
      o = occup[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+5] = tt[k]

   if (ehomo>-8.0e6):
      yscale = int(round((ehomo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'HOMO=%7.2f eV' % ehomo
      for k in range(15): point[yscale][k+0] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'LUMO=%7.2f eV' % elumo 
      for k in range(15): point[yscale][k+25] = tt[k]

      yscale = int(round((emax-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = '%7.2f eV' % emax 
      for k in range(10): point[yscale][k+26] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eigup)):
      e = eigup[k]*27.2114
      o = occup[k]
      yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
      if (o > 1.0e-3):
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1
         
   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+15]  = level[j]

   #for k in range(len(eigup)):
   #   e = eigup[k]*27.2114
   #   o = occup[k]
   #   yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
   #   if (o > 1.0e-3): 
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(15,23):
   #      point[yscale][j]  = cch


   emin = min(eigdn)
   emax = max(eigdn)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eigdn)):
      e = eigdn[k]
      o = occdn[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax0)*(maxrow-1)/(emin0-emax0)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+42] = tt[k]

   if (ehomo>-8.0e6):
      yscale = int(round((ehomo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'HOMO=%7.2f eV' % ehomo
      for k in range(15): point[yscale][k+37] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = 'LUMO=%7.2f eV' % elumo
      for k in range(15): point[yscale][k+62] = tt[k]

      yscale = int(round((emax-emax0)*(maxrow-1)/(emin0-emax0)))
      tt = '%7.2f eV' % emax
      for k in range(10): point[yscale][k+63] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eigdn)):
      e = eigdn[k]*27.2114
      o = occdn[k]
      yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
      if (o > 1.0e-3):
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1

   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+52]  = level[j]


   #for k in range(len(eigdn)):
   #   e = eigdn[k]*27.2114
   #   o = occdn[k]
   #   yscale = int(round((e-emax0)*(maxrow-1)/(emin0-emax0)))
   #   if (o > 1.0e-3):
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(50,58):
   #      point[yscale][j]  = cch


   msg  = '                      Unrestricted Eigevalue Spectra\n\n'
   msg += '                alpha                               beta\n'
   for row in point:
      for col in row:
         msg += col
      msg += "\n"


   ### plot the density of states  ###
   emin0 -= 2.0
   emax0 += 2.0
   sigma  = 0.5 
   ngrid  = 501
   pi     = 4.0*atan(1.0)
   dw     = (emax0-emin0)/float(ngrid-1)
   scale  = 1.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   ww = []
   up_filled  = []
   up_virtual = []
   dn_filled  = []
   dn_virtual = []
   for i in range(ngrid):
      w = emin0 + i*dw
      ww.append(w)
      pp = 0.0
      qq = 0.0
      for k in range(len(eigup)):
         e = eigup[k]*27.2114
         o = occup[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp += tt
         else:
            qq += tt
      up_filled.append(pp)
      up_virtual.append(qq)

      pp = 0.0
      qq = 0.0
      for k in range(len(eigdn)):
         e = eigdn[k]*27.2114
         o = occdn[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp -= tt
         else:
            qq -= tt
      dn_filled.append(pp)
      dn_virtual.append(qq)

   y = (up_filled,up_virtual,dn_filled,dn_virtual)
   symbols = ('*','#','o','@')
   title = 'Density of States (sigma=%.1f eV)' % sigma
   xlabel = 'Energy (eV)'
   ylabel = 'DOS'
   xmin = emin0
   xmax = emax0
   ymin = min(up_filled+up_virtual+dn_filled+dn_virtual)
   ymax = max(up_filled+up_virtual+dn_filled+dn_virtual)
   msg += "\n"
   msg += ascii_plotter(ww,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)


   return msg




#########################################
#                                       #
#      ascii_restricted_eig_plot        #
#                                       #
#########################################

def ascii_restricted_eig_plot(eig,occ):
   maxrow = 50
   maxcol = 75
   point = []
   for k in range(maxrow):
      row = [' ']*maxcol
      point.append(row)

   emin = min(eig)
   emax = max(eig)
   elumo = +9.0e6
   ehomo = -9.0e6
   for k in range(len(eig)):
      e = eig[k]
      o = occ[k]
      if (o>1.0e-3):
         if (e>ehomo): ehomo = e
      else:
         if (e<elumo): elumo = e

   e = 0.0
   emin  *= 27.2114
   emax  *= 27.2114
   ehomo *= 27.2114
   elumo *= 27.2114

   yscale = int(round((emin-emax)*(maxrow-1)/(emin-emax)))
   tt = '%7.2f eV' % emin
   for k in range(10): point[yscale][k+5] = tt[k]
   yscale = int(round((ehomo-emax)*(maxrow-1)/(emin-emax)))
   tt = 'HOMO=%7.2f eV' % ehomo
   for k in range(15): point[yscale][k+0] = tt[k]

   if (elumo<8.0e6):
      yscale = int(round((elumo-emax)*(maxrow-1)/(emin-emax)))
      tt = 'LUMO=%7.2f eV' % elumo 
      for k in range(15): point[yscale][k+27] = tt[k]
      yscale = int(round((emax-emax)*(maxrow-1)/(emin-emax)))
      tt = '%7.2f eV' % emax 
      for k in range(10): point[yscale][k+27] = tt[k]

   ## count eigs based on yscale location
   nstates = [0]*maxrow
   pstates = [0]*maxrow
   for k in range(len(eig)):
      e = eig[k]*27.2114
      o = occ[k]
      yscale = int(round((e-emax)*(maxrow-1)/(emin-emax)))
      if (o > 1.0e-3): 
         pstates[yscale] += 1
      else:
         nstates[yscale] += 1

   for k in range(maxrow):
      level = ascii_eig_level(pstates[k],nstates[k])
      if (level != "          "):
         for j in range(10):
            point[k][j+16]  = level[j]

   #for k in range(len(eig)):
   #   e = eig[k]*27.2114
   #   o = occ[k]
   #   yscale = int(round((e-emax)*(maxrow-1)/(emin-emax)))
   #   if (o > 1.0e-3): 
   #      cch = '+'
   #   else:
   #      cch = '-'
   #   for j in range(16,26):
   #      point[yscale][j]  = cch

   msg = '          Eigevalue Spectra\n'
   for row in point:
      for col in row:
         msg += col
      msg += "\n"


   ### plot the density of states  ###
   emin -= 2.0
   emax += 2.0
   sigma  = 0.5
   ngrid  = 501
   pi     = 4.0*atan(1.0)
   dw     = (emax-emin)/float(ngrid-1)
   scale  = 2.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   ww = []
   rs_filled  = []
   rs_virtual = []
   for i in range(ngrid):
      w = emin + i*dw
      ww.append(w)
      pp = 0.0
      qq = 0.0
      for k in range(len(eig)):
         e = eig[k]*27.2114
         o = occ[k]
         x2 = (w-e)**2
         tt = scale*exp(-omega2*x2)
         if (o>1.0e-6):
            pp += tt
         else:
            qq += tt
      rs_filled.append(pp)
      rs_virtual.append(qq)

   y = (rs_filled,rs_virtual)
   symbols = ('*','#')
   title = 'Density of States (sigma=%.1f eV)' % sigma
   xlabel = 'Energy (eV)'
   ylabel = 'DOS'
   xmin = emin
   xmax = emax
   ymin = min(rs_filled+rs_virtual)
   ymax = max(rs_filled+rs_virtual)
   msg += "\n"
   msg += ascii_plotter(ww,y,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)


   return msg

def mymedian(x):
    if len(x)%2 != 0:
        return sorted(x)[len(x)/2]
    else:
        midavg = (sorted(x)[len(x)/2] + sorted(x)[len(x)/2-1])/2.0
        return midavg

#############################################
#                                           #
#             fetch_eig                     #
#                                           #
#############################################
def fetch_eig(hup,dbfile,table,id):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   checklist = []
   checklist.append(id)
   wherestr =  " where Id=?"
   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### id found? ###
   if (len(rows)>0):
      msg = "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"
      msg += "+-----------------+\n"
      msg += "| Eigenvalue Data |\n"
      msg += "+-----------------+\n"
      msg += "Id       = %d\n" % (rows[0][0])
      msg += "iupac    = %s\n" % (rows[0][1])
      msg += "mformula = %s\n" % (rows[0][2])
      msg += "InChI    = %s\n" % (rows[0][3])
      msg += "smiles   = %s\n" % (rows[0][4])
      msg += "esmiles  = %s\n" % (rows[0][6])
      msg += "theory   = %s\n" % (rows[0][9])
      msg += "xc       = %s\n" % (rows[0][10])
      msg += "basis    = %s\n" % (rows[0][11])
      msg += "charge   = %d\n" % (rows[0][12])
      msg += "mult     = %d\n" % (rows[0][13])
      msg += "solvation_type = %s\n" % (rows[0][17])
      msg += "twirl webpage  = %s\n" % (smiles2twirl(rows[0][4]))
      msg += "image webpage  = %s\n\n" % (smiles2image(rows[0][4]))
      msg += "chemical_structure_asciiart  = </pre> <pre style=\"font-size:0.5em;color:magenta\"> \n"
      msg += stripWARNINGS(rows[0][34])
      msg += "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"

      eigall = rows[0][25]
      #restricted = eigall.split("\n")[0].strip() == "restricted"
      eigtype = eigall.split("\n")[0].strip()

      ### rdft calculation ###
      if (eigtype=="restricted"):
         eig = []
         occ = []
         for line in eigall.strip().split("\n")[1:]:
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            if (abs(evalnum(e))<MAX_EIGENVALUE):
               eig.append(evalnum(e))
               occ.append(evalnum(o))
         emid = mymedian(eig)
         peig = []
         pocc = []
         for k in range(len(eig)):
            if (eig[k]>(emid-2.0)):
               peig.append(eig[k])
               pocc.append(occ[k])
         msg += ascii_restricted_eig_plot(peig,pocc)
         msg += "\n"
         msg += "spin            eig      occ\n"
         msg += "----------------------------\n"
         for k in range(len(eig)):
           msg += "restricted  %7.2f  %7.2f\n" % (eig[k]*27.2114,occ[k])
         msg += "\n"

      ### udft calculation ###
      elif (eigtype=="alpha"):
         eigup = []
         occup = []
         for line in  eigall.split('beta')[0].strip().split("\n")[1:]:
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            if (abs(evalnum(e))<MAX_EIGENVALUE):
               eigup.append(evalnum(e))
               occup.append(evalnum(o))
         emidup = mymedian(eigup)
         peigup = []
         poccup = []
         for k in range(len(eigup)):
            if (eigup[k]>(emidup-2.0)):
               peigup.append(eigup[k])
               poccup.append(occup[k])

         eigdn = []
         occdn = []
         for line in  eigall.split('beta')[1].strip().split("\n"):
            e = line.split("E=")[1].replace("D","E")
            o = line.split("E=")[0].split("Occ=")[1].replace("D","E")
            if (abs(evalnum(e))<MAX_EIGENVALUE):
               eigdn.append(evalnum(e))
               occdn.append(evalnum(o))
         emiddn = mymedian(eigdn)
         peigdn = []
         poccdn = []
         for k in range(len(eigdn)):
            if (eigdn[k]>(emiddn-2.0)):
               peigdn.append(eigdn[k])
               poccdn.append(occdn[k])

         msg += ascii_unrestricted_eig_plot(peigup,poccup,peigdn,poccdn)
         msg += "\n"
         msg += "spin            eig      occ\n"
         msg += "----------------------------\n"
         for k in range(len(eigup)):
            msg += "alpha       %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
         msg += "\n"
         for k in range(len(eigdn)):
            msg += "beta        %7.2f  %7.2f\n" % (eigdn[k]*27.2114,occdn[k])
         msg += "\n"

      ### pspw calculation ###
      elif (eigtype=="orbital energies:"):
         eigup = []
         occup = []
         eigdn = []
         occdn = []
         ff    = 1.0
         for line in eigall.strip().split("\n")[1:]:
            if "virtual" in line:
               ff = 0.0
            else:
               ss = line.split()
               e = ss[0]
               eigup.append(evalnum(e))
               occup.append(ff)
               if (len(ss)>3):
                  e2 = ss[3]
                  eigdn.append(evalnum(e2))
                  occdn.append(ff)

         ## restricted calculation ###
         if (len(eigdn)==0):
            for k in range(len(occup)):
               occup[k] *= 2.0
            msg += ascii_restricted_eig_plot(eigup,occup)
            msg += "\n"
            msg += "spin            eig      occ\n"
            msg += "----------------------------\n"
            for k in range(len(eigup)):
               msg += "restricted  %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
         else:
            msg += ascii_unrestricted_eig_plot(eigup,occup,eigdn,occdn)
            msg += "\n"
            msg += "spin            eig      occ\n"
            msg += "----------------------------\n"
            for k in range(len(eigup)):
               msg += "alpha       %7.2f  %7.2f\n" % (eigup[k]*27.2114,occup[k])
            msg += "\n"
            for k in range(len(eigdn)):
               msg += "beta        %7.2f  %7.2f\n" % (eigdn[k]*27.2114,occdn[k])
            msg += "\n"

  

      msg += "</pre> <pre style=\"font-size:0.6em;color:blue\"> \n"
   else:
      msg = "no eigenvalue data for Id=%d\n\n" % id

   return msg

#######################################  fetch_eig functions ##################################

#######################################  fetch_freq functions ##################################


def simpson(h,f):
   n = len(f)
   ss = f[0] + f[n-1]
   for i in range(1,n-1,2): ss += (4.0*f[i])
   for i in range(2,n-2,2): ss += (2.0*f[i])
   return ss*h/3.0


#############################################
#                                           #
#           model_energies_frequencies      #
#                                           #
#############################################

def model_correct_frequencies(frequency_data,sigma=50.0,threshfreq=500.0,minfreq=0.1,maxfreq=4500.0):
   #maxfreq = 4500.0
   #minfreq = 0.1
   #threshfreq = 500.0
   ngrid   = 501
   pi      = 4.0*atan(1.0)

   all_lines2 = frequency_data[24].split("\n")
   freqs = []
   for line in all_lines2:
      if (line.find("P.Frequency") != -1):
         freqs += [ eval(s) for s in line.split()[1:]]

   nfreqs  = 0
   nlowest = 0
   for f in freqs:
      if (f<(-0.01)): nfreqs += 1
      if ((f>minfreq) and (f<threshfreq)): nlowest += 1

   exact_dos_norm = len(freqs)-6.0

   dw  = ((maxfreq-minfreq)/float(ngrid-1))
   ww  = []


   scale  = 1.0/(sigma*sqrt(2.0*pi))
   omega2 = 1.0/(2.0*sigma*sigma)
   dos = []
   dos_lowest = []
   for i in range(ngrid):
      w = minfreq + i*dw
      ww.append(w)
      pp = 0.0
      pplow = 0.0
      low = 0
      for f in freqs:
         if (f>minfreq):
            x2 = (w-f)**2
            tt = scale*exp(-omega2*x2)
            pp += tt
            if (low<nlowest):
               pplow += tt
               low += 1
      dos.append(pp)
      dos_lowest.append(pplow)

   dos_fixed = []
   dos_norm = simpson(dw,dos)
   dos_lowest_norm = simpson(dw,dos_lowest)
   if (dos_lowest_norm > 1.0e-8):
      fac = (exact_dos_norm-dos_norm)/dos_lowest_norm
   else:
      fac = 0.0
   for i in range(ngrid):
      pp = dos[i] + fac*dos_lowest[i]
      dos_fixed.append(pp)

   dos_fixed_norm = simpson(dw,dos_fixed)


   ### get database energies ###
   energy           = frequency_data[14]
   enthalpy         = frequency_data[15]
   entropy          = frequency_data[16]
   solvation_type   = frequency_data[17]
   solvation_energy = frequency_data[18]
   sitkoff          = frequency_data[19]
   if solvation_type=='COSMO': solvation_energy = -solvation_energy + sitkoff

   temp = 298.15
   AUKCAL=627.509469
   c=2.998e10
   h=6.626e-27
   kgas=1.3807e-16
   Rgas = 1.98630/1000.00/AUKCAL


   ethermal0 = 0.0
   Svib0     = 0.0
   for w in freqs:
      if (w>0.1):
         thetav = w*(h*c/kgas)
         if (temp>0.0):
            xdum   = exp(-thetav/temp)
         else:
            xdum = 0.0
         xdum   = xdum/(1.00-xdum)
         ethermal0 +=  (thetav*(0.50 + xdum)*Rgas)
         xdum   = thetav/temp
         if (xdum>0.0):
            Svib0 += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)

   ### thermo for original DOS ###
   ethermal = 0.0
   Svib     = 0.0
   for i in range(ngrid):
      w = ww[i]
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal +=  (thetav*(0.50 + xdum)*Rgas)*dos[i]*dw
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos[i]*dw

   ### thermo for model DOS ###
   ethermal_fixed = 0.0
   Svib_fixed     = 0.0
   for i in range(ngrid):
      w = ww[i]
      thetav = w*(h*c/kgas)
      xdum   = exp(-thetav/temp)
      xdum   = xdum/(1.00-xdum)
      ethermal_fixed +=  (thetav*(0.50 + xdum)*Rgas)*dos_fixed[i]*dw
      xdum   = thetav/temp
      if (xdum>0.0):
         Svib_fixed += ((xdum/(exp(xdum)-1.00) - log(1.00-exp(-xdum)))*Rgas)*dos_fixed[i]*dw

   gas_enthalpy0      = enthalpy
   gas_enthalpy       = enthalpy - ethermal0 + ethermal
   gas_enthalpy_fixed = enthalpy - ethermal0 + ethermal_fixed

   gas_entropy0       = entropy
   gas_entropy        = entropy  + (Svib - Svib0)*(AUKCAL*1000.0)
   gas_entropy_fixed  = entropy  + (Svib_fixed - Svib0)*(AUKCAL*1000.0)

   #gas_free_energy0      = gas_enthalpy0      - temp*gas_entropy0
   #gas_free_energy       = gas_enthalpy       - temp*gas_entropy
   #gas_free_energy_fixed = gas_enthalpy_fixed - temp*gas_entropy_fixed

   #sol_free_energy0      = gas_free_energy0      + solvation_energy/AUKCAL
   #sol_free_energy       = gas_free_energy       + solvation_energy/AUKCAL
   #sol_free_energy_fixed = gas_free_energy_fixed + solvation_energy/AUKCAL

   return (gas_enthalpy_fixed,gas_entropy_fixed)


#######################################  fetch_freq functions ##################################


################################################
#                                              #
#           lowest_energy_esmiles              #
#                                              #
################################################

#returns only the lowest energy row

def lowest_energy_esmiles(rows):
   if (len(rows)>1):
      newrows = []
      emin = 99.99e99

      ### search for lowest energy with no negative frequencies ###
      negative_freq = True
      for molecule in rows:
         if (molecule[14]<emin) and (molecule[35]==0):
            negative_freq = False
            emin = molecule[14]
            molecule_min = molecule

      ### if there are always negative frequencies then just search for lowest energy entry ###
      if (negative_freq):
         for molecule in rows:
            if (molecule[14]<emin):
               emin = molecule[14]
               molecule_min = molecule

      newrows.append(molecule_min)
   else:
      newrows = rows

   return newrows




#############################################
#                                           #
#         fetch_esmiles_base_datafile       #
#                                           #
#############################################

def fetch_esmiles_base_datafile(hup,dbfile,table,esmiles):

 datafile = ''
 if ('ccsd(t)' not in esmiles) and ('mp2' not in esmiles): return datafile

 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())

   ss = esmiles1.split()

   smiles  = clean_smiles(ss[0])
   if "id=" in smiles.lower():
      try:
         smiles = smiles.replace(")","")
         smiles = smiles.replace("]","")
         smiles = smiles.replace("(","")
         smiles = smiles.replace("[","")
         id = evalnum(smiles.split("=")[1].strip())
      except:
         id = 1001
      wherestr =  " where Id=? "
      checklist = []
      checklist.append(id)

   else:
      csmiles = cannonicalsmiles(smiles)
      inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
      inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

      xyzfile = wrkdir + "/" + tmpxyz1
      smiles2xyz(smiles,xyzfile)
      inchi2    = xyz2InChI(xyzfile)    #inchi2 does not include charge
      inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge
      mformula = xyz_molecular_formula(xyzfile)

      if 'theory_base{' in esmiles: theory_base = esmiles.split('theory_base{')[1].split('}')[0]
      if 'xc_base{' in esmiles:     xc_base     = esmiles.split('xc_base{')[1].split('}')[0]
      if 'basis{' in esmiles:       basis_base  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
      if 'basis_base{' in esmiles:  basis_base  = removespace_basis(esmiles.split('basis_base{')[1].split('}')[0])
      charge = smiles2charge(smiles)
      if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      mult = esmiles2mult_set(smiles,charge,esmiles)
      #mult   = smiles2mult(smiles,charge)
      #if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
      if solvation_type.lower()=='none':
         calculation_type = calculation_type.replace('c','')
      if 'ry' in  basis_base.lower():      basis_base = '%.1f Ry' % (evalnum(basis_base.strip().split()[0]))
      if 'hartree' in  basis_base.lower(): basis_base = '%.1f Ry' % (2*evalnum(basis_base.strip().split()[0]))

      print
      print "fetch_esmiles_base_datafile table  =",table
      print "fetch_esmiles_base_datafile inchi  =",inchi
      print "fetch_esmiles_base_datafile inchi2 =",inchi2
      print "fetch_esmiles_base_datafile inchikey  =",inchikey
      print "fetch_esmiles_base_datafile inchikey2 =",inchikey2
      print "fetch_esmiles_base_datafile mformula =",mformula
      print "fetch_esmiles_base_datafile theory=",theory_base
      print "fetch_esmiles_base_datafile xc    =",xc_base
      print "fetch_esmiles_base_datafile basis =",basis_base
      print "fetch_esmiles_base_datafile charge=",charge
      print "fetch_esmiles_base_datafile mult  =",mult
      print "fetch_esmiles_base_datafile solvation_type=",solvation_type
      print "fetch_esmiles_base_datafile calculation_type=",calculation_type

      checklist = []
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(mformula)
      checklist.append(theory_base)
      checklist.append(xc_base)
      checklist.append(basis_base)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(solvation_type)
      checklist.append(calculation_type)

      wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
      wherestr += " and mformula=?"
      wherestr += " and theory=?"
      wherestr += " and xc=?"
      wherestr += " and basis=?"
      wherestr += " and charge=?"
      wherestr += " and mult=?"
      wherestr += " and solvation_type=?"
      wherestr += " and calculation_type=?"

   wherestr2 = " where id=? ;"

   if (issqlite3):
      sqlcheck = "select id from " + table + wherestr
      sqlcheck2 = "select * from " + table + wherestr2
   else:
      sqlcheck = "select id from " + table + wherestr.replace('?','%s')
      sqlcheck2 = "select * from " + table + wherestr2.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   rows2 = []
   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)>0):
         for row in rows:
            checklist2 = [row[0]]
            cur.execute(sqlcheck2,checklist2)
            tmp = cur.fetchall()
            rows2.append(tmp[0])
   dbcon.close()

   rows = lowest_energy_esmiles(rows2)

   ### fetch nwout file from archive ###
   datafile = wrkdir + "/" + tmpnwout
   molecule = rows[0]
   cmd1 = "scp " + molecule[28] + " " + datafile
   print "cmd1=",cmd1
   pexpect_command(cmd1,archivepassword)
   #with open(datafile,"r") as offile:
   #   datafile = offile.read()

 except:
   datafile = ''

 return datafile







#############################################
#                                           #
#             fetch_esmiles                 #
#                                           #
#############################################

def fetch_esmiles(hup,dbfile,table,esmiles,submitrequest=True):
 try:
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_base = ''
   xc_base     = ''
   basis_base  = ''
   basisHZ_base  = ''

   if 'ccsd(t)' in esmiles:
      theory='ccsd(t)';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'mp2' in esmiles:
      theory='mp2';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      theory_base='dft';xc_base='b3lyp';basis_base='6-311++G(2d,2p)'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None';calculation_type='ov'
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO';calculation_type='ovc'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO';calculation_type='ovc'
      basisHZ  = 'aug-cc-pVTZ'
      basisHZ1 = 'crenbl_ecp'
      basisHZ2 = 'Def2-TZVP'
      basisHZ3 = 'stuttgart_rsc_1997'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())
   ss = esmiles1.split()
   print "ESMILES,ESMILES1=",esmiles,esmiles1

   #### check for a proton ###
   sesmiles  = esmiles.split()[0]
   sesmiles1 = esmiles1.split()[0]
   if (("[H+]" == sesmiles) or ("[H+]" == sesmiles1) or ("proton" == sesmiles.lower()) or ("proton" == sesmiles1.lower()) ) :
      return [proton_data()]

   if (("[1H+]" == sesmiles) or ("[1H+]" == sesmiles1)):
      return [proton_data()]

   if (("[H]" == sesmiles) or ("[H]" == sesmiles1)):
      charge = 0
      if '^{' in esmiles:   charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      if '^{' in esmiles1:  charge = evalnum(esmiles1.split('^{')[1].split('}')[0].strip())
      if charge==1:
         return [proton_data()]


   smiles  = clean_smiles(ss[0])
   if "id=" in smiles.lower():
      searchingid = True
      try:
         smiles = smiles.replace(")","")
         smiles = smiles.replace("]","")
         smiles = smiles.replace("(","")
         smiles = smiles.replace("[","")
         id = evalnum(smiles.split("=")[1].strip())
      except:
         id = 1001
      wherestr =  " where Id=?"
      wherestr2 =  " where Id=? ;"
      checklist = []
      checklist.append(id)
   else:
      searchingid = False
      csmiles  = cannonicalsmiles(smiles)
      inchi    = smiles2InChI(smiles)    #used because it includes charge in inchi
      inchikey = smiles2InChIKey(smiles) #used because it includes charge in inchikey

      xyzfile = wrkdir + "/" + tmpxyz1
      smiles2xyz(smiles,xyzfile)
      inchi2    = xyz2InChI(xyzfile)    #inchi2 does not include charge
      inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge
      mformula = xyz_molecular_formula(xyzfile)

      if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
      if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
      if 'basis{' in esmiles:  
         basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
         if ((theory=="ccsd(t)") or (theory=="mp2")):
            basis_base  = basis
      if 'basisHZ{' in esmiles:  
         basisHZ  = removespace_basis(esmiles.split('basisHZ{')[1].split('}')[0])
         basisHZ1 = basisHZ
         basisHZ2 = basisHZ
         basisHZ3 = basisHZ
         if ((theory=="ccsd(t)") or (theory=="mp2")):
            basisHZ_base  = basisHZ
      if 'theory_base{' in esmiles: theory_base = esmiles.split('theory_base{')[1].split('}')[0]
      if 'xc_base{' in esmiles:     xc_base     = esmiles.split('xc_base{')[1].split('}')[0]
      if 'basis_base{' in esmiles:  basis_base  = removespace_basis(esmiles.split('basis_base{')[1].split('}')[0])
      if 'basisHZ_base{' in esmiles:  basisHZ_base  = removespace_basis(esmiles.split('basisHZ_base{')[1].split('}')[0])
      charge = smiles2charge(smiles)
      if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
      mult = esmiles2mult_set(smiles,charge,esmiles)
      #mult   = smiles2mult(smiles,charge)
      #if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
      if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
      if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
      if solvation_type.lower()=='none':
         calculation_type = calculation_type.replace('c','')
      calculation_type2 = calculation_type + 'n'

      if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
      if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
      if 'ry' in  basis_base.lower():      basis_base = '%.1f Ry' % (evalnum(basis_base.strip().split()[0]))
      if 'hartree' in  basis_base.lower(): basis_base = '%.1f Ry' % (2*evalnum(basis_base.strip().split()[0]))

      hasHZ = inchihasHZ(inchi2) and (basis!="semiempirical") and (theory!='pspw') and (theory!='pspw4') and (theory!='paw')
      notonlyHZ = (not inchionlyHZ(inchi2)) or (basis=="semiempirical") or (theory=='pspw') or (theory=='pspw4') or (theory=='paw')

      print 
      print "fetch_esmiles table  =",table
      print "fetch_esmiles inchi  =",inchi
      print "fetch_esmiles inchi2 =",inchi2
      print "fetch_esmiles inchikey  =",inchikey
      print "fetch_esmiles inchikey2 =",inchikey2
      print "fetch_esmiles mformula =",mformula
      print "fetch_esmiles theory=",theory
      print "fetch_esmiles xc    =",xc
      #print "fetch_esmiles basis =",basis
      if (theory_base!=''): print "fetch_esmiles theory_base=",theory_base
      if (xc_base!=''):     print "fetch_esmiles xc_base    =",xc_base
      if (basis_base!=''):  print "fetch_esmiles basis_base =",basis_base
      if (notonlyHZ): print "fetch_esmiles basis =",basis
      print "HASHZ=",hasHZ

      if (hasHZ):     print "fetch_esmiles basisHZ =",basisHZ
      if (hasHZ):     print "fetch_esmiles basisHZ1 =",basisHZ1
      if (hasHZ):     print "fetch_esmiles basisHZ2 =",basisHZ2
      if (hasHZ):     print "fetch_esmiles basisHZ3 =",basisHZ3
      if (theory_base!=''): print "fetch_esmiles theory_base=",theory_base
      if (xc_base!=''):     print "fetch_esmiles xc_base    =",xc_base
      if (notonlyHZ) and (basis_base!=''):  print "fetch_esmiles basis_base =",basis_base
      if (hasHZ) and (basisHZ_base!=''):  print "fetch_esmiles basisHZ_base =",basisHZ_base
      print "fetch_esmiles charge=",charge
      print "fetch_esmiles mult  =",mult
      print "fetch_esmiles solvation_type=",solvation_type
      print "fetch_esmiles calculation_type=",calculation_type,calculation_type2

      checklist = []
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchi)
      checklist.append(inchi2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(inchikey)
      checklist.append(inchikey2)
      checklist.append(mformula)
      checklist.append(theory)
      checklist.append(xc)
      if (notonlyHZ): checklist.append(basis)
      if (hasHZ):
         checklist.append(basisHZ)
         checklist.append(basisHZ1)
         checklist.append(basisHZ2)
         checklist.append(basisHZ3)
      if (theory_base!=''): checklist.append(theory_base)
      if (xc_base!=''):     checklist.append(xc_base)
      if (basis_base!=''): checklist.append(basis_base)
      if (basisHZ_base!=''):   checklist.append(basisHZ_base)
      checklist.append(charge)
      checklist.append(mult)
      checklist.append(solvation_type)
      checklist.append(calculation_type)
      checklist.append(calculation_type2)

      wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
      wherestr += " and mformula=?"
      wherestr += " and theory=?"
      wherestr += " and xc=?"
      if (notonlyHZ): wherestr += " and basis=?"
      if (hasHZ):     wherestr += " and (basisHZ=? or basisHZ=? or basisHZ=? or basisHZ=?)"
      if (theory_base!=''): wherestr += " and theory_base=?"
      if (xc_base!=''):     wherestr += " and xc_base=?"
      if (basis_base!=''): wherestr += " and basis_base=?"
      if (basisHZ_base!=''):   wherestr += " and basisHZ_base=?"
      wherestr += " and charge=?"
      wherestr += " and mult=?"
      wherestr += " and solvation_type=?"
      wherestr += " and (calculation_type=? or calculation_type=?)"


   wherestr2 = " where id=? ;"

   if (issqlite3):
      sqlcheck = "select id from " + table + wherestr
      sqlcheck2 = "select * from " + table + wherestr2
   else:
      sqlcheck = "select id from " + table + wherestr.replace('?','%s')
      sqlcheck2 = "select * from " + table + wherestr2.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   rows2 = []
   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
      if (len(rows)>0):
         for row in rows:
            checklist2 = [row[0]]
            cur.execute(sqlcheck2,checklist2)
            tmp = cur.fetchall()
            rows2.append(tmp[0])
   dbcon.close()

   ### esmiles1 not found call chemdb_add_request ###
   if ((len(rows)<1) and (submitrequest) and (not searchingid)):
      cmd = chemdb_add_request + '\"' + esmiles1 + '\"'
      print "esmiles not found, running cmd:",cmd
      result = subprocess.check_output(cmd,shell=True)
      print 
      print  result

   return rows2

 except:
   return []






#############################################
#                                           #
#             add_nmrexp                    #
#                                           #
#############################################

def add_nmrexp(hup,dbfile,table,xyznmr_data):
   xyzfile = wrkdir + "/" + tmpxyz1

   ### fetch xyznmr_blob and solvent ###
   xyznmr_blob = xyznmr_data.split('solvent:')[0].strip()
   if 'solvent:' in xyznmr_data:
      solvent = xyznmr_data.split('solvent:')[1].split(':solvent')[0].strip()
   else:
      solvent = 'None'

   ### create xyzfile ###
   xyzdata = []
   for line in xyznmr_blob.split('\n'):
      ss = line.split()
      sline = "%s  %s %s %s" % (ss[0],ss[1],ss[2],ss[3])
      xyzdata.append(sline)

   with open(xyzfile,'w') as f:
      f.write("%d\n\n" % len(xyzdata))
      for line in xyzdata:
         f.write(line + "\n")

   mformula = xyz_molecular_formula(xyzfile)
   smiles   = xyz2smiles(xyzfile)
   csmiles  = xyz2smiles(xyzfile)
   InChI    = smiles2InChI(smiles)
   InChIKey = smiles2InChIKey(smiles)
   iupac    = pubchem_smiles2iupac(smiles)
   cid      = pubchem_smiles2cid(smiles)
   cas      = pubchem_smiles2cas(smiles)
   kegg     = pubchem_smiles2kegg(smiles)
   synonyms = pubchem_smiles2synonyms(smiles)

   eoln = '\n'
   msg = eoln
   msg += "+-----------------------+" + eoln
   msg += "| Adding NMR Experiment |" + eoln
   msg += "+-----------------------+" + eoln+eoln
   msg += "iupac             ="+iupac + eoln
   msg += "mformula          ="+mformula + eoln
   msg += "InChI             ="+InChI + eoln
   msg += "InChIKey          ="+InChIKey + eoln
   msg += "cid               ="+cid + eoln
   msg += "cas               ="+cas + eoln
   msg += "kegg              ="+kegg + eoln
   msg += "synonyms          ="+synonyms + eoln
   msg += "smiles            ="+smiles + eoln
   msg += "cannonical smiles ="+csmiles + eoln+eoln
   msg += "solvent           ="+solvent+eoln+eoln
   msg += "xyznmr_blob       =" + eoln
   msg += xyznmr_blob + eoln + eoln
   print msg


   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   sqlinsert = "insert into " + table
   sqlinsert += " (iupac,mformula,InChI,InChIKey,smiles,csmiles,"
   sqlinsert += "synonyms,cid,cas,kegg,solvent,"
   sqlinsert += "xyznmr_blob) "
   sqlinsert += " values (?,?,?,?,?,?,?,?,?,?,?,?);"

   if (not issqlite3): sqlinsert = sqlinsert.replace('?','%s')

   insertlist = []
   insertlist.append(iupac)
   insertlist.append(mformula)
   insertlist.append(InChI)
   insertlist.append(InChIKey)
   insertlist.append(smiles)
   insertlist.append(csmiles)
   insertlist.append(synonyms)
   insertlist.append(cid)
   insertlist.append(cas)
   insertlist.append(kegg)
   insertlist.append(solvent)
   if (issqlite3):
      insertlist.append(sqlite3.Binary(xyznmr_blob))
   else:
      insertlist.append(xyznmr_blob)

   print "hup=",hup
   print "dbfile=",dbfile
   print "table=",table

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss  = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlinsert,insertlist)
   dbcon.close()

   tmsg = "Hi. I just added the nmr data for the " + iupac + " molecule to the " + table + " table in the " + dbfile  + " database."
   msg += tmsg + eoln
   text2speech(tmsg)

   return msg


#############################################
#                                           #
#             nmr_blob_to_isotropic         #
#                                           #
#############################################

def nmr_blob_to_isotropic(nmr_blob):
   isotropic = []
   for line in nmr_blob.split('\n'):
      if 'Atom:' in line:
         number = evalnum(line.split()[1])
         atom   = line.split()[2]
      if 'isotropic =' in line:
         iso = evalnum(line.split()[2])
         isotropic.append([number,atom,iso])
   return isotropic

#############################################
#                                           #
#             fetch_nmr_scaling             #
#                                           #
#############################################
def fetch_nmr_scaling(hup,dbfile,table,atom,theory,xc,basis,theory_property,xc_property,basis_property,solvation_type,solvation_dielectric):

   checklist = []
   checklist.append(atom)
   checklist.append(theory)
   checklist.append(xc)
   checklist.append(basis)
   checklist.append(theory_property)
   checklist.append(xc_property)
   checklist.append(basis_property)
   checklist.append(solvation_type)
   #checklist.append(solvation_dielectric)

   wherestr =  " where atom=?"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   wherestr += " and basis=?"
   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   wherestr += " and basis_property=?"
   wherestr += " and solvation_type=?;"
   #wherestr += " and solvation_dielectric=?"
   

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()


   return rows



#############################################
#                                           #
#             print_nmr_row                 #
#                                           #
#############################################
def print_nmr_row(hup,dbfile,table,row):

   eoln = "\n"
   msg = "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"
   msg += "+---------------------------------------+\n"
   msg += "| NMR Shielding and Chemical Shift Data |\n"
   msg += "+---------------------------------------+\n"
   msg += "Id              = %d\n" % (row[0])
   msg += "iupac           = %s\n" % (row[1])
   msg += "mformula        = %s\n" % (row[2])
   msg += "InChI           = %s\n" % (row[3])
   msg += "smiles          = %s\n" % (row[4])
   msg += "esmiles         = %s\n" % (row[6])
   msg += "theory          = %s\n" % (row[9])
   msg += "xc              = %s\n" % (row[10])
   msg += "basis           = %s\n" % (row[11])
   msg += "theory_property = %s\n" % (row[38])
   msg += "xc_property     = %s\n" % (row[39])
   msg += "basis_property  = %s\n" % (row[40])
   msg += "charge          = %d\n" % (row[12])
   msg += "mult            = %d\n" % (row[13])
   msg += "solvation_type  = %s\n" % (row[17])
   #msg += "solvation_dielectric  = %f\n" % (row[37])
   msg += "chemical_structure_asciiart  = </pre> <pre style=\"font-size:0.5em;color:magenta\"> \n"
   msg += stripWARNINGS(row[34])
   msg += "</pre> <pre style=\"font-size:0.6em;color:black\"> \n"

   msg += eoln
   msg +=  "NMR chemical shieldings from %s: \n" % row[7] 
   msg +=  "----------------------------------------\n"
   isotropic = nmr_blob_to_isotropic(row[36])
   atoms = []
   for iso in isotropic:
      atoms.append(iso[1])
      msg += "   %5d %3s  isotropic ppm= %12.6f\n" % (iso[0],iso[1],iso[2])

   ### search for LFERS ###
   msg +=  eoln+ eoln + "Linear Relations between NMR Shieldings and Chemical Shifts:\n"
   msg +=  "------------------------------------------------------------\n"
   atoms = list(set(atoms))
   lfers = {}
   for a in atoms:
      lfers[a] = fetch_nmr_scaling(hup,dbfile,table,a,row[9],row[10],row[11],row[38],row[39],row[40],row[17],row[37])
      for lfer in lfers[a]:
         msg += " %2s%d - slope = %f  intersept = %f  - RMSD=%f R2=%f\n" % (a,lfer[2],lfer[11],lfer[12],lfer[13],lfer[14])
         msg += "    - theory{%s} xc{%s} basis{%s}\n" % (lfer[3],lfer[4],lfer[5])
         msg += "    - theory_property{%s} xc_property{%s} basis_property{%s}\n" % (lfer[6],lfer[7],lfer[8])
         msg += "    - solvation_type{%s} solvation_dielectric{%f}\n" % (lfer[9],lfer[10])
         msg += "    - reference{%s} \n\n" % (lfer[15])

         msg +=  " %2s%d NMR chemical shifts:\n" % (a,lfer[2])
         emin = 9.999e99
         emax = -9.999e99
         for iso in isotropic:
            if (iso[1]==a):
               shft = -(lfer[12] - iso[2])/lfer[11]
               msg += "   %5d %3s ppm= %12.6f\n" % (iso[0],a,shft)
               if (shft>emax): emax = shft
               if (shft<emin): emin = shft
         msg += eoln

         ### plot the chemical shift spectrum  ###
         emin -= 2.0
         emax += 2.0
         sigma  = (emax-emin)*0.0125
         ngrid  = 501
         pi     = 4.0*atan(1.0)
         dw     = (emax-emin)/float(ngrid-1)
         scale  = 1.0/(sigma*sqrt(2.0*pi))
         omega2 = 1.0/(2.0*sigma*sigma)
         ww = []
         y  = []
         for i in range(ngrid):
            w = emin + i*dw
            ww.append(w)
            pp = 0.0
            for iso in isotropic:
               if (iso[1]==a):
                  shft = -(lfer[12] - iso[2])/lfer[11]
                  x2   = (w-shft)**2
                  tt   = scale*exp(-omega2*x2)
                  pp += tt
            y.append(pp)

         yy = [y]
         symbols = ('*')
         title = '%s%d NMR Chemical Shift Spectrum (sigma=%.2f ppm)' % (a,lfer[2],sigma)
         xlabel = 'Chemical Shift (ppm)'
         ylabel = 'Magnitude'
         xmin = emin
         xmax = emax
         ymin = min(y)
         ymax = max(y)
         msg += "\n"
         msg += ascii_plotter(ww,yy,symbols,title,xlabel,ylabel,xmin,xmax,ymin,ymax,False)





   
   return msg


#############################################
#                                           #
#             fetch_nmr                     #
#                                           #
#############################################

def fetch_nmr(hup,dbfile,table,esmiles,submitrequest=True):
   if (hup=='sqlite3'):
      issqlite3 = True
   else:
      issqlite3 = False

   theory_property = ''
   xc_property     = ''
   basis_property  = ''
   if 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='100.0 Ry';solvation_type='None'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'

   #esmiles1=esmiles.strip()
   esmiles1=esmileswithname_to_esmiles(esmiles.strip())

   ss = esmiles1.split()
   smiles  = clean_smiles(ss[0])
   csmiles = cannonicalsmiles(ss[0])
   inchi    = smiles2InChI(ss[0])
   inchikey = smiles2InChIKey(ss[0])
   xyzfile = wrkdir + "/" + tmpxyz1
   smiles2xyz(ss[0],xyzfile)
   inchi2    = xyz2InChI(xyzfile) #inchi2 does not include charge
   inchikey2 = xyz2InChIKey(xyzfile) #inchikey2 does not include charge


   #print "ss[0]=",ss[0]
   #print "inchi=",inchi
   #for s in ss:
   #   if 'theory' in s: theory = s.split('{')[1].split('}')[0]
   #   if 'xc' in s:     xc     = s.split('{')[1].split('}')[0]
   #   if 'basis' in s:  basis  = s.split('{')[1].split('}')[0]
   #   if '^' in s:      charge = s.split('{')[1].split('}')[0]
   #   if 'mult' in s:   mult   = s.split('{')[1].split('}')[0]
   #   if 'solvation_type' in s: solvation_type = s.split('{')[1].split('}')[0]

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
   if 'theory_property{' in esmiles: theory_property = esmiles.split('theory_property{')[1].split('}')[0]
   if 'xc_property{' in esmiles:     xc_property     = esmiles.split('xc_property{')[1].split('}')[0]
   if 'basis_property{' in esmiles:  basis_property  = removespace_basis(esmiles.split('basis_property{')[1].split('}')[0])
   charge = smiles2charge(smiles)
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
   mult = esmiles2mult_set(smiles,charge,esmiles)
   #mult   = smiles2mult(smiles,charge)
   #if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'calculation_type' in esmiles: calculation_type = esmiles.split('calculation_type{')[1].split('}')[0]
   if solvation_type.lower()=='none':
      calculation_type = calculation_type.replace('c','')
   if 'ry' in  basis.lower():      basis = '%.1f Ry' % (evalnum(basis.strip().split()[0]))
   if 'hartree' in  basis.lower(): basis = '%.1f Ry' % (2*evalnum(basis.strip().split()[0]))
   if 'ry' in  basis_property.lower():      basis_property = '%.1f Ry' % (evalnum(basis_property.strip().split()[0]))
   if 'hartree' in  basis_property.lower(): basis_property = '%.1f Ry' % (2*evalnum(basis_property.strip().split()[0]))


   if (theory_property==''): theory_property = theory
   if (xc_property==''):     xc_property = xc
   if (basis_property==''):  basis_property = basis
   print "fetch_nmr inchi =",inchi
   print "fetch_nmr inchi2=",inchi2
   print "fetch_nmr inchikey =",inchikey
   print "fetch_nmr inchikey2=",inchikey2
   print "fetch_nmr theory=",theory
   print "fetch_nmr xc    =",xc
   print "fetch_nmr basis =",basis
   print "fetch_nmr theory_property=",theory_property
   print "fetch_nmr xc_property    =",xc_property
   print "fetch_nmr basis_property =",basis_property
   print "fetch_nmr charge=",charge
   print "fetch_nmr mult  =",mult
   print "fetch_nmr solvation_type=",solvation_type

   checklist = []
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchi)
   checklist.append(inchi2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(inchikey)
   checklist.append(inchikey2)
   checklist.append(theory)
   checklist.append(xc)
   checklist.append(basis)
   checklist.append(theory_property)
   checklist.append(xc_property)
   checklist.append(basis_property)

   checklist.append(charge)
   checklist.append(mult)
   checklist.append(solvation_type)
   

   wherestr =  " where (InChI=? or InChI=? or oInChI=? or oInChI=? or InChIKey=? or InChIKey=? or oInChIKey=? or oInChIKey=?)"
   wherestr += " and theory=?"
   wherestr += " and xc=?"
   wherestr += " and basis=?"
   wherestr += " and theory_property=?"
   wherestr += " and xc_property=?"
   wherestr += " and basis_property=?"
   wherestr += " and charge=?"
   wherestr += " and mult=?"
   wherestr += " and solvation_type=?"
   wherestr += " and nmr_blob IS NOT NULL"
  

   if (issqlite3):
      sqlcheck = "select * from " + table + wherestr
   else:
      sqlcheck = "select * from " + table + wherestr.replace('?','%s')

   print "nmr_table=",table
   print "sqlcheck =",sqlcheck


   if (issqlite3):
      dbcon = sqlite3.connect(dbfile)
   else:
      host = hup.split()[0]
      user = hup.split()[1]
      pss = hup.split()[2]
      dbcon = MySQLdb.connect(host,user,pss,dbfile)

   with dbcon:
      cur = dbcon.cursor()
      cur.execute(sqlcheck,checklist)
      rows = cur.fetchall()
   dbcon.close()

   ### esmiles not found call chemdb_add_request ###
   if ((len(rows)<1) and (submitrequest)):
      cmd = chemdb_add_request + '\"' + esmiles1 + '\"'
      print "esmiles not found, running cmd:",cmd
      result = subprocess.check_output(cmd,shell=True)
      print
      print  result

   return rows






#############################################
#                                           #
#             molecule2esmiles              #
#                                           #
#############################################
def molecule2esmiles(molecule):
   try:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13],molecule[35])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{%d}" % tt
   except:
      tt = (molecule[4],molecule[9],molecule[11],molecule[10],molecule[17],molecule[12],molecule[13])
      esmiles = "%s theory{%s} basis{%s} xc{%s} solvation_type{%s} ^{%d} mult{%d} nf{?}" % tt
   
   return esmiles

#############################################
#                                           #
#        esmileswithid_to_esmiles           #
#                                           #
#############################################

def esmileswithid_to_esmiles(hup,dbfile,table,esmiles0):
   esmiles1 = esmiles0
   try:
      if "id=" in esmiles0.lower():
         rows = fetch_esmiles(hup,dbfile,table,esmiles0,False)
         if (len(rows)>0):
            ss          = esmiles0.strip().split()
            tagsoptions = " ".join(ss[1:])
            molecule    = rows[0]
            smiles      = molecule[4]
            charge      = molecule[12]
            mult        = molecule[13]
            xyz         = molecule[23].strip()
            xyzdata     = "xyzdata{" + xyz.replace('\n',' | ') + "}"
            if ("^{" not in tagsoptions):    smiles += " ^{%d}"    % charge
            if ("mult{" not in tagsoptions): smiles += " mult{%d}" % mult
            esmiles1 =  smiles + " " + xyzdata + " " + tagsoptions
         else:
            esmiles1 = "C"
   except:
      esmiles1 = "C"

   return esmiles1

#############################################
#                                           #
#             submit_esmiles                #
#                                           #
#############################################
def submit_esmiles(esmiles,includerotation,datafile,emailfrom=None,machine=None):
   result = "\nSubmitting the following esmiles: " + esmiles + "\n"
   cmd0 = ''
   if (includerotation): cmd0 += ' -r ' 
   if (emailfrom!=None) and (emailfrom!=''):
      cmd0 += ' -e ' + emailfrom + ' '
   if (machine!=None):   cmd0 += ' -m ' + machine + ' '
   if (datafile!=''):    cmd0 += ' -a ' + datafile + ' '

   #add orginal smiles string to vtag
   vtag = '"osmiles:'+ esmiles.strip().split()[0].strip() + ':osmiles "'
   cmd0 += ' -v ' + vtag + ' '

   cmd1 = tnt_submit + cmd0 + '"' + esmiles.strip() + '"'
   print "submit esmiles cmd1 = " + cmd1

   try:
      result += subprocess.check_output(cmd1,shell=True)
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print  result
   return result


#############################################
#                                           #
#             submit_esmiles_xyz            #
#                                           #
#############################################
def submit_esmiles_xyz(esmiles,includerotation,xyz,vtag=None,machine=None):
   xyzfile = wrkdir + "/" + tmpxyz99
   result = "\nSubmitting the following esmiles,xyz: " + esmiles + "\n"
   result += "xyz=\n"
   result += xyz + "\n"
   cmd0 = ''

   if (includerotation): cmd0 += ' -r ' 
   if ((machine!=None) and (machine!='')): cmd0 += ' -m ' + machine

   if 'pspw4' in esmiles:
      theory='pspw4';xc='pbe';basis='50.0';solvation_type='None'
   elif 'pspw' in esmiles:
      theory='pspw';xc='pbe';basis='50.0';solvation_type='None'
   elif 'paw4' in esmiles:
      theory='paw4';xc='pbe';basis='50.0';solvation_type='None'
   elif 'paw' in esmiles:
      theory='paw';xc='pbe';basis='50.0';solvation_type='None'
   elif 'am1' in esmiles:
      theory='am1';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'pm3' in esmiles:
      theory='pm3';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'mndo' in esmiles:
      theory='mndo';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'mindo3' in esmiles:
      theory='mindo3';xc='unknown';basis='semiempirical';solvation_type='COSMO'
   elif 'dft' in esmiles:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'uhf' in esmiles:
      theory='uhf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   elif 'hf' in esmiles:
      theory='hf';xc='unknown';basis='6-311++G(2d,2p)';solvation_type='COSMO'
   else:
      theory='dft';xc='b3lyp';basis='6-311++G(2d,2p)';solvation_type='COSMO'

   smiles = clean_smiles(esmiles.strip().split()[0])

   if 'theory{' in esmiles: theory = esmiles.split('theory{')[1].split('}')[0]
   if 'xc{' in esmiles:     xc     = esmiles.split('xc{')[1].split('}')[0]
   charge = smiles2charge(smiles)
   if '^{' in esmiles:      charge = evalnum(esmiles.split('^{')[1].split('}')[0].strip())
   mult = esmiles2mult_set(smiles,charge,esmiles)
   #mult   = smiles2mult(smiles,charge)
   #if 'mult{' in esmiles:   mult   = evalnum(esmiles.split('mult{')[1].split('}')[0].strip())
   if 'solvation_type' in esmiles: solvation_type = esmiles.split('solvation_type{')[1].split('}')[0]
   if 'basis{' in esmiles:  basis  = removespace_basis(esmiles.split('basis{')[1].split('}')[0])
   if 'ry' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*0.5
      basis = '%f' % xb
   if 'hartree' in basis.lower():
      xb = evalnum(basis.strip().split()[0])*1.0
      basis = '%f' % xb
   charge = '%d' % charge
   mult   = '%d' % mult

   cmd0 += ' -t ' + theory + " -b '" + basis + "' -x " + xc + " -y " + solvation_type + " -s " + mult + " -q " + charge
   if ((vtag!=None) and (vtag!='')):  cmd0 += " -v " + vtag

   ofile = open(xyzfile,'w')
   ofile.write(xyz)
   ofile.close()
   cmd1 = tnt_submit + cmd0 + " " + xyzfile
   print "submit esmiles cmd1 = " + cmd1

   try:
      result += subprocess.check_output(cmd1,shell=True)
   except:
      result += "\n\ntnt_submit failed and job was not submitted\n\n"
   print  result
   return result



##########################################################
#                                                        #
#        generate_reactions_from_reactionenumerate       #
#                                                        #
##########################################################
def generate_reactions_from_reactionenumerate(reactiontable):

   ### change to small case  ###
   rstring = ireplace("TABLEREACTIONS", "tablereactions", reactiontable)
   rstring = ireplace("TABLEMETHODS", "tablemethods", rstring)
   rstring = ireplace("REACTION", "reaction", rstring)
   rstring = ireplace("METHOD", "method", rstring)

   ### get the reactions ###
   reactions      = []
   msg2           = rstring.split("tablereactions:")
   tablereactions = msg2[1].split(":tablereactions")[0]
   rstring        = rstring.replace("tablereactions:"+tablereactions+":tablereactions","")
   for a in tablereactions.strip().split("reaction:")[1:]:
      reaction = a.strip().split(":reaction")[0]
      reaction2 = addspaces_reaction(reaction.strip())
      reaction3 = parsetosmiles(reaction2)
      reactions.append(reaction3)

   ### get the methods ###
   methods      = []
   msg2         = rstring.split("tablemethods:")
   tablemethods = msg2[1].split(":tablemethods")[0]
   rstring      = rstring.replace("tablemethods:"+tablemethods+":tablemethods","")
   for a in tablemethods.strip().split("method:")[1:]:
      method = a.strip().split(":method")[0]
      methods.append(method)

   rr = ""
   for reaction in reactions:
      sslist = reaction.split("-->")
      left  = sslist[0].strip()
      left = left.replace("\t"," ")
      left = left.replace("\n"," ")
      #left = left.decode('ascii', 'replace')
      left = left.replace('\xc2', ' ')
      left = left.replace('\xa0', ' ')
      esmiles_reactants  = left.split(' + ')
      number_reactants = len(esmiles_reactants)
      if (len(sslist)>1):
         right = sslist[1].strip()
         right= right.replace("\t"," ")
         right= right.replace("\n"," ")
         right= right.replace('\xc2', ' ')
         right= right.replace('\xa0', ' ')
         esmiles_products   = right.split(' + ')
         number_products  = len(esmiles_products)
      else:
         esmiles_products = esmiles_reactants
         number_products  = number_reactants
         esmiles_reactants = []
         number_reactants = 0
      for method in methods:
         rr += "reaction: "
         for k in range(number_reactants-1):
            rr += esmiles_reactants[k] + " " + method + " + "
         if (number_reactants>0):
            rr += esmiles_reactants[number_reactants-1] + " " + method + " --> "
         for k in range(number_products-1):
            rr += esmiles_products[k] + " " + method + " + "
         if (number_products>0):
            rr += esmiles_products[number_products-1] + " " + method  + " :reaction\n"

   return rr




##########################################################
#                                                        #
#             maketable_from_reactionenumerate           #
#                                                        #
##########################################################
def maketable_from_reactionenumerate(reactiontable,reaction_data):

   ### change to small case  ###
   rstring = ireplace("TABLEREACTIONS", "tablereactions", reactiontable)
   rstring = ireplace("TABLEMETHODS", "tablemethods", rstring)
   rstring = ireplace("REACTION", "reaction", rstring)
   rstring = ireplace("METHOD", "method", rstring)

   ### get the reactions ###
   reactions      = []
   msg2           = rstring.split("tablereactions:")
   tablereactions = msg2[1].split(":tablereactions")[0]
   rstring        = rstring.replace("tablereactions:"+tablereactions+":tablereactions","")
   for a in tablereactions.strip().split("reaction:")[1:]:
      reaction = a.strip().split(":reaction")[0]
      reaction2 = addspaces_reaction(reaction.strip())
      reaction3 = parsetosmiles(reaction2)
      reactions.append(reaction3)

   ### get the methods ###
   methods      = []
   msg2         = rstring.split("tablemethods:")
   tablemethods = msg2[1].split(":tablemethods")[0]
   rstring      = rstring.replace("tablemethods:"+tablemethods+":tablemethods","")
   for a in tablemethods.strip().split("method:")[1:]:
      method = a.strip().split(":method")[0]
      methods.append(method)

   ### get the energytypes ###
   toolongcountmax = 8
   toolongcount = 0
   toolong      = False
   etypes   = []
   utypes   = []
   rstring = ireplace("ENERGYTYPE", "energytype", rstring)
   while ((len(rstring.split("energytype:"))>1) and (not toolong)):
      msg2    = rstring.split("energytype:")
      etype   = msg2[1].split(":energytype")[0]
      rstring = rstring.replace("energytype:"+etype+":energytype","")
      if "erxn(gas)"       in etype.lower(): etypes.append([0,"Erxn(gas)"])
      if "hrxn(gas)"       in etype.lower(): etypes.append([1,"Hrxn(gas)"])
      if "grxn(gas)"       in etype.lower(): etypes.append([2,"Grxn(gas)"])
      if "delta_solvation" in etype.lower(): etypes.append([3,"Delta_Solvation"])
      if "grxn(aq)"        in etype.lower(): etypes.append([4,"Grxn(aq)"])
      if "kcal/mol" in etype.lower(): utypes.append([627.509469,"kcal/mol"])
      if "kj/mol"   in etype.lower(): utypes.append([2625.49962,"kJ/mol"])
      if "ev"       in etype.lower(): utypes.append([27.2114,"eV"])
      if "cm-1"     in etype.lower(): utypes.append([219474.6,"cm-1"])
      if "ry"       in etype.lower(): utypes.append([2.0,"Rydbergs"])
      if "hartree"  in etype.lower(): utypes.append([1.0,"Hartrees"])
      if "au"       in etype.lower(): utypes.append([1.0,"au"])
      toolong = (toolongcount > toolongcountmax)
      toolongcount += 1
   if (toolong):
      rr = "maketable_from_reactionenumerate: too long parinsg energytype: :energytype\n"
      return (rr,0)
   if (len(etypes)==0): etypes.append([4,"Grxn(aq)"])
   if (len(utypes)==0): utypes.append([1,"Hartrees"])

   nr = len(reactions)
   nm = len(methods)

   rr  = "+--------------------------------+\n"
   rr += "| Generating Reaction Table Data |\n"
   rr += "+--------------------------------+\n\n"
   for etype in etypes:
    for utype in utypes:
      rr += "CSV FILE of for %s in %s:\n" % (etype[1],utype[1])
      rr += "--------------------------------------------------------------------------------------------------\n"
      rr += "reactions,instance"
      for method  in methods:
         rr += "," + method.strip()
      rr += "\n"
      for k in range(nr):
         max_paths = 0
         for j in range(nm):
            i = j + k*nm
            ipaths = reaction_data[i][1]
            max_paths = max(len(ipaths),max_paths)
         for ii in range(max_paths):
            rr += reactions[k]
            rr += ",%d" % ii
            for j in range(nm):
               i = j + k*nm
               ipaths = reaction_data[i][1]
               if (ii<len(ipaths)):
                  inst = ipaths[ii]
                  rr += ",%15.6f" % (inst[etype[0]]*utype[0])
               else:
                  rr += ","
            rr += "\n"
      rr += "--------------------------------------------------------------------------------------------------\n\n"

   return (rr,nr*nm)




############################# main program ###################################
usage = \
"""
chemdb fetch reactions program

  Usage: chemdb_fetch_reactions -h hup_string -d database -t table -n nmr_table -q requests_table reactions output

  -h hup_string="machine user password" or enter sqlite3 for sqlite3 db
  -d database = "name of database"
  -t table = "name of calculation table"
  -n nmr_table = "name of nmr_table"
  -q requests_table = "name of requests_table"
  -f view frequencies
  -e submit missing esmiles
  -h prints this message

"""


eoln = "\n"
#Database defaults
hup    = hup0
dbfile = "TNT_Project"
table  = "calculations"
requests_table = "requests"
abbrev_table   = "abbreviations"
nmr_table = "nmr_calculations"
nmr_scaling_table = "nmr_scaling"
nmr_experiments_table = "nmr_experiments"
heat_formation_table = "heats_of_formation"

print "chemdb_fetch_reactions4 mysql version"
tt      = time.localtime()

viewfreq              = False
submitmissingesmiles1 = False
opts, args = getopt.getopt(sys.argv[1:], "h:d:t:n:q:efh")
for o, a in opts:
  if '-h' in o:
     hup = a
  if '-d' in o:
     dbfile = a
  if '-t' in o:
     table = a
  if '-q' in o:
     requests_table = a
  if '-n' in o:
     nmr_table = a
  if '-f' in o:
     viewfreq = True
  if '-e' in o:
     submitmissingesmiles1 = True
  if o in ("-h","--help"):
    print usage
    exit()

if (len(args)<2): 
   print usage
   exit()
print args[0]
print args[1]
ooofile = open(args[1],'w')
ooofile.write("<html>\n")
ooofile.write(ArrowsHeader)
ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")
#ooofile.write("chemdb_fetch_reactions mysql version"+eoln)

### load the reactions input file into rstring ###
if (os.path.isfile(args[0])):
   rfile = open(args[0],'r')
   rstring = rfile.read()
   rfile.close()
else:
   rstring = args[0]


#####################################
##### parse hidden options first ####
#####################################

### get the database and table ###
rstring = ireplace("HUP_STRING", "hup_string", rstring)
rstring = ireplace("DATABASE", "database", rstring)
rstring = ireplace("TABLE", "table", rstring)
rstring = ireplace("REQUESTS_TABLE", "requests_table", rstring)
for line in rstring.split("\n"):
   if ("hup_string:" in line):
      rstring = rstring.replace(line,"")
      hup  = line.split()[1]
   if ("database:" in line):
      rstring = rstring.replace(line,"")
      dbfile  = line.split()[1]
   if ("requests_table:" in line):
      rstring = rstring.replace(line,"")
      requests_table   = line.split()[1]
   if ("table:" in line):
      rstring = rstring.replace(line,"")
      table   = line.split()[1]

if (hup=='sqlite3'):
   issqlite3 = True
   #ooofile.write("sqlite3 db file = "+dbfile+eoln)
else:
   issqlite3 = False
   #ooofile.write("mysql db        ="+dbfile+eoln)
#ooofile.write("table name      ="+table+eoln)
#ooofile.write("requests_table name="+requests_table+eoln)
#ooofile.write("nmr_scaling_table name="+nmr_scaling_table+eoln)

### emailfrom  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
emailfrom = ''
rstring = ireplace("EMAILFROM", "emailfrom", rstring)
while ((len(rstring.split("emailfrom:"))>1) and (not toolong) and (":emailfrom" in rstring)):
   msg2 = rstring.split("emailfrom:")
   msg3 = msg2[1].split(":emailfrom")[0]
   rstring  = rstring.replace("emailfrom:"+msg3+":emailfrom","")
   emailfrom = msg3
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing emailfrom: :emailfrom, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### emailcc  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
emailcc = ''
rstring = ireplace("EMAILCC", "emailcc", rstring)
while ((len(rstring.split("emailcc:"))>1) and (not toolong) and (":emailcc" in rstring)):
   msg2 = rstring.split("emailcc:")
   msg3 = msg2[1].split(":emailcc")[0]
   rstring  = rstring.replace("emailcc:"+msg3+":emailcc","")
   emailcc = msg3
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing emailcc: :emailcc, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


#################################
##### parse regular options  ####
#################################

### print rstring w/o email to ooofile ####
blockdata = eoln+eoln+"Block Data Parsed::"+eoln
blockdata += rstring+eoln
blockdata += "::Block Data Parsed"+eoln+eoln
blockdata2 = eoln+eoln+"Arrows::"+eoln
blockdata2 += rstring+eoln
blockdata2 += "::Arrows data Parsed"+eoln+eoln

emailall = emailfrom.strip() + " " + emailcc.strip()
print "All emails= " + emailall

### print blockdata to ooofile ####
if (('arrows@emsl.pnl.gov' in emailall) or ('arrows@emsl.pnnl.gov' in emailall) or
    ('arrow5@emsl.pnl.gov' in emailall) or ('arrow5@emsl.pnnl.gov' in emailall)):
   ooofile.write(blockdata)
else:
   ooofile.write(blockdata2)


### findreplace: old text | new text :findreplace  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("FINDREPLACE", "findreplace", rstring)
while ((len(rstring.split("findreplace:"))>1) and (not toolong) and (":findreplace" in rstring)):
   msg2 = rstring.split("findreplace:")
   msg3 = msg2[1].split(":findreplace")[0]
   rstring  = rstring.replace("findreplace:"+msg3+":findreplace","")
   ss = msg3.split("|")
   oldtext = ss[0]
   newtext = ss[1]
   rstring  = rstring.replace(oldtext,newtext)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing findreplace: :findreplace exiting.\n")
   print  "All requests to Arrows were successful."



### look for usesvg keyword ###
usesvg = False
rstring = ireplace("USESVG", "usesvg", rstring)
if "usesvg" in rstring: 
   usesvg = True
   rstring = rstring.replace("usesvg","")

### set how many entries to use ###
use_lowest_energy_esmiles = True
if ('useallentries' in rstring.lower()):
   use_lowest_energy_esmiles = False

### look for nomodelcorrect keyword ###
model_correct = True
rstring = ireplace("NOMODELCORRECT", "nomodelcorrect", rstring)
if "nomodelcorrect" in rstring:
   model_correct = False
   rstring = rstring.replace("nomodelcorrect","")
   ooofile.write("chemdb_fetch_reactions: nomodelcorrect set - low frequency correction turned off\n")


### look for nosubmitmissingesmiles keyword ###
submitmissingesmiles2 = True
rstring = ireplace("NOSUBMITMISSINGESMILES", "nosubmitmissingesmiles", rstring)
if "nosubmitmissingesmiles" in rstring:
   submitmissingesmiles2 = False
   rstring = rstring.replace("nosubmitmissingesmiles","")
submitmissingesmiles = submitmissingesmiles1 and submitmissingesmiles2
missingesmiles = False

### rotatebonds keyword ###
includerotation = False
rstring = ireplace("ROTATEBONDS", "rotatebonds", rstring)
if "rotatebonds" in rstring:
   includerotation = True
   rstring = rstring.replace("rotatebonds","")

### look for queuecheck keyword ###
queuecheck = False
rstring = ireplace("QUEUECHECK", "queuecheck", rstring)
if "queuecheck" in rstring:
   queuecheck = True
   rstring = rstring.replace("queuecheck","")


### look for listnwjobs keyword ###
listnwjobs = False
rstring = ireplace("LISTNWJOBS", "listnwjobs", rstring)
if "listnwjobs" in rstring:
   listnwjobs = True
   rstring = rstring.replace("listnwjobs","")

### name{}  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NAME", "name", rstring)
while ((len(rstring.split("name{"))>1) and (not toolong) and ("}" in rstring)):
   msg2 = rstring.split("name{")
   msg3 = msg2[1].split("}")[0]
   ss = msg3.split()
   rmsg3 = ' name='
   for ll in range(len(ss)-1):
     rmsg3 += ss[ll] + "%20"
   rmsg3 += ss[len(ss)-1]
   rmsg3 += " "
   rstring  = rstring.replace("name{"+msg3+"}",rmsg3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing name{}, exiting.\n")
   print  "All requests to Arrows were successful."


### xyzdata  ###
(rstring,success) = parse_xyzdata(rstring) 
if (not success):
   ooofile.write("chemdb_fetch_reactions: too long parsing xyzdata: :xyzdata, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### submit nmrexp data  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NMR_EXPERIMENT", "nmr_experiment", rstring)
while ((len(rstring.split("nmr_experiment:"))>1) and (not toolong) and (":nmr_experiment" in rstring)):
   msg2 = rstring.split("nmr_experiment:")
   xyz_nmr_data = msg2[1].split(":nmr_experiment")[0]
   rstring  = rstring.replace("nmr_experiment:" + xyz_nmr_data + ":nmr_experiment","")
   msg3 = add_nmrexp(hup,dbfile,nmr_experiments_table,xyz_nmr_data)
   ooofile.write(eoln + msg3 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submitxyz_nmrexp: :submitxyz_nmrexp\n")
   print  "All requests to Arrows were successful."
   exit()


### submit heats of formation  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submit_heat_formation = []
rstring = ireplace("SUBMITHF", "submithf", rstring)
while ((len(rstring.split("submithf:"))>1) and (not toolong) and (":submithf" in rstring)):
   msg2 = rstring.split("submithf:")
   msg3 = msg2[1].split(":submithf")[0]
   rstring  = rstring.replace("submithf:"+msg3+":submithf","")
   msg4 = parsetosmiles(msg3)
   submit_heat_formation.append(msg4)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submithf: :submithf\n")
   print  "All requests to Arrows were successful."
   exit()


### submit esmiles  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submitesmiles = []
rstring = ireplace("SUBMITESMILES", "submitesmiles", rstring)
while ((len(rstring.split("submitesmiles:"))>1) and (not toolong) and (":submitesmiles" in rstring)):
   msg2 = rstring.split("submitesmiles:")
   msg3 = msg2[1].split(":submitesmiles")[0]
   rstring  = rstring.replace("submitesmiles:"+msg3+":submitesmiles","")
   msg4 = addspaces_reaction(msg3.strip())
   msg4 = parsetosmiles(msg4)
   submitesmiles.append(msg4)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parinsg submitesmiles: :submitesmiles\n")
   print  "All requests to Arrows were successful."
   exit()



### submit machines  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
submitmachines = []
rstring = ireplace("SUBMITMACHINES", "submitmachines", rstring)
while ((len(rstring.split("submitmachines:"))>1) and (not toolong) and (":submitmachines" in rstring)):
   msg2 = rstring.split("submitmachines:")
   msg3 = msg2[1].split(":submitmachines")[0]
   rstring  = rstring.replace("submitmachines:"+msg3+":submitmachines","")
   for m in msg3.split():
      submitmachines.append(m)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing submitmachines: :submitmachines, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()
   

### print nwout files ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTNWOUT", "printnwout", rstring)
while ((len(rstring.split("printnwout:"))>1) and (not toolong) and (":printnwout" in rstring)):
   msg2 = rstring.split("printnwout:")
   msg3 = msg2[1].split(":printnwout")[0]
   rstring  = rstring.replace("printnwout:"+msg3+":printnwout","")
   tt = msg3.split()
   for t in tt:
      id = evalnum(t)
      msg4 = fetch_nwout(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printnwout: :printnwout, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### nwoutput ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("NWOUTPUT", "nwoutput", rstring)
while ((len(rstring.split("nwoutput:"))>1) and (not toolong) and (":nwoutput" in rstring)):
   msg2 = rstring.split("nwoutput:")
   msg3 = msg2[1].split(":nwoutput")[0]
   rstring  = rstring.replace("nwoutput:"+msg3+":nwoutput","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No nwoutput data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printnwout: :printnwout option to print nwoutput for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      msg4 = fetch_nwout(hup,dbfile,table,id)
   ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing nwoutput: :nwoutput, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### print jobinfo ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTJOBINFO", "printjobinfo", rstring)
while ((len(rstring.split("printjobinfo:"))>1) and (not toolong) and (":printjobinfo" in rstring)):
   msg2 = rstring.split("printjobinfo:")
   msg3 = msg2[1].split(":printjobinfo")[0]
   rstring  = rstring.replace("printjobinfo:"+msg3+":printjobinfo","")
   tt = msg3.split()
   for t in tt:
      id = evalnum(t)
      msg4 = fetch_jobinfo(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printjobinfo: :printjobinfo, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### print xyz files ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTXYZ", "printxyz", rstring)
while ((len(rstring.split("printxyz:"))>1) and (not toolong) and (":printxyz" in rstring)):
   msg2 = rstring.split("printxyz:")
   msg3 = msg2[1].split(":printxyz")[0]
   rstring  = rstring.replace("printxyz:"+msg3+":printxyz","")
   tt = msg3.split()
   for t in tt: 
      id = evalnum(t)
      msg4 = fetch_xyz(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printxyz: :printxyz, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### xyz files ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("XYZFILE", "xyzfile", rstring)
while ((len(rstring.split("xyzfile:"))>1) and (not toolong) and (":xyzfile" in rstring)):
   msg2 = rstring.split("xyzfile:")
   msg3 = msg2[1].split(":xyzfile")[0]
   rstring  = rstring.replace("xyzfile:"+msg3+":xyzfile","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No xyz data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printxyz: :printxyz option to print xyzfile for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      msg4 = fetch_xyz(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing xyzfile: :xyzfile, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()





### print eigenvalues ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTEIG", "printeig", rstring)
while ((len(rstring.split("printeig:"))>1) and (not toolong) and (":printeig" in rstring)):
   msg2 = rstring.split("printeig:")
   msg3 = msg2[1].split(":printeig")[0]
   rstring  = rstring.replace("printeig:"+msg3+":printeig","")
   tt = msg3.split()
   for t in tt: 
      id = evalnum(t)
      msg4 = fetch_eig(hup,dbfile,table,id)
      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printeig: :printeig, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("EIGENVALUES", "eigenvalues", rstring)
while ((len(rstring.split("eigenvalues:"))>1) and (not toolong) and (":eigenvalues" in rstring)):
   msg2 = rstring.split("eigenvalues:")
   msg3 = msg2[1].split(":eigenvalues")[0]
   rstring  = rstring.replace("eigenvalues:"+msg3+":eigenvalues","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No eigenvalue data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printfreq_id: :printfreq_id or alleigs: :alleigs options to print eigenvalues for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      msg4 += fetch_eig(hup,dbfile,table,id)
   ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing eigenvalues: :eigenvalues, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


toolongcountmax = 200
toolongcount = 0
toolong      = False
rstring = ireplace("ALLEIGS", "alleigs", rstring)
while ((len(rstring.split("alleigs:"))>1) and (not toolong) and (":alleigs" in rstring)):
   msg2 = rstring.split("alleigs:")
   msg3 = msg2[1].split(":alleigs")[0]
   rstring  = rstring.replace("alleigs:"+msg3+":alleigs","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1): 
      msg4 = "No eigenvalue data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      for row in rows:
         id = row[0]
         msg4 += fetch_eig(hup,dbfile,table,id)
   ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing alleigs: :alleigs, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### print frequencies ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTFREQ", "printfreq", rstring)
while ((len(rstring.split("printfreq:"))>1) and (not toolong) and (":printfreq" in rstring)):
   msg2 = rstring.split("printfreq:")
   msg3 = msg2[1].split(":printfreq")[0]
   rstring  = rstring.replace("printfreq:"+msg3+":printfreq","")
   tt = msg3.split()
   for id in tt:
      cmd1 = chemdb_freq + id + " 2"
      print "printfreq cmd1 = " + cmd1
      try:
         msg4 = subprocess.check_output(cmd1,shell=True)
      except:
         msg4 = "frequency analysis failed for id = "+ id
      ooofile.write(eoln+msg4+eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printfreq: :printfreq, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### frequencies ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("FREQUENCIES", "frequencies", rstring)
while ((len(rstring.split("frequencies:"))>1) and (not toolong) and (":frequencies" in rstring)):
   msg2 = rstring.split("frequencies:")
   msg3 = msg2[1].split(":frequencies")[0]
   rstring  = rstring.replace("frequencies:"+msg3+":frequencies","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No frequency data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      msg4 += "Use printfreq: :printfreq or allfreqs: :allfreqs options to print frequencies for other entries.\n"
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      id = rows[0][0]
      cmd1 = chemdb_freq + " %d 2" % id
      print "frequencies cmd1 = " + cmd1
      try:
         msg4 += subprocess.check_output(cmd1,shell=True)
      except:
         msg4 += "frequency analysis failed for id = "+ id
   ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### allfreqs ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("ALLFREQS", "allfreqs", rstring)
while ((len(rstring.split("allfreqs:"))>1) and (not toolong) and (":allfreqs" in rstring)):
   msg2 = rstring.split("allfreqs:")
   msg3 = msg2[1].split(":allfreqs")[0]
   rstring  = rstring.replace("allfreqs:"+msg3+":allfreqs","")
   rows = fetch_esmiles(hup,dbfile,table,msg3,False)
   if (len(rows)<1):
      msg4 = "No frequency data for esmiles = " + msg3
   else:
      msg4 = "The id(s) for emsiles = %s are: " % rows[0][6]
      for row in rows:
         id = row[0]
         msg4 += "%d " %id
      msg4 += "\n"
      for row in rows:
         id = row[0]
         cmd1 = chemdb_freq + " %d 2" % id
         print "allfreqs cmd1 = " + cmd1
         try:
            msg4 += subprocess.check_output(cmd1,shell=True)
         except:
            msg4 += "frequency analysis failed for id = "+ id
   ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing frequencies: :frequencies, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### print csv ###
toolongcountmax = 20
toolongcount = 0
toolong      = False
rstring = ireplace("PRINTCSV", "printcsv", rstring)
while ((len(rstring.split("printcsv:"))>1) and (not toolong) and (":printcsv" in rstring)):
   msg2 = rstring.split("printcsv:")
   msg3 = msg2[1].split(":printcsv")[0]
   rstring  = rstring.replace("printcsv:"+msg3+":printcsv","")
   msg3 = ireplace("COLUMN_TAGS","column_tags", msg3)
   if "column_tags{" in msg3:
      msg4 = msg3.split("column_tags{")[1].split("}")[0]
      msg3 = msg3.replace("column_tags{"+msg4+"}","")
      msg4 = msg4.rstrip(",")
      cc = msg4.split(",")
      columns_list = []
      for c in cc: columns_list.append(c.strip())
   else:
      columns_list = ['id','esmiles']
   msg3 = msg3.strip()
   msg3 = msg3.strip(",")
   ee = msg3.split(",")
   esmiles_list = []
   for e in ee: esmiles_list.append(e.strip())
   msg5 = fetch_csv_esmiles_full(hup,dbfile,table,columns_list,esmiles_list)
   ooofile.write(eoln + msg5 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing printcsv: :printcsv, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### pushnwjob ###
toolongcountmax = 100
toolongcount = 0
toolong      = False
pushnwjob = []
rstring = ireplace("PUSHNWJOB", "pushnwjob", rstring)
while ((len(rstring.split("pushnwjob:"))>1) and (not toolong) and (":pushnwjob" in rstring)):
   msg2 = rstring.split("pushnwjob:")
   msg3 = msg2[1].split(":pushnwjob")[0]
   rstring  = rstring.replace("pushnwjob:"+msg3+":pushnwjob","")
   pushnwjob.append(msg3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
   print "toolong=",toolong,toolongcount
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing pushnwjob: :pushnwjob, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


### find fetchnwjob ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("FETCHNWJOB", "fetchnwjob", rstring)
fetchnwjob = []
while ((len(rstring.split("fetchnwjob:"))>1) and (not toolong) and (":fetchnwjob" in rstring)):
   msg2 = rstring.split("fetchnwjob:")
   msg3 = msg2[1].split(":fetchnwjob")[0]
   rstring  = rstring.replace("fetchnwjob:"+msg3+":fetchnwjob","")
   tt = msg3.split()
   for t in tt: fetchnwjob.append(evalnum(t))
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing fetchnwjob: :fetchnwjob, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### find badids ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("BADIDS", "badids", rstring)
badids = []
while ((len(rstring.split("badids:"))>1) and (not toolong) and (":badids" in rstring)):
   msg2 = rstring.split("badids:")
   msg3 = msg2[1].split(":badids")[0]
   rstring  = rstring.replace("badids:"+msg3+":badids","")
   tt = msg3.split()
   for t in tt: badids.append(evalnum(t))
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing badids: :badids, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


###  molecule  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("MOLECULE", "molecule", rstring)
while ((len(rstring.split("molecule:"))>1) and (not toolong) and (":molecule" in rstring)):
   msg2 = rstring.split("molecule:")
   esmiles = msg2[1].split(":molecule")[0]
   rstring = rstring.replace("molecule:"+esmiles+":molecule","")
   esmiles = addspaces_reaction(esmiles.strip())
   esmiles = parsetosmiles(esmiles)
   esmileslist = formula_to_reactions(hup,dbfile,abbrev_table,esmiles)
   for esmiles in esmileslist:
      rows = fetch_esmiles(hup,dbfile,table,esmiles,False)
      if (len(rows)<1):
         msg4 = "No molecule data for esmiles = " + esmiles + eoln
         missingesmiles = True
         if (submitmissingesmiles):
            rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles,False)
            rows  = fetch_esmiles(hup,dbfile,table,esmiles) #adding to request table
            if (len(rows1)==0):
               msg4 += " - molecule not found : " + esmiles + " scheduled to be submitted." + eoln
               submitesmiles.append(esmiles)
            else:
               msg4 += " - molecule not found : " + esmiles + " has already been scheduled to be submitted." + eoln
         else:
            msg4 += " - molecule not found : " + esmiles + eoln
      else:
         msg4 =  "+==================================================+" + eoln
         msg4 += "||              Molecular Calculation             ||" + eoln
         msg4 += "+==================================================+" + eoln + eoln
         msg4 += "The id(s) for emsiles = %s are: " % rows[0][6]
         for row in rows:
            id = row[0]
            msg4 += "%d " %id
         msg4 += "\n"
         msg4 += "Use printmolecule_id: :printmolecule_id option to print other entries.\n"
         if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
         id = rows[0][0]
         msg4 += fetch_eig(hup,dbfile,table,id)
         cmd1 = chemdb_freq + " %d 2" % id
         print "cmd1 = " + cmd1
         try:
            msg4 += subprocess.check_output(cmd1,shell=True)
         except:
            msg4 += "frequency analysis failed for id = "+ id

      ooofile.write(eoln + msg4 + eoln)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing molecule: :molecule, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()



### print NMR  ###
toolongcountmax = 500
toolongcount = 0
toolong      = False
rstring = ireplace("NMR", "nmr", rstring)
while ((len(rstring.split("nmr:"))>1) and (not toolong) and (":nmr" in rstring)):
   msg2 = rstring.split("nmr:")
   esmiles = msg2[1].split(":nmr")[0]
   rstring = rstring.replace("nmr:"+esmiles+":nmr","")
   esmiles = addspaces_reaction(esmiles.strip())
   esmiles = parsetosmiles(esmiles)
   #rows = fetch_nmr(hup,dbfile,nmr_table,esmiles,False)
   rows = fetch_nmr(hup,dbfile,table,esmiles,False)
   if (len(rows)==0):
      missingesmiles = True
      if (submitmissingesmiles):
         esmiles2 = esmiles + " property{nmr}"
         rows  = fetch_nmr(hup,dbfile,requests_table,esmiles2) #adding to request table
         if (len(rows)==0):
            ooofile.write(" - " + esmiles2 + " not found and scheduled to be submitted."+ eoln)
            submitesmiles.append(esmiles2)
         else:
            ooofile.write(" - " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
      else:
         ooofile.write(" - " + esmiles + " not found."+ eoln)
   else:
      for row in rows:
         msg = print_nmr_row(hup,dbfile,nmr_scaling_table,row)
         ooofile.write(eoln+msg+eoln)

   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing nmr: :nmr, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

#################################
### parse reactionenumeration ###
#################################
toolongcount = 0
toolong      = False
reactionenumerates = []
rstring = ireplace("REACTIONENUMERATE", "reactionenumerate", rstring)
while ((len(rstring.split("reactionenumerate:"))>1) and (not toolong) and (":reactionenumerate" in rstring)):
   msg2 = rstring.split("reactionenumerate:")
   reactionenumerate = msg2[1].split(":reactionenumerate")[0]
   rstring  = rstring.replace("reactionenumerate:"+reactionenumerate+":reactionenumerate","")
   reactionenumerates.append(reactionenumerate)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reactionenumerate: :reactionenumerate, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

### add reactionenumerates to rstring for parsing by parse reactions  ###
for reactionenumerate in reactionenumerates:
   print "reactionenumerate=",reactionenumerate
   rstring += "\n"
   rstring += generate_reactions_from_reactionenumerate(reactionenumerate)
   rstring += "\n"



#################################################################
### convert reactions[]: :reactions  to reactions: :reactions ###
#################################################################
rstring = ireplace("REACTION", "reaction", rstring)
toolongcount = 0
toolong      = False
while ((len(rstring.split("reaction["))>1) and (not toolong) and (":reaction" in rstring)):
   msg2 = rstring.split("reaction[")
   msg3 = msg2[1].split(":reaction")[0]
   optiontag = msg3.split("]:")[0].strip()
   rr = msg3.split("]:")[1]
   rr = rr.replace("\t"," ")
   rr = rr.replace("\n"," ")
   rr = rr.replace('\xc2', ' ')
   rr = rr.replace('\xa0', ' ')
   rr = rr.replace(" + "," " + optiontag + " + ")
   rr = rr.replace("-->"," " + optiontag + " --> ")
   rr = rr + " " + optiontag
   convertreaction = "reaction: " + rr + " :reaction"
   rstring  = rstring.replace("reaction["+msg3+":reaction",convertreaction)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reaction[]: :reaction, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()


#######################
### parse reactions ###
#######################
### set how many entries to use ###
use_lowest_energy_esmiles = True
if ('useallentries' in rstring.lower()):
   use_lowest_energy_esmiles = False

asciiart_data       = []
toolongcount = 0
toolong      = False
reactions = []
rstring = ireplace("REACTION", "reaction", rstring)
while ((len(rstring.split("reaction:"))>1) and (not toolong) and (":reaction" in rstring)):
   msg2 = rstring.split("reaction:")
   reaction = msg2[1].split(":reaction")[0]
   rstring  = rstring.replace("reaction:"+reaction+":reaction","")
   reaction2 = expand_reaction(reaction.strip())
   reaction2 = addspaces_reaction(reaction2.strip())
   reaction3 = parsetosmiles(reaction2)
   #### need to fix this logic #####
   if (reaction3.find("*")!=-1):
      reaction3 = reaction3.replace("*}","&}")
      reaction3 = reaction3.replace("*"," ")
      reaction3 = reaction3.replace("&}","*}")
   #if (reaction3.find(".")!=-1):
   #   reaction3 = reaction3.replace("."," + ")
   #reactions.append(reaction3)
   reactions += formula_to_reactions(hup,dbfile,abbrev_table,reaction3)
   toolong = (toolongcount > toolongcountmax)
   toolongcount += 1
if (toolong):
   ooofile.write("chemdb_fetch_reactions: too long parsing reaction: :reaction, exiting.\n")
   print  "All requests to Arrows were successful."
   exit()

if (len(reactions)<1):
   print "no reactions found, exiting"
else:
   print "reactions=",reactions

reaction_data = []
reactioncount = 0
erxnfile = open(wrkdir+"/"+tmperxn,'w')
addedtoerxnfile = False

for reaction in reactions:
   reactioncount += 1
   rlink =  "https://arrows.emsl.pnnl.gov/api/reaction/%22" + reaction.strip() + "%22"
   htmlreactionlink = "<a href=\"" + rlink.replace('#','%23') + "\">%s</a>" % reaction.strip()
   #ooofile.write(eoln+eoln+eoln + "Reaction %d: " % (reactioncount)  + reaction.strip()+ eoln)
   ooofile.write(eoln+eoln+eoln + "Reaction %d: " % (reactioncount)  + htmlreactionlink+ eoln)

   sslist = reaction.split("-->")
   left  = sslist[0].strip()
   left = left.replace("\t"," ")
   left = left.replace("\n"," ")
   #left = left.decode('ascii', 'replace')
   left = left.replace('\xc2', ' ')
   left = left.replace('\xa0', ' ')
   esmiles_reactants  = left.split(' + ')
   number_reactants = len(esmiles_reactants)

   if (len(sslist)>1):
      right = sslist[1].strip()
      right= right.replace("\t"," ")
      right= right.replace("\n"," ")
      right= right.replace('\xc2', ' ')
      right= right.replace('\xa0', ' ')
      esmiles_products   = right.split(' + ')
      number_products  = len(esmiles_products)
   else:
      esmiles_products = esmiles_reactants
      number_products  = number_reactants
      esmiles_reactants = []
      number_reactants = 0

   #### SHE option ####
   SHE_reactant_string = ''
   SHE = 0.0
   eetmp = []
   for er in esmiles_reactants:
      if "SHE" in er:
         try:
            x = float(er.split(None,1)[0])
         except:
            x = 1.0
         SHE += 98.6*x
         SHE_reactant_string += ' + %.2f SHE ^{-1}' % x
      else:
         eetmp.append(er)
   esmiles_reactants = eetmp
   number_reactants = len(esmiles_reactants)

   SHE_product_string = ''
   eetmp = []
   for ep in esmiles_products:
      if "SHE" in ep:
         try:
            x = float(ep.split(None,1)[0])
         except:
            x = 1.0
         SHE -= (98.6*x)
         SHE_product_string += ' + %.2f SHE ^{-1}' % x
      else:
         eetmp.append(ep)
   esmiles_products = eetmp
   number_products  = len(esmiles_products)

   print
   print "esmiles_reactants=",esmiles_reactants
   print "esmiles_products =",esmiles_products
   print "numbers=",number_reactants,number_products

   ### get the reactants from the database ###
   asciiart_data       = []
   energy_reactants    = []
   enthalpy_reactants  = []
   entropy_reactants   = []
   solvation_type_reactants = []
   solvation_reactants      = []
   sitkoff_reactants        = []
   honig_reactants          = []

   npaths = 1
   path   = []
   mcount_reactants = []
   data_reactants = []
   for esmiles in esmiles_reactants:
      try:
         x = float(esmiles.split(None,1)[0])
         mcount_reactants.append(x)
         esmiles2 = esmiles.split(None,1)[1]
      except:
         mcount_reactants.append(1.0)
         esmiles2 = esmiles
      rows  = fetch_esmiles(hup,dbfile,table,esmiles2,False)
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      data_reactants.append(rows)
      npaths *= len(rows)
      path.append(len(rows))
      if (len(rows)>0):
         iupac    = rows[0][1]
         asciiart = stripWARNINGS(rows[0][34])
         tstr = "Compound = " + iupac + eoln 
         tstr += "twirl webpage  = %s\n" % (smiles2twirl(rows[0][4])) 
         tstr += "image webpage  = %s\n\n" % (smiles2image(rows[0][4]))
         tstr += asciiart + eoln
         asciiart_data.append(tstr)
      if (len(rows)==0):
         missingesmiles = True
         if (submitmissingesmiles): 
            rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles2,False)
            rows  = fetch_esmiles(hup,dbfile,table,esmiles2) #adding to request table
            if (len(rows1)==0):
               ooofile.write(" - reactant not found: " + esmiles2 + " scheduled to be submitted."+ eoln)
               submitesmiles.append(esmiles2)
            else:
               ooofile.write(" - reactant not found: " + esmiles2 + " has already been scheduled to be submitted."+ eoln)
         else:
            ooofile.write(" - reactant not found: " + esmiles2 + eoln)

   mcount_products = []
   data_products  = []
   for esmiles in esmiles_products:
      try:
         x = float(esmiles.split(None,1)[0])
         mcount_products.append(x)
         esmiles2 = esmiles.split(None,1)[1]
      except:
         mcount_products.append(1.0)
         esmiles2 = esmiles
      rows = fetch_esmiles(hup,dbfile,table,esmiles2,False)
      if (use_lowest_energy_esmiles): rows = lowest_energy_esmiles(rows)
      data_products.append(rows)
      npaths *= len(rows)
      path.append(len(rows))
      if (len(rows)>0):
         iupac    = rows[0][1]
         asciiart = stripWARNINGS(rows[0][34])
         tstr = "Compound = " + iupac + eoln 
         tstr += "twirl webpage  = %s\n" % (smiles2twirl(rows[0][4])) 
         tstr += "image webpage  = %s\n\n" % (smiles2image(rows[0][4]))
         tstr += asciiart + eoln
         asciiart_data.append(tstr)
      if (len(rows)==0):
         missingesmiles = True
         if (submitmissingesmiles):
            rows1 = fetch_esmiles(hup,dbfile,requests_table,esmiles2,False)
            print "ROWS1 = ",rows1
            rows = fetch_esmiles(hup,dbfile,table,esmiles2) #adding to request table
            if (len(rows1)==0):
               ooofile.write(" - product not found : " + esmiles2 + " scheduled to be submitted." + eoln)
               submitesmiles.append(esmiles2)
            else:
               ooofile.write(" - product not found : " + esmiles2 + " has already been scheduled to be submitted." + eoln)
         else:
            ooofile.write(" - product not found : " + esmiles2 + eoln)
      

   pathcount = [0]*len(path)

   instance_paths_data = []
   ggresults = []
   for p in range(npaths):
      uniqueresult = True
      pathstr = " - instance %d: " % (p+1)
      msg0 = pathstr + "  "
      msg1 = pathstr
      msg1f = pathstr
      msg2 = pathstr
      msg3 = pathstr
      msg4 = pathstr
      msg4b = pathstr
      msg5 = pathstr
      energy_reactants = []
      enthalpy_reactants = []
      entropy_reactants = []
      solvation_type_reactants = []
      solvation_reactants = []
      sitkoff_reactants = []
      for ir in range(number_reactants):
         x = mcount_reactants[ir]
         molecule = data_reactants[ir][pathcount[ir]]
         if (model_correct):
            (tmp_enthalpy,tmp_entropy) = model_correct_frequencies(molecule)
         else:
            tmp_enthalpy = molecule[15]
            tmp_entropy  = molecule[16]
         energy_reactants.append(x*molecule[14])
         #enthalpy_reactants.append(x*molecule[15])
         #entropy_reactants.append(x*molecule[16])
         enthalpy_reactants.append(x*tmp_enthalpy)
         entropy_reactants.append(x*tmp_entropy)
         solvation_type_reactants.append(molecule[17])
         solvation_reactants.append(x*molecule[18])
         sitkoff_reactants.append(x*molecule[19])

         msg0 += "%.2f %s" % (x,molecule2esmiles(molecule))
         if (ir<(number_reactants-1)): msg0 += "\n" + pathstr + "+ "
         msg1 += "%.2f %s" % (x,molecule[1])
         if (ir<(number_reactants-1)): msg1 += " + "
         msg1f += "%.2f %s" % (x,molecule[2])
         if (ir<(number_reactants-1)): msg1f += " + "
         ss0 = "Id=%d" % molecule[0]
         link = "https://arrows.emsl.pnnl.gov/api/molecule/%22" + ss0 + "%22"
         gink = "<a href=\"" + link + "\">%s</a>" % ss0
         msg2 += "%.2f (%s)" % (x,gink)
         #msg2 += "%.2f (Id=%d)" % (x,molecule[0])
         #msg2 += "%.2f (Id=%d)" % (x,molecule[0])
         if (ir<(number_reactants-1)): msg2 += " + "
         if molecule[0] in badids: uniqueresult = False

      msg0  += SHE_reactant_string
      msg1  += SHE_reactant_string
      msg1f += SHE_reactant_string
      msg2  += SHE_reactant_string

      msg0 += "\n" + pathstr + "  --> "
      msg1 += " --> "
      msg1f += " --> "
      msg2 += " --> "
      energy_products = []
      enthalpy_products = []
      entropy_products = []
      solvation_type_products = []
      solvation_products = []
      sitkoff_products = []
      for ip in range(number_products):
         x = mcount_products[ip]
         molecule = data_products[ip][pathcount[ip+number_reactants]]
         if (model_correct):
            (tmp_enthalpy,tmp_entropy) = model_correct_frequencies(molecule)
         else:
            tmp_enthalpy = molecule[15]
            tmp_entropy  = molecule[16]
         energy_products.append(x*molecule[14])
         #enthalpy_products.append(x*molecule[15])
         #entropy_products.append(x*molecule[16])
         enthalpy_products.append(x*tmp_enthalpy)
         entropy_products.append(x*tmp_entropy)
         solvation_type_products.append(molecule[17])
         solvation_products.append(x*molecule[18])
         sitkoff_products.append(x*molecule[19])

         msg0 += "%.2f %s" % (x,molecule2esmiles(molecule))
         if (ip<(number_products-1)): msg0 += "\n" + pathstr + "    + "
         msg1 += "%.2f %s" % (x,molecule[1])
         if (ip<(number_products-1)): msg1 += " + "
         msg1f += "%.2f %s" % (x,molecule[2])
         if (ip<(number_products-1)): msg1f += " + "
         msg2 += "%.2f (Id=%d)" % (x,molecule[0])
         if (ip<(number_products-1)): msg2 += " + "
         if molecule[0] in badids: uniqueresult = False

      delta_e = sum(energy_products) - sum(energy_reactants)
      delta_h = sum(enthalpy_products) - sum(enthalpy_reactants)
      delta_s = sum(entropy_products) - sum(entropy_reactants)
      delta_cosmo = sum(solvation_products) - sum(solvation_reactants)
      delta_sitkoff = sum(sitkoff_products) - sum(sitkoff_reactants)
      delta_solv = 0.0
      if (solvation_type_products[0]=='COSMO'):     delta_solv = -delta_cosmo + delta_sitkoff
      if ('COSMO-SMD' in solvation_type_products[0]): delta_solv = delta_cosmo
      #autokcal=27.2114*23.06
      #autokj  =27.2114*23.06*4.184
      autokcal= 627.509469
      autokj  = 2625.49962
      tempfac = 298.15/1000.0

      msg0  += SHE_product_string
      msg1  += SHE_product_string
      msg1f += SHE_product_string
      msg2  += SHE_product_string

      #msg3 += "Erxn(gas)=%8.3f kcal/mol " % (delta_e*autokcal)
      #msg3 += "Hrxn(gas)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal)
      #msg3 += "Grxn(gas)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal-tempfac*delta_s)
      #msg3 += "Delta Solvation=%8.3f kcal/mol " % (delta_solv)
      #msg3 += "Grxn(aq)=%8.3f kcal/mol " % ((delta_e+delta_h)*autokcal-tempfac*delta_s + delta_solv)

      msg3 += "       Erxn(gas)"
      msg3 += "       Hrxn(gas)"
      msg3 += "       Grxn(gas)"
      msg3 += " Delta_Solvation"
      msg3 += "        Grxn(aq)"

      msg4 += " %15.3f" % (delta_e*autokcal)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s)
      msg4 += " %15.3f" % (delta_solv)
      msg4 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s + delta_solv + SHE)
      if (abs(SHE)>(0.01)):
         msg4 += "  -- in kcal/mol (electrode bias =%8.3f kcal/mol)" % SHE
      else:
         msg4 += "  -- in kcal/mol"

      msg4b += " %15.3f" % (delta_e*autokj)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj-tempfac*delta_s*4.184)
      msg4b += " %15.3f" % (delta_solv*4.184)
      msg4b += " %15.3f" % ((delta_e+delta_h)*autokj-tempfac*delta_s*4.184 + (delta_solv+SHE)*4.184)
      msg4b += "  -- in kj/mol"

      msg5 += " %15.6f" % (delta_e)
      msg5 += " %15.6f" % ((delta_e+delta_h))
      msg5 += " %15.6f" % ((delta_e+delta_h)-tempfac*delta_s/autokcal)
      msg5 += " %15.6f" % (delta_solv/autokcal)
      msg5 += " %15.6f" % ((delta_e+delta_h)-tempfac*delta_s/autokcal + (delta_solv+SHE)/autokcal)
      msg5 += "  -- in Hartrees"

      msg6  = " %d" % (reactioncount)
      msg6 += " %15.3f" % (delta_e*autokcal)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s)
      msg6 += " %15.3f" % (delta_solv)
      msg6 += " %15.3f" % ((delta_e+delta_h)*autokcal-tempfac*delta_s + (delta_solv+SHE))

      instance = []
      instance.append(delta_e)
      instance.append(delta_e+delta_h)
      instance.append(delta_e+delta_h -tempfac*delta_s/autokcal)
      instance.append(delta_solv/autokcal)
      instance.append(delta_e+delta_h-tempfac*delta_s/autokcal + (delta_solv+SHE)/autokcal)
      instance_paths_data.append(instance)

      ggcur =  (delta_e+delta_h)*autokcal-tempfac*delta_s + (delta_solv+SHE)
      for gg in ggresults:
         if (abs(gg-ggcur)<1.0e-3): uniqueresult = False
      ggresults.append(ggcur)

      if (uniqueresult):
         ooofile.write(msg2+eoln)
         ooofile.write(msg1+eoln)
         ooofile.write(msg1f+eoln)
         ooofile.write(msg0+eoln)
         ooofile.write(msg3+eoln)
         ooofile.write(msg4+eoln)
         ooofile.write(msg4b+eoln)
         ooofile.write(msg5+eoln+eoln)
         erxnfile.write(msg6+eoln)
         addedtoerxnfile = True

      ### shift the path ###
      done = False; i = 0
      while (not done):
         if (pathcount[i]<path[i]):
            pathcount[i] += 1
            if (pathcount[i]<path[i]):
               done = True
            else:
               pathcount[i] = 0
               i += 1
         if (i>=len(path)): done = True

   ### append the reaction data reaction_data ###
   reaction_data.append([reaction,instance_paths_data])

   ### print asciiart ###
   if (len(asciiart_data)>0):
      ooofile.write("</pre>\n")
      ooofile.write("<pre style=\"font-size:0.5em;color:magenta\">\n")
      #ooofile.write("----------------------------------------------------------------------------\n")
      ooofile.write("-------------------------------------------------------------------------\n")
      for asciiart in asciiart_data:
         ooofile.write(asciiart)
         ooofile.write("-------------------------------------------------------------------------\n")
      ooofile.write("</pre>\n")
      ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")

   
   
erxnfile.close()



#### make dumb plots ####
if (addedtoerxnfile) and (len(reactions)>1):
   erxngnuplot  = wrkdir + "/erxn-%d.gnuplot" % ddrand
   hrxngnuplot  = wrkdir + "/hrxn-%d.gnuplot" % ddrand
   grxngnuplot  = wrkdir + "/grxn-%d.gnuplot" % ddrand
   gsrxngnuplot = wrkdir + "/gsrxn-%d.gnuplot" % ddrand

   erxndumb  = wrkdir + "/erxn-%d.dumb" % ddrand
   hrxndumb  = wrkdir + "/hrxn-%d.dumb" % ddrand
   grxndumb  = wrkdir + "/grxn-%d.dumb" % ddrand
   gsrxndumb = wrkdir + "/gsrxn-%d.dumb" % ddrand
   eedatafile = wrkdir+"/"+ tmperxn

   #erxn = 'set output \"%s\"; set term dumb; set grid; set title \"Reaction Erxn(gas) (kcal/mol)\"; set xlabel \"reaction number\";  plot \"%s\" with lp pointtype 5' % (erxndumb,eedatafile)
   erxn = 'set output \"%s\"; set term dumb; set title \"Reaction Erxn(gas) (kcal/mol)\"; set xlabel \"reaction number\";  plot \"%s\" with lp pointtype 5' % (erxndumb,eedatafile)

   hrxn = 'set output \"%s\"; set term dumb; set title \"Reaction Hrxn(gas) (kcal/mol)\"; set xlabel \"reaction number\";  plot \"%s\" using 1:3 with lp pointtype 8' % (hrxndumb,eedatafile)

   grxn = 'set output \"%s\"; set term dumb; set title \"Reaction Grxn(gas) (kcal/mol)\"; set xlabel \"reaction number\";  plot \"%s\" using 1:4 with lp pointtype 7' % (grxndumb,eedatafile)

   gsrxn = 'set output \"%s\"; set term dumb; set title \"Reaction Grxn(aq) (kcal/mol)\"; set xlabel \"reaction number\";  plot \"%s\" using 1:6 with lp pointtype 19' % (gsrxndumb,eedatafile)

   with open(erxngnuplot,'w')  as f: f.write(erxn+eoln)
   with open(hrxngnuplot,'w')  as f: f.write(hrxn+eoln)
   with open(grxngnuplot,'w')  as f: f.write(grxn+eoln)
   with open(gsrxngnuplot,'w') as f: f.write(gsrxn+eoln)

   os.system(gnuplot + erxngnuplot)
   os.system(gnuplot + hrxngnuplot)
   os.system(gnuplot + grxngnuplot)
   os.system(gnuplot + gsrxngnuplot)
   ooofile.write("</pre>\n")
   ooofile.write("<pre style=\"font-size:0.6em;color:black\">\n")
   with open(erxndumb,'r')  as f: msg = f.read(); ooofile.write(msg)
   with open(hrxndumb,'r')  as f: msg = f.read(); ooofile.write(msg)
   with open(grxndumb,'r')  as f: msg = f.read(); ooofile.write(msg)
   with open(gsrxndumb,'r') as f: msg = f.read(); ooofile.write(msg)
   ooofile.write("</pre>\n")
   ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")


   try:
      os.unlink(erxngnuplot)
      os.unlink(hrxngnuplot)
      os.unlink(grxngnuplot)
      os.unlink(gsrxngnuplot)
      os.unlink(erxndumb)
      os.unlink(hrxndumb)
      os.unlink(grxndumb)
      os.unlink(gsrxndumb)
   except:
      print "Failed to delete temporary gnuplot files"


### print reaction tables ###
shift = 0
for reactionenumerate in reactionenumerates:
   (rr,ss) = maketable_from_reactionenumerate(reactionenumerate,reaction_data[shift:])
   shift += ss
   ooofile.write(rr)



### add reaction_data to reactionhash database ###
for reaction in reaction_data:
   try:
      print "Adding to reaction database=",reaction
      Erxn     = reaction[1][0][0]*autokcal
      Hrxn     = reaction[1][0][1]*autokcal
      Grxn     = reaction[1][0][2]*autokcal
      Solv     = reaction[1][0][3]*autokcal
      Grxnaq   = reaction[1][0][4]*autokcal
      cmd9 = chemdb_predict_reaction + " -e %f -r %f -g %f -q %f -u %f  -a " % (Erxn,Hrxn,Grxn,Solv,Grxnaq)
      cmd9 += "\"" + reaction[0] + "\""
      print "cmd9=",cmd9
      result9 = subprocess.check_output(cmd9,shell=True)
      print "adding reaction result=",result9
   except:
      print "Failed adding adding reaction =", reaction[0]


#### print asciiart ###
#if (len(asciiart_data)>0):
#   ooofile.write("</pre>\n")
#   ooofile.write("<pre style=\"font-size:0.5em;color:magenta\">\n")
#   ooofile.write("----------------------------------------------------------------------------\n")
#   for asciiart in asciiart_data:
#      ooofile.write(asciiart)
#      ooofile.write("-------------------------------------------------------------------------\n")
#   ooofile.write("</pre>\n")
#   ooofile.write("<pre style=\"font-size:0.6em;color:blue\">\n")

#### submit missing esmiles ####
if (submitmissingesmiles):
   nmach = len(submitmachines)
   i = 0
   for esmiles in submitesmiles:
    try:
      ### fetch the datafile ###
      datafile = fetch_esmiles_base_datafile(hup,dbfile,table,esmiles)
      esmiles1 = esmileswithid_to_esmiles(hup,dbfile,table,esmiles)
      esmiles1 = esmileswithname_to_esmiles(esmiles1.strip())
      print "esmiles=",esmiles,"  esmiles1=",esmiles1
      print "datafile=",datafile

      if (datafile=='') and (("ccsd(t)" in esmiles) or ("mp2" in esmiles)):
         mmsg = "Base calculation not found: not submitting esmiles="+esmiles+"\n"
         print mmsg
         ooofile.write(mmsg)
      else:
         vtag = ''
         if (nmach>0):
            msg4 = submit_esmiles(esmiles1,includerotation,datafile,emailfrom,submitmachines[i])
            i += 1
            i = i % nmach
         else:
            msg4 = submit_esmiles(esmiles1,includerotation,datafile,emailfrom)
         ooofile.write(eoln + msg4 + eoln)
    except:
      mmsg = "Error: not submitting esmiles="+esmiles+"\n"
      print mmsg
      ooofile.write(mmsg)
   listnwjobs = listnwjobs or (len(submitesmiles)>0)
   listnwjobs = False


#### submit_heat_formation ####
for esmiles in submit_heat_formation:
   cmd1 = chemdb_add_Hf + '"' + esmiles.strip() + '"'
   print "chemdb_add_Hf = " + cmd1
   try:
      result = subprocess.check_output(cmd1,shell=True)
   except:
      result = "\n\nchemdb_add_Hf failed and job was not submitted\n\n"
   ooofile.write(eoln+result+eoln)
   print result


#### queuecheck ####
if (queuecheck):
   cmd1 = tnt_submit + " -i"
   print "queuecheck cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   print result

#### listnwjobs ####
if (listnwjobs):
   cmd1 = queue_nwchem_em + " -a -s -m None"
   print "listnwjobs cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   print result

#### fetchnwjob ####
for f in fetchnwjob:
   cmd1 = queue_nwchem_em + " -f %d -m %s " % (f,emailfrom)
   print "fetchwjob cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   print result

#### pushnwjob ####
for aa in pushnwjob:
   with open(wrkdir + "/"+tmpsmi1,'w') as ff: ff.write(aa)
   cmd1 = queue_nwchem_em + " -w  " + wrkdir + "/"+ tmpsmi1
   print "pushwjob cmd1 = " + cmd1
   result = subprocess.check_output(cmd1,shell=True)
   ooofile.write(result)
   print result

##### report missingesmiles #####
if (missingesmiles):
   msg = "Several requests to Arrows were not successful."
else:
   msg = "All requests to Arrows were successful."
ooofile.write(eoln+msg+eoln)
print eoln+msg+eoln


### add simple arrows logo 
#afile = open(arrowslogo,'r')
#alogo = afile.read()
#afile.close

if usesvg:
   ooofile.write(alogosvg)
else:
   ooofile.write(alogo)

ooofile.write("</pre>\n")

ooofile.write("</html>\n")
ooofile.close()

#for molecule in rows:
#   print "Id=%6d iupac=%s csmiles=%s charge=%d mult=%d method=%s theory=%s basis=%s \tE=%14.6f  Enthalpy=%14.6f Entropy=%8.3f solvation=%8.3f sitkoff=%8.3f" % (molecule[0],molecule[1],molecule[4],molecule[12],molecule[13],molecule[9],molecule[10],molecule[11],molecule[14],molecule[15],molecule[16],molecule[18],molecule[19])


### remove temporary wrkdir files ###
try:
   os.unlink(wrkdir + "/"+tmpsmi1)
except:
   print "chemdb_fetch_reactions4 Failed to remove " + wrkdir + "/"+ tmpsmi1

try:
   os.unlink(wrkdir + "/"+tmpsmi2)
except:
   print "chemdb_fetch_reactions4 Failed to remove " + wrkdir + "/"+ tmpsmi2

try:
   os.unlink(wrkdir + "/"+tmpxyz1)
except:
   print "chemdb_fetch_reactions4 Failed to remove " + wrkdir + "/"+ tmpxyz1

try:
   os.unlink(wrkdir + "/"+tmperxn)
except:
   print "chemdb_fetch_reactions4 Failed to remove " + wrkdir + "/"+ tmperxn

try:
   os.unlink(wrkdir + "/"+tmpnwout)
except:
   print "chemdb_fetch_reactions4 Failed to remove " + wrkdir + "/"+ tmpnwout

